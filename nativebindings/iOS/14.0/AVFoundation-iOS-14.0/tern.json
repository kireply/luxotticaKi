{
	"NSURLSessionDataTask": {
		"jsnew": {
			"!type": "fn() -> +NSURLSessionDataTask"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionDataTask"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLSessionDataTask"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLSessionDataTask"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionDataTask"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"countOfBytesSent": {
				"!type": "number"
			},
			"earliestBeginDate": {
				"!type": "+Date"
			},
			"countOfBytesExpectedToReceive": {
				"!type": "number"
			},
			"taskDescription": {
				"!type": "string"
			},
			"countOfBytesExpectedToSend": {
				"!type": "number"
			},
			"state": {
				"!type": "number"
			},
			"priority": {
				"!type": "number"
			},
			"countOfBytesClientExpectsToSend": {
				"!type": "number"
			},
			"taskIdentifier": {
				"!type": "number"
			},
			"countOfBytesReceived": {
				"!type": "number"
			},
			"error": {
				"!type": "+NSError"
			},
			"currentRequest": {
				"!type": "+NSURLRequest"
			},
			"progress": {
				"!type": "+NSProgress"
			},
			"countOfBytesClientExpectsToReceive": {
				"!type": "number"
			},
			"response": {
				"!type": "+NSURLResponse"
			},
			"originalRequest": {
				"!type": "+NSURLRequest"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionDataTask"
			},
			"suspend": {
				"!type": "fn() -> void"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"resume": {
				"!type": "fn() -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionDataTask"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionDataTask"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSLinguisticTagger": {
		"enumerateTagsForStringRangeUnitSchemeOptionsOrthographyUsingBlock": {
			"!type": "fn(string: string, range: +Object, unit: number, scheme: string, options: number, orthography: +NSOrthography, block: +Function) -> void"
		},
		"availableTagSchemesForLanguage": {
			"!type": "fn(language: string) -> +Array"
		},
		"availableTagSchemesForUnitLanguage": {
			"!type": "fn(unit: number, language: string) -> +Array"
		},
		"tagsForStringRangeUnitSchemeOptionsOrthographyTokenRanges": {
			"!type": "fn(string: string, range: +Object, unit: number, scheme: string, options: number, orthography: +NSOrthography, tokenRanges: +Object) -> +Array"
		},
		"dominantLanguageForString": {
			"!type": "fn(string: string) -> string"
		},
		"tagForStringAtIndexUnitSchemeOrthographyTokenRange": {
			"!type": "fn(string: string, charIndex: number, unit: number, scheme: string, orthography: +NSOrthography, tokenRange: +Object) -> string"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSLinguisticTagger"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSLinguisticTagger"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSLinguisticTagger"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"dominantLanguage": {
				"!type": "string"
			},
			"string": {
				"!type": "string"
			},
			"tagSchemes": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithTagSchemesOptions": {
				"!type": "fn(tagSchemes: +Array, opts: number) -> +NSLinguisticTagger"
			},
			"setOrthographyRange": {
				"!type": "fn(orthography: +NSOrthography, range: +Object) -> void"
			},
			"tokenRangeAtIndexUnit": {
				"!type": "fn(charIndex: number, unit: number) -> +Object"
			},
			"tagAtIndexUnitSchemeTokenRange": {
				"!type": "fn(charIndex: number, unit: number, scheme: string, tokenRange: +Object) -> string"
			},
			"enumerateTagsInRangeSchemeOptionsUsingBlock": {
				"!type": "fn(range: +Object, tagScheme: string, opts: number, block: +Function) -> void"
			},
			"possibleTagsAtIndexSchemeTokenRangeSentenceRangeScores": {
				"!type": "fn(charIndex: number, tagScheme: string, tokenRange: +Object, sentenceRange: +Object, scores: +Object) -> +Array"
			},
			"orthographyAtIndexEffectiveRange": {
				"!type": "fn(charIndex: number, effectiveRange: +Object) -> +NSOrthography"
			},
			"enumerateTagsInRangeUnitSchemeOptionsUsingBlock": {
				"!type": "fn(range: +Object, unit: number, scheme: string, options: number, block: +Function) -> void"
			},
			"tagAtIndexSchemeTokenRangeSentenceRange": {
				"!type": "fn(charIndex: number, scheme: string, tokenRange: +Object, sentenceRange: +Object) -> string"
			},
			"tagsInRangeSchemeOptionsTokenRanges": {
				"!type": "fn(range: +Object, tagScheme: string, opts: number, tokenRanges: +Object) -> +Array"
			},
			"tagsInRangeUnitSchemeOptionsTokenRanges": {
				"!type": "fn(range: +Object, unit: number, scheme: string, options: number, tokenRanges: +Object) -> +Array"
			},
			"sentenceRangeForRange": {
				"!type": "fn(range: +Object) -> +Object"
			},
			"stringEditedInRangeChangeInLength": {
				"!type": "fn(newRange: +Object, delta: number) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSLinguisticTagger"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitConcentrationMass": {
		"millimolesPerLiterWithGramsPerMole": {
			"!type": "fn(gramsPerMole: number) -> +NSUnitConcentrationMass"
		},
		"gramsPerLiter": {
			"!type": "fn() -> +NSUnitConcentrationMass"
		},
		"milligramsPerDeciliter": {
			"!type": "fn() -> +NSUnitConcentrationMass"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitConcentrationMass"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitConcentrationMass"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitConcentrationMass"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitConcentrationMass"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitConcentrationMass"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitConcentrationMass"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitConcentrationMass"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnitDelay": {
		"instantiateWithComponentDescriptionOptionsCompletionHandler": {
			"!type": "fn(audioComponentDescription: +Object, options: number, completionHandler: +Function) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnitDelay"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnitDelay"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnitDelay"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"wetDryMix": {
				"!type": "number"
			},
			"delayTime": {
				"!type": "number"
			},
			"feedback": {
				"!type": "number"
			},
			"lowPassCutoff": {
				"!type": "number"
			},
			"bypass": {
				"!type": "bool"
			},
			"name": {
				"!type": "string"
			},
			"audioComponentDescription": {
				"!type": "+Object"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"version": {
				"!type": "number"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithAudioComponentDescription": {
				"!type": "fn(audioComponentDescription: +Object) -> +AVAudioUnitDelay"
			},
			"loadAudioUnitPresetAtURLError": {
				"!type": "fn(url: +NSURL, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnitDelay"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnit": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnit"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnit"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnit"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnit"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnit"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSString": {
		"stringWithCStringLength": {
			"!type": "fn(bytes: +Object, length: number) -> +Object"
		},
		"defaultCStringEncoding": {
			"!type": "fn() -> number"
		},
		"stringWithContentsOfFile": {
			"!type": "fn(path: string) -> +Object"
		},
		"string": {
			"!type": "fn() -> string"
		},
		"stringEncodingForDataEncodingOptionsConvertedStringUsedLossyConversion": {
			"!type": "fn(data: +NSData, opts: +Object, string: +Object, usedLossyConversion: +Object) -> number"
		},
		"stringWithUTF8String": {
			"!type": "fn(nullTerminatedCString: +Object) -> string"
		},
		"stringWithCString": {
			"!type": "fn(bytes: +Object) -> +Object"
		},
		"stringWithContentsOfFileUsedEncodingError": {
			"!type": "fn(path: string, enc: +Object, error: +Object) -> string"
		},
		"stringWithContentsOfURL": {
			"!type": "fn(url: +NSURL) -> +Object"
		},
		"stringWithCharactersLength": {
			"!type": "fn(characters: +Object, length: number) -> string"
		},
		"pathWithComponents": {
			"!type": "fn(components: +Array) -> string"
		},
		"localizedStringWithFormat": {
			"!type": "fn(format: string, args: Array.prototype) -> string"
		},
		"availableStringEncodings": {
			"!type": "fn() -> +Object"
		},
		"stringWithContentsOfFileEncodingError": {
			"!type": "fn(path: string, enc: number, error: +Object) -> string"
		},
		"localizedNameOfStringEncoding": {
			"!type": "fn(encoding: number) -> string"
		},
		"stringWithCStringEncoding": {
			"!type": "fn(cString: +Object, enc: number) -> string"
		},
		"stringWithFormat": {
			"!type": "fn(format: string, args: Array.prototype) -> string"
		},
		"stringWithString": {
			"!type": "fn(string: string) -> string"
		},
		"stringWithContentsOfURLUsedEncodingError": {
			"!type": "fn(url: +NSURL, enc: +Object, error: +Object) -> string"
		},
		"stringWithContentsOfURLEncodingError": {
			"!type": "fn(url: +NSURL, enc: number, error: +Object) -> string"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> string"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> string"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> string"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"stringByRemovingPercentEncoding": {
				"!type": "string"
			},
			"stringByStandardizingPath": {
				"!type": "string"
			},
			"doubleValue": {
				"!type": "number"
			},
			"boolValue": {
				"!type": "bool"
			},
			"stringByAbbreviatingWithTildeInPath": {
				"!type": "string"
			},
			"description": {
				"!type": "string"
			},
			"decomposedStringWithCanonicalMapping": {
				"!type": "string"
			},
			"smallestEncoding": {
				"!type": "number"
			},
			"uppercaseString": {
				"!type": "string"
			},
			"length": {
				"!type": "number"
			},
			"absolutePath": {
				"!type": "bool"
			},
			"fastestEncoding": {
				"!type": "number"
			},
			"decomposedStringWithCompatibilityMapping": {
				"!type": "string"
			},
			"precomposedStringWithCanonicalMapping": {
				"!type": "string"
			},
			"stringByResolvingSymlinksInPath": {
				"!type": "string"
			},
			"lowercaseString": {
				"!type": "string"
			},
			"pathExtension": {
				"!type": "string"
			},
			"precomposedStringWithCompatibilityMapping": {
				"!type": "string"
			},
			"hash": {
				"!type": "number"
			},
			"localizedLowercaseString": {
				"!type": "string"
			},
			"lastPathComponent": {
				"!type": "string"
			},
			"floatValue": {
				"!type": "number"
			},
			"stringByDeletingPathExtension": {
				"!type": "string"
			},
			"intValue": {
				"!type": "number"
			},
			"localizedUppercaseString": {
				"!type": "string"
			},
			"capitalizedString": {
				"!type": "string"
			},
			"integerValue": {
				"!type": "number"
			},
			"stringByExpandingTildeInPath": {
				"!type": "string"
			},
			"stringByDeletingLastPathComponent": {
				"!type": "string"
			},
			"localizedCapitalizedString": {
				"!type": "string"
			},
			"longLongValue": {
				"!type": "number"
			},
			"pathComponents": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"stringByTrimmingCharactersInSet": {
				"!type": "fn(set: +NSCharacterSet) -> string"
			},
			"getCharacters": {
				"!type": "fn(buffer: +Object) -> void"
			},
			"localizedCaseInsensitiveCompare": {
				"!type": "fn(string: string) -> number"
			},
			"commonPrefixWithStringOptions": {
				"!type": "fn(str: string, mask: number) -> string"
			},
			"initWithFormatArguments": {
				"!type": "fn(format: string, argList: +Object) -> string"
			},
			"lowercaseStringWithLocale": {
				"!type": "fn(locale: +NSLocale) -> string"
			},
			"containsString": {
				"!type": "fn(str: string) -> bool"
			},
			"componentsSeparatedByCharactersInSet": {
				"!type": "fn(separator: +NSCharacterSet) -> +Array"
			},
			"stringByAddingPercentEncodingWithAllowedCharacters": {
				"!type": "fn(allowedCharacters: +NSCharacterSet) -> string"
			},
			"initWithContentsOfFile": {
				"!type": "fn(path: string) -> +Object"
			},
			"propertyListFromStringsFileFormat": {
				"!type": "fn() -> +Object"
			},
			"enumerateLinguisticTagsInRangeSchemeOptionsOrthographyUsingBlock": {
				"!type": "fn(range: +Object, scheme: string, options: number, orthography: +NSOrthography, block: +Function) -> void"
			},
			"hasSuffix": {
				"!type": "fn(str: string) -> bool"
			},
			"lineRangeForRange": {
				"!type": "fn(range: +Object) -> +Object"
			},
			"initWithContentsOfFileEncodingError": {
				"!type": "fn(path: string, enc: number, error: +Object) -> string"
			},
			"initWithFormatLocale": {
				"!type": "fn(format: string, locale: +Object, args: Array.prototype) -> string"
			},
			"lossyCString": {
				"!type": "fn() -> +Object"
			},
			"substringWithRange": {
				"!type": "fn(range: +Object) -> string"
			},
			"jsinit": {
				"!type": "fn() -> string"
			},
			"getParagraphStartEndContentsEndForRange": {
				"!type": "fn(startPtr: +Object, parEndPtr: +Object, contentsEndPtr: +Object, range: +Object) -> void"
			},
			"getCharactersRange": {
				"!type": "fn(buffer: +Object, range: +Object) -> void"
			},
			"rangeOfComposedCharacterSequencesForRange": {
				"!type": "fn(range: +Object) -> +Object"
			},
			"cStringUsingEncoding": {
				"!type": "fn(encoding: number) -> +Object"
			},
			"rangeOfCharacterFromSetOptions": {
				"!type": "fn(searchSet: +NSCharacterSet, mask: number) -> +Object"
			},
			"lengthOfBytesUsingEncoding": {
				"!type": "fn(enc: number) -> number"
			},
			"substringToIndex": {
				"!type": "fn(to: number) -> string"
			},
			"writeToFileAtomicallyEncodingError": {
				"!type": "fn(path: string, useAuxiliaryFile: bool, enc: number, error: +Object) -> bool"
			},
			"rangeOfCharacterFromSet": {
				"!type": "fn(searchSet: +NSCharacterSet) -> +Object"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> string"
			},
			"getCStringMaxLengthEncoding": {
				"!type": "fn(buffer: +Object, maxBufferCount: number, encoding: number) -> bool"
			},
			"stringByAppendingPathExtension": {
				"!type": "fn(str: string) -> string"
			},
			"initWithCStringNoCopyLengthFreeWhenDone": {
				"!type": "fn(bytes: +Object, length: number, freeBuffer: bool) -> +Object"
			},
			"localizedCompare": {
				"!type": "fn(string: string) -> number"
			},
			"stringByApplyingTransformReverse": {
				"!type": "fn(transform: string, reverse: bool) -> string"
			},
			"completePathIntoStringCaseSensitiveMatchesIntoArrayFilterTypes": {
				"!type": "fn(outputName: +Object, flag: bool, outputArray: +Object, filterTypes: +Array) -> number"
			},
			"stringByReplacingOccurrencesOfStringWithStringOptionsRange": {
				"!type": "fn(target: string, replacement: string, options: number, searchRange: +Object) -> string"
			},
			"localizedCaseInsensitiveContainsString": {
				"!type": "fn(str: string) -> bool"
			},
			"stringByAddingPercentEscapesUsingEncoding": {
				"!type": "fn(enc: number) -> string"
			},
			"initWithCharactersLength": {
				"!type": "fn(characters: +Object, length: number) -> string"
			},
			"stringByReplacingOccurrencesOfStringWithString": {
				"!type": "fn(target: string, replacement: string) -> string"
			},
			"propertyList": {
				"!type": "fn() -> +Object"
			},
			"initWithFormatLocaleArguments": {
				"!type": "fn(format: string, locale: +Object, argList: +Object) -> string"
			},
			"getCString": {
				"!type": "fn(bytes: +Object) -> void"
			},
			"getLineStartEndContentsEndForRange": {
				"!type": "fn(startPtr: +Object, lineEndPtr: +Object, contentsEndPtr: +Object, range: +Object) -> void"
			},
			"hasPrefix": {
				"!type": "fn(str: string) -> bool"
			},
			"initWithCStringLength": {
				"!type": "fn(bytes: +Object, length: number) -> +Object"
			},
			"getBytesMaxLengthUsedLengthEncodingOptionsRangeRemainingRange": {
				"!type": "fn(buffer: +Object, maxBufferCount: number, usedBufferCount: +Object, encoding: number, options: number, range: +Object, leftover: +Object) -> bool"
			},
			"componentsSeparatedByString": {
				"!type": "fn(separator: string) -> +Array"
			},
			"initWithBytesNoCopyLengthEncodingFreeWhenDone": {
				"!type": "fn(bytes: +Object, len: number, encoding: number, freeBuffer: bool) -> string"
			},
			"maximumLengthOfBytesUsingEncoding": {
				"!type": "fn(enc: number) -> number"
			},
			"initWithDataEncoding": {
				"!type": "fn(data: +NSData, encoding: number) -> string"
			},
			"rangeOfStringOptionsRange": {
				"!type": "fn(searchString: string, mask: number, rangeOfReceiverToSearch: +Object) -> +Object"
			},
			"initWithCharactersNoCopyLengthDeallocator": {
				"!type": "fn(chars: +Object, len: number, deallocator: +Function) -> string"
			},
			"caseInsensitiveCompare": {
				"!type": "fn(string: string) -> number"
			},
			"stringByReplacingCharactersInRangeWithString": {
				"!type": "fn(range: +Object, replacement: string) -> string"
			},
			"compareOptions": {
				"!type": "fn(string: string, mask: number) -> number"
			},
			"initWithContentsOfURLEncodingError": {
				"!type": "fn(url: +NSURL, enc: number, error: +Object) -> string"
			},
			"canBeConvertedToEncoding": {
				"!type": "fn(encoding: number) -> bool"
			},
			"rangeOfStringOptions": {
				"!type": "fn(searchString: string, mask: number) -> +Object"
			},
			"initWithCStringEncoding": {
				"!type": "fn(nullTerminatedCString: +Object, encoding: number) -> string"
			},
			"stringByFoldingWithOptionsLocale": {
				"!type": "fn(options: number, locale: +NSLocale) -> string"
			},
			"initWithFormat": {
				"!type": "fn(format: string, args: Array.prototype) -> string"
			},
			"enumerateSubstringsInRangeOptionsUsingBlock": {
				"!type": "fn(range: +Object, opts: number, block: +Function) -> void"
			},
			"initWithString": {
				"!type": "fn(aString: string) -> string"
			},
			"stringByPaddingToLengthWithStringStartingAtIndex": {
				"!type": "fn(newLength: number, padString: string, padIndex: number) -> string"
			},
			"localizedStandardRangeOfString": {
				"!type": "fn(str: string) -> +Object"
			},
			"rangeOfString": {
				"!type": "fn(searchString: string) -> +Object"
			},
			"getCStringMaxLengthRangeRemainingRange": {
				"!type": "fn(bytes: +Object, maxLength: number, aRange: +Object, leftoverRange: +Object) -> void"
			},
			"initWithCString": {
				"!type": "fn(bytes: +Object) -> +Object"
			},
			"getFileSystemRepresentationMaxLength": {
				"!type": "fn(cname: +Object, max: number) -> bool"
			},
			"compare": {
				"!type": "fn(string: string) -> number"
			},
			"enumerateLinesUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"writeToURLAtomically": {
				"!type": "fn(url: +NSURL, atomically: bool) -> bool"
			},
			"initWithBytesNoCopyLengthEncodingDeallocator": {
				"!type": "fn(bytes: +Object, len: number, encoding: number, deallocator: +Function) -> string"
			},
			"stringByAppendingString": {
				"!type": "fn(aString: string) -> string"
			},
			"compareOptionsRange": {
				"!type": "fn(string: string, mask: number, rangeOfReceiverToCompare: +Object) -> number"
			},
			"substringFromIndex": {
				"!type": "fn(from: number) -> string"
			},
			"initWithCharactersNoCopyLengthFreeWhenDone": {
				"!type": "fn(characters: +Object, length: number, freeBuffer: bool) -> string"
			},
			"stringByAppendingPathComponent": {
				"!type": "fn(str: string) -> string"
			},
			"capitalizedStringWithLocale": {
				"!type": "fn(locale: +NSLocale) -> string"
			},
			"localizedStandardContainsString": {
				"!type": "fn(str: string) -> bool"
			},
			"stringsByAppendingPaths": {
				"!type": "fn(paths: +Array) -> +Array"
			},
			"stringByAppendingFormat": {
				"!type": "fn(format: string, args: Array.prototype) -> string"
			},
			"cString": {
				"!type": "fn() -> +Object"
			},
			"isEqualToString": {
				"!type": "fn(aString: string) -> bool"
			},
			"getCStringMaxLength": {
				"!type": "fn(bytes: +Object, maxLength: number) -> void"
			},
			"linguisticTagsInRangeSchemeOptionsOrthographyTokenRanges": {
				"!type": "fn(range: +Object, scheme: string, options: number, orthography: +NSOrthography, tokenRanges: +Object) -> +Array"
			},
			"cStringLength": {
				"!type": "fn() -> number"
			},
			"rangeOfCharacterFromSetOptionsRange": {
				"!type": "fn(searchSet: +NSCharacterSet, mask: number, rangeOfReceiverToSearch: +Object) -> +Object"
			},
			"variantFittingPresentationWidth": {
				"!type": "fn(width: number) -> string"
			},
			"rangeOfComposedCharacterSequenceAtIndex": {
				"!type": "fn(index: number) -> +Object"
			},
			"writeToURLAtomicallyEncodingError": {
				"!type": "fn(url: +NSURL, useAuxiliaryFile: bool, enc: number, error: +Object) -> bool"
			},
			"initWithContentsOfURLUsedEncodingError": {
				"!type": "fn(url: +NSURL, enc: +Object, error: +Object) -> string"
			},
			"dataUsingEncoding": {
				"!type": "fn(encoding: number) -> +NSData"
			},
			"initWithContentsOfURL": {
				"!type": "fn(url: +NSURL) -> +Object"
			},
			"initWithBytesLengthEncoding": {
				"!type": "fn(bytes: +Object, len: number, encoding: number) -> string"
			},
			"initWithContentsOfFileUsedEncodingError": {
				"!type": "fn(path: string, enc: +Object, error: +Object) -> string"
			},
			"dataUsingEncodingAllowLossyConversion": {
				"!type": "fn(encoding: number, lossy: bool) -> +NSData"
			},
			"compareOptionsRangeLocale": {
				"!type": "fn(string: string, mask: number, rangeOfReceiverToCompare: +Object, locale: +Object) -> number"
			},
			"writeToFileAtomically": {
				"!type": "fn(path: string, useAuxiliaryFile: bool) -> bool"
			},
			"localizedStandardCompare": {
				"!type": "fn(string: string) -> number"
			},
			"characterAtIndex": {
				"!type": "fn(index: number) -> number"
			},
			"paragraphRangeForRange": {
				"!type": "fn(range: +Object) -> +Object"
			},
			"rangeOfStringOptionsRangeLocale": {
				"!type": "fn(searchString: string, mask: number, rangeOfReceiverToSearch: +Object, locale: +NSLocale) -> +Object"
			},
			"initWithUTF8String": {
				"!type": "fn(nullTerminatedCString: +Object) -> string"
			},
			"stringByReplacingPercentEscapesUsingEncoding": {
				"!type": "fn(enc: number) -> string"
			},
			"uppercaseStringWithLocale": {
				"!type": "fn(locale: +NSLocale) -> string"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> string"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioEnvironmentDistanceAttenuationParameters": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioEnvironmentDistanceAttenuationParameters"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioEnvironmentDistanceAttenuationParameters"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioEnvironmentDistanceAttenuationParameters"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"maximumDistance": {
				"!type": "number"
			},
			"rolloffFactor": {
				"!type": "number"
			},
			"distanceAttenuationModel": {
				"!type": "number"
			},
			"referenceDistance": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioEnvironmentDistanceAttenuationParameters"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureSynchronizedDepthData": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureSynchronizedDepthData"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureSynchronizedDepthData"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureSynchronizedDepthData"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"droppedReason": {
				"!type": "number"
			},
			"depthData": {
				"!type": "+AVDepthData"
			},
			"depthDataWasDropped": {
				"!type": "bool"
			},
			"timestamp": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureSynchronizedDepthData"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnitEffect": {
		"instantiateWithComponentDescriptionOptionsCompletionHandler": {
			"!type": "fn(audioComponentDescription: +Object, options: number, completionHandler: +Function) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnitEffect"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnitEffect"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnitEffect"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"bypass": {
				"!type": "bool"
			},
			"name": {
				"!type": "string"
			},
			"audioComponentDescription": {
				"!type": "+Object"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"version": {
				"!type": "number"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithAudioComponentDescription": {
				"!type": "fn(audioComponentDescription: +Object) -> +AVAudioUnitEffect"
			},
			"loadAudioUnitPresetAtURLError": {
				"!type": "fn(url: +NSURL, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnitEffect"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureMetadataInput": {
		"metadataInputWithFormatDescriptionClock": {
			"!type": "fn(desc: +Object, clock: +Object) -> +AVCaptureMetadataInput"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureMetadataInput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureMetadataInput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureMetadataInput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"ports": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithFormatDescriptionClock": {
				"!type": "fn(desc: +Object, clock: +Object) -> +AVCaptureMetadataInput"
			},
			"appendTimedMetadataGroupError": {
				"!type": "fn(metadata: +AVTimedMetadataGroup, outError: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureMetadataInput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitMass": {
		"stones": {
			"!type": "fn() -> +NSUnitMass"
		},
		"metricTons": {
			"!type": "fn() -> +NSUnitMass"
		},
		"nanograms": {
			"!type": "fn() -> +NSUnitMass"
		},
		"grams": {
			"!type": "fn() -> +NSUnitMass"
		},
		"micrograms": {
			"!type": "fn() -> +NSUnitMass"
		},
		"kilograms": {
			"!type": "fn() -> +NSUnitMass"
		},
		"milligrams": {
			"!type": "fn() -> +NSUnitMass"
		},
		"decigrams": {
			"!type": "fn() -> +NSUnitMass"
		},
		"poundsMass": {
			"!type": "fn() -> +NSUnitMass"
		},
		"shortTons": {
			"!type": "fn() -> +NSUnitMass"
		},
		"ounces": {
			"!type": "fn() -> +NSUnitMass"
		},
		"picograms": {
			"!type": "fn() -> +NSUnitMass"
		},
		"carats": {
			"!type": "fn() -> +NSUnitMass"
		},
		"centigrams": {
			"!type": "fn() -> +NSUnitMass"
		},
		"ouncesTroy": {
			"!type": "fn() -> +NSUnitMass"
		},
		"slugs": {
			"!type": "fn() -> +NSUnitMass"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitMass"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitMass"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitMass"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitMass"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitMass"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitMass"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitMass"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetReaderSampleReferenceOutput": {
		"assetReaderSampleReferenceOutputWithTrack": {
			"!type": "fn(track: +AVAssetTrack) -> +AVAssetReaderSampleReferenceOutput"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetReaderSampleReferenceOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetReaderSampleReferenceOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetReaderSampleReferenceOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"track": {
				"!type": "+AVAssetTrack"
			},
			"alwaysCopiesSampleData": {
				"!type": "bool"
			},
			"mediaType": {
				"!type": "string"
			},
			"supportsRandomAccess": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithTrack": {
				"!type": "fn(track: +AVAssetTrack) -> +AVAssetReaderSampleReferenceOutput"
			},
			"copyNextSampleBuffer": {
				"!type": "fn() -> +Object"
			},
			"resetForReadingTimeRanges": {
				"!type": "fn(timeRanges: +Array) -> void"
			},
			"markConfigurationAsFinal": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetReaderSampleReferenceOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMutableCompositionTrack": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMutableCompositionTrack"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMutableCompositionTrack"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMutableCompositionTrack"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"languageCode": {
				"!type": "string"
			},
			"extendedLanguageTag": {
				"!type": "string"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"enabled": {
				"!type": "bool"
			},
			"naturalTimeScale": {
				"!type": "number"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"segments": {
				"!type": "+Array"
			},
			"segments": {
				"!type": "+Array"
			},
			"formatDescriptionReplacements": {
				"!type": "+Array"
			},
			"languageCode": {
				"!type": "string"
			},
			"minFrameDuration": {
				"!type": "+Object"
			},
			"formatDescriptions": {
				"!type": "+Array"
			},
			"availableTrackAssociationTypes": {
				"!type": "+Array"
			},
			"nominalFrameRate": {
				"!type": "number"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"estimatedDataRate": {
				"!type": "number"
			},
			"naturalTimeScale": {
				"!type": "number"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"requiresFrameReordering": {
				"!type": "bool"
			},
			"hasAudioSampleDependencies": {
				"!type": "bool"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"selfContained": {
				"!type": "bool"
			},
			"segments": {
				"!type": "+Array"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"extendedLanguageTag": {
				"!type": "string"
			},
			"mediaType": {
				"!type": "string"
			},
			"asset": {
				"!type": "+AVAsset"
			},
			"trackID": {
				"!type": "number"
			},
			"totalSampleDataLength": {
				"!type": "number"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"decodable": {
				"!type": "bool"
			},
			"enabled": {
				"!type": "bool"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"insertEmptyTimeRange": {
				"!type": "fn(timeRange: +Object) -> void"
			},
			"validateTrackSegmentsError": {
				"!type": "fn(trackSegments: +Array, outError: +Object) -> bool"
			},
			"removeTimeRange": {
				"!type": "fn(timeRange: +Object) -> void"
			},
			"scaleTimeRangeToDuration": {
				"!type": "fn(timeRange: +Object, duration: +Object) -> void"
			},
			"replaceFormatDescriptionWithFormatDescription": {
				"!type": "fn(originalFormatDescription: +Object, replacementFormatDescription: +Object) -> void"
			},
			"insertTimeRangesOfTracksAtTimeError": {
				"!type": "fn(timeRanges: +Array, tracks: +Array, startTime: +Object, outError: +Object) -> bool"
			},
			"insertTimeRangeOfTrackAtTimeError": {
				"!type": "fn(timeRange: +Object, track: +AVAssetTrack, startTime: +Object, outError: +Object) -> bool"
			},
			"removeTrackAssociationToTrackType": {
				"!type": "fn(compositionTrack: +AVCompositionTrack, trackAssociationType: string) -> void"
			},
			"addTrackAssociationToTrackType": {
				"!type": "fn(compositionTrack: +AVCompositionTrack, trackAssociationType: string) -> void"
			},
			"segmentForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +AVCompositionTrackSegment"
			},
			"hasMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> bool"
			},
			"samplePresentationTimeForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +Object"
			},
			"associatedTracksOfType": {
				"!type": "fn(trackAssociationType: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"segmentForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +AVAssetTrackSegment"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMutableCompositionTrack"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSStream": {
		"getBoundStreamsWithBufferSizeInputStreamOutputStream": {
			"!type": "fn(bufferSize: number, inputStream: +Object, outputStream: +Object) -> void"
		},
		"getStreamsToHostWithNamePortInputStreamOutputStream": {
			"!type": "fn(hostname: string, port: number, inputStream: +Object, outputStream: +Object) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSStream"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSStream"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSStream"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"streamError": {
				"!type": "+NSError"
			},
			"streamStatus": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setPropertyForKey": {
				"!type": "fn(property: +Object, key: string) -> bool"
			},
			"scheduleInRunLoopForMode": {
				"!type": "fn(aRunLoop: +NSRunLoop, mode: string) -> void"
			},
			"propertyForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"removeFromRunLoopForMode": {
				"!type": "fn(aRunLoop: +NSRunLoop, mode: string) -> void"
			},
			"close": {
				"!type": "fn() -> void"
			},
			"open": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSStream"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetWriterInputPixelBufferAdaptor": {
		"assetWriterInputPixelBufferAdaptorWithAssetWriterInputSourcePixelBufferAttributes": {
			"!type": "fn(input: +AVAssetWriterInput, sourcePixelBufferAttributes: +Object) -> +AVAssetWriterInputPixelBufferAdaptor"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetWriterInputPixelBufferAdaptor"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetWriterInputPixelBufferAdaptor"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetWriterInputPixelBufferAdaptor"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"sourcePixelBufferAttributes": {
				"!type": "+Object"
			},
			"pixelBufferPool": {
				"!type": "+Object"
			},
			"assetWriterInput": {
				"!type": "+AVAssetWriterInput"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithAssetWriterInputSourcePixelBufferAttributes": {
				"!type": "fn(input: +AVAssetWriterInput, sourcePixelBufferAttributes: +Object) -> +AVAssetWriterInputPixelBufferAdaptor"
			},
			"appendPixelBufferWithPresentationTime": {
				"!type": "fn(pixelBuffer: +Object, presentationTime: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetWriterInputPixelBufferAdaptor"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitDispersion": {
		"partsPerMillion": {
			"!type": "fn() -> +NSUnitDispersion"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitDispersion"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitDispersion"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitDispersion"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitDispersion"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitDispersion"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitDispersion"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitDispersion"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureMovieFileOutput": {
		"jsnew": {
			"!type": "fn() -> +AVCaptureMovieFileOutput"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureMovieFileOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureMovieFileOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureMovieFileOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"movieFragmentInterval": {
				"!type": "+Object"
			},
			"availableVideoCodecTypes": {
				"!type": "+Array"
			},
			"metadata": {
				"!type": "+Array"
			},
			"maxRecordedFileSize": {
				"!type": "number"
			},
			"recordedFileSize": {
				"!type": "number"
			},
			"outputFileURL": {
				"!type": "+NSURL"
			},
			"recordedDuration": {
				"!type": "+Object"
			},
			"minFreeDiskSpaceLimit": {
				"!type": "number"
			},
			"recording": {
				"!type": "bool"
			},
			"maxRecordedDuration": {
				"!type": "+Object"
			},
			"connections": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setRecordsVideoOrientationAndMirroringChangesAsMetadataTrackForConnection": {
				"!type": "fn(doRecordChanges: bool, connection: +AVCaptureConnection) -> void"
			},
			"supportedOutputSettingsKeysForConnection": {
				"!type": "fn(connection: +AVCaptureConnection) -> +Array"
			},
			"recordsVideoOrientationAndMirroringChangesAsMetadataTrackForConnection": {
				"!type": "fn(connection: +AVCaptureConnection) -> bool"
			},
			"outputSettingsForConnection": {
				"!type": "fn(connection: +AVCaptureConnection) -> +Object"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureMovieFileOutput"
			},
			"setOutputSettingsForConnection": {
				"!type": "fn(outputSettings: +Object, connection: +AVCaptureConnection) -> void"
			},
			"stopRecording": {
				"!type": "fn() -> void"
			},
			"startRecordingToOutputFileURLRecordingDelegate": {
				"!type": "fn(outputFileURL: +NSURL, delegate: +Object) -> void"
			},
			"metadataOutputRectOfInterestForRect": {
				"!type": "fn(rectInOutputCoordinates: +Object) -> +Object"
			},
			"transformedMetadataObjectForMetadataObjectConnection": {
				"!type": "fn(metadataObject: +AVMetadataObject, connection: +AVCaptureConnection) -> +AVMetadataObject"
			},
			"rectForMetadataOutputRectOfInterest": {
				"!type": "fn(rectInMetadataOutputCoordinates: +Object) -> +Object"
			},
			"connectionWithMediaType": {
				"!type": "fn(mediaType: string) -> +AVCaptureConnection"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureMovieFileOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLSession": {
		"sharedSession": {
			"!type": "fn() -> +NSURLSession"
		},
		"sessionWithConfigurationDelegateDelegateQueue": {
			"!type": "fn(configuration: +NSURLSessionConfiguration, delegate: +Object, queue: +NSOperationQueue) -> +NSURLSession"
		},
		"sessionWithConfiguration": {
			"!type": "fn(configuration: +NSURLSessionConfiguration) -> +NSURLSession"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSession"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLSession"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLSession"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSession"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"sessionDescription": {
				"!type": "string"
			},
			"configuration": {
				"!type": "+NSURLSessionConfiguration"
			},
			"delegate": {
				"!type": "+Object"
			},
			"delegateQueue": {
				"!type": "+NSOperationQueue"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"dataTaskWithRequest": {
				"!type": "fn(request: +NSURLRequest) -> +NSURLSessionDataTask"
			},
			"streamTaskWithNetService": {
				"!type": "fn(service: +NSNetService) -> +NSURLSessionStreamTask"
			},
			"downloadTaskWithResumeData": {
				"!type": "fn(resumeData: +NSData) -> +NSURLSessionDownloadTask"
			},
			"uploadTaskWithRequestFromDataCompletionHandler": {
				"!type": "fn(request: +NSURLRequest, bodyData: +NSData, completionHandler: +Function) -> +NSURLSessionUploadTask"
			},
			"uploadTaskWithStreamedRequest": {
				"!type": "fn(request: +NSURLRequest) -> +NSURLSessionUploadTask"
			},
			"dataTaskWithURLCompletionHandler": {
				"!type": "fn(url: +NSURL, completionHandler: +Function) -> +NSURLSessionDataTask"
			},
			"flushWithCompletionHandler": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"getTasksWithCompletionHandler": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"getAllTasksWithCompletionHandler": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSession"
			},
			"downloadTaskWithRequestCompletionHandler": {
				"!type": "fn(request: +NSURLRequest, completionHandler: +Function) -> +NSURLSessionDownloadTask"
			},
			"invalidateAndCancel": {
				"!type": "fn() -> void"
			},
			"uploadTaskWithRequestFromFile": {
				"!type": "fn(request: +NSURLRequest, fileURL: +NSURL) -> +NSURLSessionUploadTask"
			},
			"downloadTaskWithURL": {
				"!type": "fn(url: +NSURL) -> +NSURLSessionDownloadTask"
			},
			"streamTaskWithHostNamePort": {
				"!type": "fn(hostname: string, port: number) -> +NSURLSessionStreamTask"
			},
			"resetWithCompletionHandler": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"webSocketTaskWithURLProtocols": {
				"!type": "fn(url: +NSURL, protocols: +Array) -> +NSURLSessionWebSocketTask"
			},
			"uploadTaskWithRequestFromData": {
				"!type": "fn(request: +NSURLRequest, bodyData: +NSData) -> +NSURLSessionUploadTask"
			},
			"downloadTaskWithResumeDataCompletionHandler": {
				"!type": "fn(resumeData: +NSData, completionHandler: +Function) -> +NSURLSessionDownloadTask"
			},
			"downloadTaskWithURLCompletionHandler": {
				"!type": "fn(url: +NSURL, completionHandler: +Function) -> +NSURLSessionDownloadTask"
			},
			"finishTasksAndInvalidate": {
				"!type": "fn() -> void"
			},
			"downloadTaskWithRequest": {
				"!type": "fn(request: +NSURLRequest) -> +NSURLSessionDownloadTask"
			},
			"uploadTaskWithRequestFromFileCompletionHandler": {
				"!type": "fn(request: +NSURLRequest, fileURL: +NSURL, completionHandler: +Function) -> +NSURLSessionUploadTask"
			},
			"dataTaskWithURL": {
				"!type": "fn(url: +NSURL) -> +NSURLSessionDataTask"
			},
			"webSocketTaskWithRequest": {
				"!type": "fn(request: +NSURLRequest) -> +NSURLSessionWebSocketTask"
			},
			"webSocketTaskWithURL": {
				"!type": "fn(url: +NSURL) -> +NSURLSessionWebSocketTask"
			},
			"dataTaskWithRequestCompletionHandler": {
				"!type": "fn(request: +NSURLRequest, completionHandler: +Function) -> +NSURLSessionDataTask"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSession"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMIDIPlayer": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMIDIPlayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMIDIPlayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMIDIPlayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"duration": {
				"!type": "number"
			},
			"currentPosition": {
				"!type": "number"
			},
			"rate": {
				"!type": "number"
			},
			"playing": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithDataSoundBankURLError": {
				"!type": "fn(data: +NSData, bankURL: +NSURL, outError: +Object) -> +AVMIDIPlayer"
			},
			"stop": {
				"!type": "fn() -> void"
			},
			"play": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"prepareToPlay": {
				"!type": "fn() -> void"
			},
			"initWithContentsOfURLSoundBankURLError": {
				"!type": "fn(inURL: +NSURL, bankURL: +NSURL, outError: +Object) -> +AVMIDIPlayer"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMIDIPlayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMeasurementFormatter": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMeasurementFormatter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMeasurementFormatter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMeasurementFormatter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"unitStyle": {
				"!type": "number"
			},
			"locale": {
				"!type": "+NSLocale"
			},
			"unitOptions": {
				"!type": "number"
			},
			"numberFormatter": {
				"!type": "+NSNumberFormatter"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"stringFromMeasurement": {
				"!type": "fn(measurement: +NSMeasurement) -> string"
			},
			"stringFromUnit": {
				"!type": "fn(unit: +NSUnit) -> string"
			},
			"editingStringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription": {
				"!type": "fn(partialStringPtr: +Object, proposedSelRangePtr: +Object, origString: string, origSelRange: +Object, error: +Object) -> bool"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"attributedStringForObjectValueWithDefaultAttributes": {
				"!type": "fn(obj: +Object, attrs: +Object) -> +NSAttributedString"
			},
			"isPartialStringValidNewEditingStringErrorDescription": {
				"!type": "fn(partialString: string, newString: +Object, error: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMeasurementFormatter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMutableCharacterSet": {
		"newlineCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"letterCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"nonBaseCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"symbolCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"characterSetWithBitmapRepresentation": {
			"!type": "fn(data: +NSData) -> +NSMutableCharacterSet"
		},
		"alphanumericCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"uppercaseLetterCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"whitespaceCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"lowercaseLetterCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"punctuationCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"whitespaceAndNewlineCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"controlCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"characterSetWithCharactersInString": {
			"!type": "fn(aString: string) -> +NSMutableCharacterSet"
		},
		"capitalizedLetterCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"characterSetWithContentsOfFile": {
			"!type": "fn(fName: string) -> +NSMutableCharacterSet"
		},
		"illegalCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"decomposableCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"characterSetWithRange": {
			"!type": "fn(aRange: +Object) -> +NSMutableCharacterSet"
		},
		"decimalDigitCharacterSet": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"URLHostAllowedCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"URLFragmentAllowedCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"letterCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"nonBaseCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"characterSetWithCharactersInString": {
			"!type": "fn(aString: string) -> +NSCharacterSet"
		},
		"punctuationCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"symbolCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"capitalizedLetterCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"characterSetWithContentsOfFile": {
			"!type": "fn(fName: string) -> +NSCharacterSet"
		},
		"illegalCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"URLUserAllowedCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"decomposableCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"newlineCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"whitespaceAndNewlineCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"alphanumericCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"URLPathAllowedCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"uppercaseLetterCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"URLPasswordAllowedCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"whitespaceCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"lowercaseLetterCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"characterSetWithBitmapRepresentation": {
			"!type": "fn(data: +NSData) -> +NSCharacterSet"
		},
		"controlCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"characterSetWithRange": {
			"!type": "fn(aRange: +Object) -> +NSCharacterSet"
		},
		"URLQueryAllowedCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"decimalDigitCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMutableCharacterSet"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMutableCharacterSet"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"invertedSet": {
				"!type": "+NSCharacterSet"
			},
			"bitmapRepresentation": {
				"!type": "+NSData"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"formIntersectionWithCharacterSet": {
				"!type": "fn(otherSet: +NSCharacterSet) -> void"
			},
			"removeCharactersInRange": {
				"!type": "fn(aRange: +Object) -> void"
			},
			"formUnionWithCharacterSet": {
				"!type": "fn(otherSet: +NSCharacterSet) -> void"
			},
			"removeCharactersInString": {
				"!type": "fn(aString: string) -> void"
			},
			"addCharactersInRange": {
				"!type": "fn(aRange: +Object) -> void"
			},
			"invert": {
				"!type": "fn() -> void"
			},
			"addCharactersInString": {
				"!type": "fn(aString: string) -> void"
			},
			"isSupersetOfSet": {
				"!type": "fn(theOtherSet: +NSCharacterSet) -> bool"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSMutableCharacterSet"
			},
			"characterIsMember": {
				"!type": "fn(aCharacter: number) -> bool"
			},
			"longCharacterIsMember": {
				"!type": "fn(theLongChar: number) -> bool"
			},
			"hasMemberInPlane": {
				"!type": "fn(thePlane: number) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableCharacterSet"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CAEmitterCell": {
		"emitterCell": {
			"!type": "fn() -> +CAEmitterCell"
		},
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CAEmitterCell"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CAEmitterCell"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CAEmitterCell"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"greenSpeed": {
				"!type": "number"
			},
			"blueSpeed": {
				"!type": "number"
			},
			"color": {
				"!type": "+Object"
			},
			"redRange": {
				"!type": "number"
			},
			"scaleRange": {
				"!type": "number"
			},
			"birthRate": {
				"!type": "number"
			},
			"greenRange": {
				"!type": "number"
			},
			"velocityRange": {
				"!type": "number"
			},
			"lifetime": {
				"!type": "number"
			},
			"contents": {
				"!type": "+Object"
			},
			"emissionRange": {
				"!type": "number"
			},
			"blueRange": {
				"!type": "number"
			},
			"scale": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"xAcceleration": {
				"!type": "number"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"yAcceleration": {
				"!type": "number"
			},
			"emissionLatitude": {
				"!type": "number"
			},
			"contentsScale": {
				"!type": "number"
			},
			"spinRange": {
				"!type": "number"
			},
			"emitterCells": {
				"!type": "+Array"
			},
			"style": {
				"!type": "+Object"
			},
			"redSpeed": {
				"!type": "number"
			},
			"zAcceleration": {
				"!type": "number"
			},
			"emissionLongitude": {
				"!type": "number"
			},
			"spin": {
				"!type": "number"
			},
			"alphaSpeed": {
				"!type": "number"
			},
			"name": {
				"!type": "string"
			},
			"alphaRange": {
				"!type": "number"
			},
			"enabled": {
				"!type": "bool"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"lifetimeRange": {
				"!type": "number"
			},
			"velocity": {
				"!type": "number"
			},
			"scaleSpeed": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAEmitterCell"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSListFormatter": {
		"localizedStringByJoiningStrings": {
			"!type": "fn(strings: +Array) -> string"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSListFormatter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSListFormatter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSListFormatter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"locale": {
				"!type": "+NSLocale"
			},
			"itemFormatter": {
				"!type": "+NSFormatter"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"stringFromItems": {
				"!type": "fn(items: +Array) -> string"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"editingStringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription": {
				"!type": "fn(partialStringPtr: +Object, proposedSelRangePtr: +Object, origString: string, origSelRange: +Object, error: +Object) -> bool"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"attributedStringForObjectValueWithDefaultAttributes": {
				"!type": "fn(obj: +Object, attrs: +Object) -> +NSAttributedString"
			},
			"isPartialStringValidNewEditingStringErrorDescription": {
				"!type": "fn(partialString: string, newString: +Object, error: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSListFormatter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSNetService": {
		"dataFromTXTRecordDictionary": {
			"!type": "fn(txtDictionary: +Object) -> +NSData"
		},
		"dictionaryFromTXTRecordData": {
			"!type": "fn(txtData: +NSData) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSNetService"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSNetService"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSNetService"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"domain": {
				"!type": "string"
			},
			"name": {
				"!type": "string"
			},
			"includesPeerToPeer": {
				"!type": "bool"
			},
			"hostName": {
				"!type": "string"
			},
			"delegate": {
				"!type": "+Object"
			},
			"type": {
				"!type": "string"
			},
			"port": {
				"!type": "number"
			},
			"addresses": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"stopMonitoring": {
				"!type": "fn() -> void"
			},
			"scheduleInRunLoopForMode": {
				"!type": "fn(aRunLoop: +NSRunLoop, mode: string) -> void"
			},
			"removeFromRunLoopForMode": {
				"!type": "fn(aRunLoop: +NSRunLoop, mode: string) -> void"
			},
			"startMonitoring": {
				"!type": "fn() -> void"
			},
			"resolveWithTimeout": {
				"!type": "fn(timeout: number) -> void"
			},
			"publishWithOptions": {
				"!type": "fn(options: number) -> void"
			},
			"getInputStreamOutputStream": {
				"!type": "fn(inputStream: +Object, outputStream: +Object) -> bool"
			},
			"stop": {
				"!type": "fn() -> void"
			},
			"initWithDomainTypeName": {
				"!type": "fn(domain: string, type: string, name: string) -> +NSNetService"
			},
			"TXTRecordData": {
				"!type": "fn() -> +NSData"
			},
			"resolve": {
				"!type": "fn() -> void"
			},
			"initWithDomainTypeNamePort": {
				"!type": "fn(domain: string, type: string, name: string, port: number) -> +NSNetService"
			},
			"setTXTRecordData": {
				"!type": "fn(recordData: +NSData) -> bool"
			},
			"publish": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSNetService"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSSimpleCString": {
		"stringWithCStringLength": {
			"!type": "fn(bytes: +Object, length: number) -> +Object"
		},
		"defaultCStringEncoding": {
			"!type": "fn() -> number"
		},
		"stringWithContentsOfFile": {
			"!type": "fn(path: string) -> +Object"
		},
		"string": {
			"!type": "fn() -> +NSSimpleCString"
		},
		"stringEncodingForDataEncodingOptionsConvertedStringUsedLossyConversion": {
			"!type": "fn(data: +NSData, opts: +Object, string: +Object, usedLossyConversion: +Object) -> number"
		},
		"stringWithUTF8String": {
			"!type": "fn(nullTerminatedCString: +Object) -> +NSSimpleCString"
		},
		"stringWithCString": {
			"!type": "fn(bytes: +Object) -> +Object"
		},
		"stringWithContentsOfFileUsedEncodingError": {
			"!type": "fn(path: string, enc: +Object, error: +Object) -> +NSSimpleCString"
		},
		"stringWithContentsOfURL": {
			"!type": "fn(url: +NSURL) -> +Object"
		},
		"stringWithCharactersLength": {
			"!type": "fn(characters: +Object, length: number) -> +NSSimpleCString"
		},
		"pathWithComponents": {
			"!type": "fn(components: +Array) -> string"
		},
		"localizedStringWithFormat": {
			"!type": "fn(format: string, args: Array.prototype) -> +NSSimpleCString"
		},
		"availableStringEncodings": {
			"!type": "fn() -> +Object"
		},
		"stringWithContentsOfFileEncodingError": {
			"!type": "fn(path: string, enc: number, error: +Object) -> +NSSimpleCString"
		},
		"localizedNameOfStringEncoding": {
			"!type": "fn(encoding: number) -> string"
		},
		"stringWithCStringEncoding": {
			"!type": "fn(cString: +Object, enc: number) -> +NSSimpleCString"
		},
		"stringWithFormat": {
			"!type": "fn(format: string, args: Array.prototype) -> +NSSimpleCString"
		},
		"stringWithString": {
			"!type": "fn(string: string) -> +NSSimpleCString"
		},
		"stringWithContentsOfURLUsedEncodingError": {
			"!type": "fn(url: +NSURL, enc: +Object, error: +Object) -> +NSSimpleCString"
		},
		"stringWithContentsOfURLEncodingError": {
			"!type": "fn(url: +NSURL, enc: number, error: +Object) -> +NSSimpleCString"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSSimpleCString"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSSimpleCString"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSSimpleCString"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"stringByRemovingPercentEncoding": {
				"!type": "string"
			},
			"stringByStandardizingPath": {
				"!type": "string"
			},
			"doubleValue": {
				"!type": "number"
			},
			"boolValue": {
				"!type": "bool"
			},
			"stringByAbbreviatingWithTildeInPath": {
				"!type": "string"
			},
			"description": {
				"!type": "string"
			},
			"decomposedStringWithCanonicalMapping": {
				"!type": "string"
			},
			"smallestEncoding": {
				"!type": "number"
			},
			"uppercaseString": {
				"!type": "string"
			},
			"length": {
				"!type": "number"
			},
			"absolutePath": {
				"!type": "bool"
			},
			"fastestEncoding": {
				"!type": "number"
			},
			"decomposedStringWithCompatibilityMapping": {
				"!type": "string"
			},
			"precomposedStringWithCanonicalMapping": {
				"!type": "string"
			},
			"stringByResolvingSymlinksInPath": {
				"!type": "string"
			},
			"lowercaseString": {
				"!type": "string"
			},
			"pathExtension": {
				"!type": "string"
			},
			"precomposedStringWithCompatibilityMapping": {
				"!type": "string"
			},
			"hash": {
				"!type": "number"
			},
			"localizedLowercaseString": {
				"!type": "string"
			},
			"lastPathComponent": {
				"!type": "string"
			},
			"floatValue": {
				"!type": "number"
			},
			"stringByDeletingPathExtension": {
				"!type": "string"
			},
			"intValue": {
				"!type": "number"
			},
			"localizedUppercaseString": {
				"!type": "string"
			},
			"capitalizedString": {
				"!type": "string"
			},
			"integerValue": {
				"!type": "number"
			},
			"stringByExpandingTildeInPath": {
				"!type": "string"
			},
			"stringByDeletingLastPathComponent": {
				"!type": "string"
			},
			"localizedCapitalizedString": {
				"!type": "string"
			},
			"longLongValue": {
				"!type": "number"
			},
			"pathComponents": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"stringByTrimmingCharactersInSet": {
				"!type": "fn(set: +NSCharacterSet) -> string"
			},
			"getCharacters": {
				"!type": "fn(buffer: +Object) -> void"
			},
			"localizedCaseInsensitiveCompare": {
				"!type": "fn(string: string) -> number"
			},
			"commonPrefixWithStringOptions": {
				"!type": "fn(str: string, mask: number) -> string"
			},
			"initWithFormatArguments": {
				"!type": "fn(format: string, argList: +Object) -> +NSSimpleCString"
			},
			"lowercaseStringWithLocale": {
				"!type": "fn(locale: +NSLocale) -> string"
			},
			"containsString": {
				"!type": "fn(str: string) -> bool"
			},
			"componentsSeparatedByCharactersInSet": {
				"!type": "fn(separator: +NSCharacterSet) -> +Array"
			},
			"stringByAddingPercentEncodingWithAllowedCharacters": {
				"!type": "fn(allowedCharacters: +NSCharacterSet) -> string"
			},
			"initWithContentsOfFile": {
				"!type": "fn(path: string) -> +Object"
			},
			"propertyListFromStringsFileFormat": {
				"!type": "fn() -> +Object"
			},
			"enumerateLinguisticTagsInRangeSchemeOptionsOrthographyUsingBlock": {
				"!type": "fn(range: +Object, scheme: string, options: number, orthography: +NSOrthography, block: +Function) -> void"
			},
			"hasSuffix": {
				"!type": "fn(str: string) -> bool"
			},
			"lineRangeForRange": {
				"!type": "fn(range: +Object) -> +Object"
			},
			"initWithContentsOfFileEncodingError": {
				"!type": "fn(path: string, enc: number, error: +Object) -> +NSSimpleCString"
			},
			"initWithFormatLocale": {
				"!type": "fn(format: string, locale: +Object, args: Array.prototype) -> +NSSimpleCString"
			},
			"lossyCString": {
				"!type": "fn() -> +Object"
			},
			"substringWithRange": {
				"!type": "fn(range: +Object) -> string"
			},
			"jsinit": {
				"!type": "fn() -> +NSSimpleCString"
			},
			"getParagraphStartEndContentsEndForRange": {
				"!type": "fn(startPtr: +Object, parEndPtr: +Object, contentsEndPtr: +Object, range: +Object) -> void"
			},
			"getCharactersRange": {
				"!type": "fn(buffer: +Object, range: +Object) -> void"
			},
			"rangeOfComposedCharacterSequencesForRange": {
				"!type": "fn(range: +Object) -> +Object"
			},
			"cStringUsingEncoding": {
				"!type": "fn(encoding: number) -> +Object"
			},
			"rangeOfCharacterFromSetOptions": {
				"!type": "fn(searchSet: +NSCharacterSet, mask: number) -> +Object"
			},
			"lengthOfBytesUsingEncoding": {
				"!type": "fn(enc: number) -> number"
			},
			"substringToIndex": {
				"!type": "fn(to: number) -> string"
			},
			"writeToFileAtomicallyEncodingError": {
				"!type": "fn(path: string, useAuxiliaryFile: bool, enc: number, error: +Object) -> bool"
			},
			"rangeOfCharacterFromSet": {
				"!type": "fn(searchSet: +NSCharacterSet) -> +Object"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSSimpleCString"
			},
			"getCStringMaxLengthEncoding": {
				"!type": "fn(buffer: +Object, maxBufferCount: number, encoding: number) -> bool"
			},
			"stringByAppendingPathExtension": {
				"!type": "fn(str: string) -> string"
			},
			"initWithCStringNoCopyLengthFreeWhenDone": {
				"!type": "fn(bytes: +Object, length: number, freeBuffer: bool) -> +Object"
			},
			"localizedCompare": {
				"!type": "fn(string: string) -> number"
			},
			"stringByApplyingTransformReverse": {
				"!type": "fn(transform: string, reverse: bool) -> string"
			},
			"completePathIntoStringCaseSensitiveMatchesIntoArrayFilterTypes": {
				"!type": "fn(outputName: +Object, flag: bool, outputArray: +Object, filterTypes: +Array) -> number"
			},
			"stringByReplacingOccurrencesOfStringWithStringOptionsRange": {
				"!type": "fn(target: string, replacement: string, options: number, searchRange: +Object) -> string"
			},
			"localizedCaseInsensitiveContainsString": {
				"!type": "fn(str: string) -> bool"
			},
			"stringByAddingPercentEscapesUsingEncoding": {
				"!type": "fn(enc: number) -> string"
			},
			"initWithCharactersLength": {
				"!type": "fn(characters: +Object, length: number) -> +NSSimpleCString"
			},
			"stringByReplacingOccurrencesOfStringWithString": {
				"!type": "fn(target: string, replacement: string) -> string"
			},
			"propertyList": {
				"!type": "fn() -> +Object"
			},
			"initWithFormatLocaleArguments": {
				"!type": "fn(format: string, locale: +Object, argList: +Object) -> +NSSimpleCString"
			},
			"getCString": {
				"!type": "fn(bytes: +Object) -> void"
			},
			"getLineStartEndContentsEndForRange": {
				"!type": "fn(startPtr: +Object, lineEndPtr: +Object, contentsEndPtr: +Object, range: +Object) -> void"
			},
			"hasPrefix": {
				"!type": "fn(str: string) -> bool"
			},
			"initWithCStringLength": {
				"!type": "fn(bytes: +Object, length: number) -> +Object"
			},
			"getBytesMaxLengthUsedLengthEncodingOptionsRangeRemainingRange": {
				"!type": "fn(buffer: +Object, maxBufferCount: number, usedBufferCount: +Object, encoding: number, options: number, range: +Object, leftover: +Object) -> bool"
			},
			"componentsSeparatedByString": {
				"!type": "fn(separator: string) -> +Array"
			},
			"initWithBytesNoCopyLengthEncodingFreeWhenDone": {
				"!type": "fn(bytes: +Object, len: number, encoding: number, freeBuffer: bool) -> +NSSimpleCString"
			},
			"maximumLengthOfBytesUsingEncoding": {
				"!type": "fn(enc: number) -> number"
			},
			"initWithDataEncoding": {
				"!type": "fn(data: +NSData, encoding: number) -> +NSSimpleCString"
			},
			"rangeOfStringOptionsRange": {
				"!type": "fn(searchString: string, mask: number, rangeOfReceiverToSearch: +Object) -> +Object"
			},
			"initWithCharactersNoCopyLengthDeallocator": {
				"!type": "fn(chars: +Object, len: number, deallocator: +Function) -> +NSSimpleCString"
			},
			"caseInsensitiveCompare": {
				"!type": "fn(string: string) -> number"
			},
			"stringByReplacingCharactersInRangeWithString": {
				"!type": "fn(range: +Object, replacement: string) -> string"
			},
			"compareOptions": {
				"!type": "fn(string: string, mask: number) -> number"
			},
			"initWithContentsOfURLEncodingError": {
				"!type": "fn(url: +NSURL, enc: number, error: +Object) -> +NSSimpleCString"
			},
			"canBeConvertedToEncoding": {
				"!type": "fn(encoding: number) -> bool"
			},
			"rangeOfStringOptions": {
				"!type": "fn(searchString: string, mask: number) -> +Object"
			},
			"initWithCStringEncoding": {
				"!type": "fn(nullTerminatedCString: +Object, encoding: number) -> +NSSimpleCString"
			},
			"stringByFoldingWithOptionsLocale": {
				"!type": "fn(options: number, locale: +NSLocale) -> string"
			},
			"initWithFormat": {
				"!type": "fn(format: string, args: Array.prototype) -> +NSSimpleCString"
			},
			"enumerateSubstringsInRangeOptionsUsingBlock": {
				"!type": "fn(range: +Object, opts: number, block: +Function) -> void"
			},
			"initWithString": {
				"!type": "fn(aString: string) -> +NSSimpleCString"
			},
			"stringByPaddingToLengthWithStringStartingAtIndex": {
				"!type": "fn(newLength: number, padString: string, padIndex: number) -> string"
			},
			"localizedStandardRangeOfString": {
				"!type": "fn(str: string) -> +Object"
			},
			"rangeOfString": {
				"!type": "fn(searchString: string) -> +Object"
			},
			"getCStringMaxLengthRangeRemainingRange": {
				"!type": "fn(bytes: +Object, maxLength: number, aRange: +Object, leftoverRange: +Object) -> void"
			},
			"initWithCString": {
				"!type": "fn(bytes: +Object) -> +Object"
			},
			"getFileSystemRepresentationMaxLength": {
				"!type": "fn(cname: +Object, max: number) -> bool"
			},
			"compare": {
				"!type": "fn(string: string) -> number"
			},
			"enumerateLinesUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"writeToURLAtomically": {
				"!type": "fn(url: +NSURL, atomically: bool) -> bool"
			},
			"initWithBytesNoCopyLengthEncodingDeallocator": {
				"!type": "fn(bytes: +Object, len: number, encoding: number, deallocator: +Function) -> +NSSimpleCString"
			},
			"stringByAppendingString": {
				"!type": "fn(aString: string) -> string"
			},
			"compareOptionsRange": {
				"!type": "fn(string: string, mask: number, rangeOfReceiverToCompare: +Object) -> number"
			},
			"substringFromIndex": {
				"!type": "fn(from: number) -> string"
			},
			"initWithCharactersNoCopyLengthFreeWhenDone": {
				"!type": "fn(characters: +Object, length: number, freeBuffer: bool) -> +NSSimpleCString"
			},
			"stringByAppendingPathComponent": {
				"!type": "fn(str: string) -> string"
			},
			"capitalizedStringWithLocale": {
				"!type": "fn(locale: +NSLocale) -> string"
			},
			"localizedStandardContainsString": {
				"!type": "fn(str: string) -> bool"
			},
			"stringsByAppendingPaths": {
				"!type": "fn(paths: +Array) -> +Array"
			},
			"stringByAppendingFormat": {
				"!type": "fn(format: string, args: Array.prototype) -> string"
			},
			"cString": {
				"!type": "fn() -> +Object"
			},
			"isEqualToString": {
				"!type": "fn(aString: string) -> bool"
			},
			"getCStringMaxLength": {
				"!type": "fn(bytes: +Object, maxLength: number) -> void"
			},
			"linguisticTagsInRangeSchemeOptionsOrthographyTokenRanges": {
				"!type": "fn(range: +Object, scheme: string, options: number, orthography: +NSOrthography, tokenRanges: +Object) -> +Array"
			},
			"cStringLength": {
				"!type": "fn() -> number"
			},
			"rangeOfCharacterFromSetOptionsRange": {
				"!type": "fn(searchSet: +NSCharacterSet, mask: number, rangeOfReceiverToSearch: +Object) -> +Object"
			},
			"variantFittingPresentationWidth": {
				"!type": "fn(width: number) -> string"
			},
			"rangeOfComposedCharacterSequenceAtIndex": {
				"!type": "fn(index: number) -> +Object"
			},
			"writeToURLAtomicallyEncodingError": {
				"!type": "fn(url: +NSURL, useAuxiliaryFile: bool, enc: number, error: +Object) -> bool"
			},
			"initWithContentsOfURLUsedEncodingError": {
				"!type": "fn(url: +NSURL, enc: +Object, error: +Object) -> +NSSimpleCString"
			},
			"dataUsingEncoding": {
				"!type": "fn(encoding: number) -> +NSData"
			},
			"initWithContentsOfURL": {
				"!type": "fn(url: +NSURL) -> +Object"
			},
			"initWithBytesLengthEncoding": {
				"!type": "fn(bytes: +Object, len: number, encoding: number) -> +NSSimpleCString"
			},
			"initWithContentsOfFileUsedEncodingError": {
				"!type": "fn(path: string, enc: +Object, error: +Object) -> +NSSimpleCString"
			},
			"dataUsingEncodingAllowLossyConversion": {
				"!type": "fn(encoding: number, lossy: bool) -> +NSData"
			},
			"compareOptionsRangeLocale": {
				"!type": "fn(string: string, mask: number, rangeOfReceiverToCompare: +Object, locale: +Object) -> number"
			},
			"writeToFileAtomically": {
				"!type": "fn(path: string, useAuxiliaryFile: bool) -> bool"
			},
			"localizedStandardCompare": {
				"!type": "fn(string: string) -> number"
			},
			"characterAtIndex": {
				"!type": "fn(index: number) -> number"
			},
			"paragraphRangeForRange": {
				"!type": "fn(range: +Object) -> +Object"
			},
			"rangeOfStringOptionsRangeLocale": {
				"!type": "fn(searchString: string, mask: number, rangeOfReceiverToSearch: +Object, locale: +NSLocale) -> +Object"
			},
			"initWithUTF8String": {
				"!type": "fn(nullTerminatedCString: +Object) -> +NSSimpleCString"
			},
			"stringByReplacingPercentEscapesUsingEncoding": {
				"!type": "fn(enc: number) -> string"
			},
			"uppercaseStringWithLocale": {
				"!type": "fn(locale: +NSLocale) -> string"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSSimpleCString"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMetadataDogBodyObject": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMetadataDogBodyObject"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMetadataDogBodyObject"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMetadataDogBodyObject"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"bodyID": {
				"!type": "number"
			},
			"duration": {
				"!type": "+Object"
			},
			"type": {
				"!type": "string"
			},
			"bounds": {
				"!type": "+Object"
			},
			"time": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMetadataDogBodyObject"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSBundleResourceRequest": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSBundleResourceRequest"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSBundleResourceRequest"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSBundleResourceRequest"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"progress": {
				"!type": "+NSProgress"
			},
			"loadingPriority": {
				"!type": "number"
			},
			"bundle": {
				"!type": "+NSBundle"
			},
			"tags": {
				"!type": "+NSSet"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithTags": {
				"!type": "fn(tags: +NSSet) -> +NSBundleResourceRequest"
			},
			"initWithTagsBundle": {
				"!type": "fn(tags: +NSSet, bundle: +NSBundle) -> +NSBundleResourceRequest"
			},
			"conditionallyBeginAccessingResourcesWithCompletionHandler": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"endAccessingResources": {
				"!type": "fn() -> void"
			},
			"beginAccessingResourcesWithCompletionHandler": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSBundleResourceRequest"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CAShapeLayer": {
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +CAShapeLayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CAShapeLayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CAShapeLayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CAShapeLayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"strokeEnd": {
				"!type": "number"
			},
			"lineWidth": {
				"!type": "number"
			},
			"fillRule": {
				"!type": "string"
			},
			"lineCap": {
				"!type": "string"
			},
			"miterLimit": {
				"!type": "number"
			},
			"lineDashPattern": {
				"!type": "+Array"
			},
			"fillColor": {
				"!type": "+Object"
			},
			"lineDashPhase": {
				"!type": "number"
			},
			"path": {
				"!type": "+Object"
			},
			"strokeColor": {
				"!type": "+Object"
			},
			"strokeStart": {
				"!type": "number"
			},
			"lineJoin": {
				"!type": "string"
			},
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAShapeLayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +CAShapeLayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +CAShapeLayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +CAShapeLayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAShapeLayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSFileVersion": {
		"otherVersionsOfItemAtURL": {
			"!type": "fn(url: +NSURL) -> +Array"
		},
		"versionOfItemAtURLForPersistentIdentifier": {
			"!type": "fn(url: +NSURL, persistentIdentifier: +Object) -> +NSFileVersion"
		},
		"unresolvedConflictVersionsOfItemAtURL": {
			"!type": "fn(url: +NSURL) -> +Array"
		},
		"getNonlocalVersionsOfItemAtURLCompletionHandler": {
			"!type": "fn(url: +NSURL, completionHandler: +Function) -> void"
		},
		"removeOtherVersionsOfItemAtURLError": {
			"!type": "fn(url: +NSURL, outError: +Object) -> bool"
		},
		"currentVersionOfItemAtURL": {
			"!type": "fn(url: +NSURL) -> +NSFileVersion"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSFileVersion"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSFileVersion"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSFileVersion"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"resolved": {
				"!type": "bool"
			},
			"hasThumbnail": {
				"!type": "bool"
			},
			"originatorNameComponents": {
				"!type": "+NSPersonNameComponents"
			},
			"hasLocalContents": {
				"!type": "bool"
			},
			"URL": {
				"!type": "+NSURL"
			},
			"persistentIdentifier": {
				"!type": "+Object"
			},
			"localizedName": {
				"!type": "string"
			},
			"localizedNameOfSavingComputer": {
				"!type": "string"
			},
			"modificationDate": {
				"!type": "+Date"
			},
			"conflict": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"removeAndReturnError": {
				"!type": "fn(outError: +Object) -> bool"
			},
			"replaceItemAtURLOptionsError": {
				"!type": "fn(url: +NSURL, options: number, error: +Object) -> +NSURL"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSFileVersion"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCameraCalibrationData": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCameraCalibrationData"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCameraCalibrationData"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCameraCalibrationData"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"intrinsicMatrixReferenceDimensions": {
				"!type": "+Object"
			},
			"inverseLensDistortionLookupTable": {
				"!type": "+NSData"
			},
			"lensDistortionLookupTable": {
				"!type": "+NSData"
			},
			"lensDistortionCenter": {
				"!type": "+Object"
			},
			"pixelSize": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCameraCalibrationData"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioTime": {
		"secondsForHostTime": {
			"!type": "fn(hostTime: number) -> number"
		},
		"timeWithHostTime": {
			"!type": "fn(hostTime: number) -> +AVAudioTime"
		},
		"timeWithAudioTimeStampSampleRate": {
			"!type": "fn(ts: +Object, sampleRate: number) -> +AVAudioTime"
		},
		"timeWithHostTimeSampleTimeAtRate": {
			"!type": "fn(hostTime: number, sampleTime: number, sampleRate: number) -> +AVAudioTime"
		},
		"hostTimeForSeconds": {
			"!type": "fn(seconds: number) -> number"
		},
		"timeWithSampleTimeAtRate": {
			"!type": "fn(sampleTime: number, sampleRate: number) -> +AVAudioTime"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioTime"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioTime"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioTime"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"hostTimeValid": {
				"!type": "bool"
			},
			"hostTime": {
				"!type": "number"
			},
			"sampleTimeValid": {
				"!type": "bool"
			},
			"sampleTime": {
				"!type": "number"
			},
			"audioTimeStamp": {
				"!type": "+Object"
			},
			"sampleRate": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSampleTimeAtRate": {
				"!type": "fn(sampleTime: number, sampleRate: number) -> +AVAudioTime"
			},
			"initWithAudioTimeStampSampleRate": {
				"!type": "fn(ts: +Object, sampleRate: number) -> +AVAudioTime"
			},
			"initWithHostTimeSampleTimeAtRate": {
				"!type": "fn(hostTime: number, sampleTime: number, sampleRate: number) -> +AVAudioTime"
			},
			"extrapolateTimeFromAnchor": {
				"!type": "fn(anchorTime: +AVAudioTime) -> +AVAudioTime"
			},
			"initWithHostTime": {
				"!type": "fn(hostTime: number) -> +AVAudioTime"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioTime"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnitEQ": {
		"instantiateWithComponentDescriptionOptionsCompletionHandler": {
			"!type": "fn(audioComponentDescription: +Object, options: number, completionHandler: +Function) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnitEQ"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnitEQ"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnitEQ"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"bands": {
				"!type": "+Array"
			},
			"globalGain": {
				"!type": "number"
			},
			"bypass": {
				"!type": "bool"
			},
			"name": {
				"!type": "string"
			},
			"audioComponentDescription": {
				"!type": "+Object"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"version": {
				"!type": "number"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithNumberOfBands": {
				"!type": "fn(numberOfBands: number) -> +AVAudioUnitEQ"
			},
			"initWithAudioComponentDescription": {
				"!type": "fn(audioComponentDescription: +Object) -> +AVAudioUnitEQ"
			},
			"loadAudioUnitPresetAtURLError": {
				"!type": "fn(url: +NSURL, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnitEQ"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVRouteDetector": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVRouteDetector"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVRouteDetector"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVRouteDetector"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"routeDetectionEnabled": {
				"!type": "bool"
			},
			"multipleRoutesDetected": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVRouteDetector"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMetadataObject": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMetadataObject"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMetadataObject"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMetadataObject"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"duration": {
				"!type": "+Object"
			},
			"type": {
				"!type": "string"
			},
			"bounds": {
				"!type": "+Object"
			},
			"time": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMetadataObject"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureSynchronizedDataCollection": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureSynchronizedDataCollection"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureSynchronizedDataCollection"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureSynchronizedDataCollection"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"synchronizedDataForCaptureOutput": {
				"!type": "fn(captureOutput: +AVCaptureOutput) -> +AVCaptureSynchronizedData"
			},
			"objectForKeyedSubscript": {
				"!type": "fn(key: +AVCaptureOutput) -> +AVCaptureSynchronizedData"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureSynchronizedDataCollection"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSByteCountFormatter": {
		"stringFromMeasurementCountStyle": {
			"!type": "fn(measurement: +NSMeasurement, countStyle: number) -> string"
		},
		"stringFromByteCountCountStyle": {
			"!type": "fn(byteCount: number, countStyle: number) -> string"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSByteCountFormatter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSByteCountFormatter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSByteCountFormatter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"allowedUnits": {
				"!type": "number"
			},
			"includesCount": {
				"!type": "bool"
			},
			"includesActualByteCount": {
				"!type": "bool"
			},
			"includesUnit": {
				"!type": "bool"
			},
			"zeroPadsFractionDigits": {
				"!type": "bool"
			},
			"allowsNonnumericFormatting": {
				"!type": "bool"
			},
			"countStyle": {
				"!type": "number"
			},
			"formattingContext": {
				"!type": "number"
			},
			"adaptive": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"stringFromByteCount": {
				"!type": "fn(byteCount: number) -> string"
			},
			"stringFromMeasurement": {
				"!type": "fn(measurement: +NSMeasurement) -> string"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"editingStringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription": {
				"!type": "fn(partialStringPtr: +Object, proposedSelRangePtr: +Object, origString: string, origSelRange: +Object, error: +Object) -> bool"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"attributedStringForObjectValueWithDefaultAttributes": {
				"!type": "fn(obj: +Object, attrs: +Object) -> +NSAttributedString"
			},
			"isPartialStringValidNewEditingStringErrorDescription": {
				"!type": "fn(partialString: string, newString: +Object, error: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSByteCountFormatter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CAAnimation": {
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"animation": {
			"!type": "fn() -> +CAAnimation"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CAAnimation"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CAAnimation"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CAAnimation"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"timingFunction": {
				"!type": "+CAMediaTimingFunction"
			},
			"delegate": {
				"!type": "+Object"
			},
			"removedOnCompletion": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAAnimation"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSLengthFormatter": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSLengthFormatter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSLengthFormatter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSLengthFormatter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"unitStyle": {
				"!type": "number"
			},
			"forPersonHeightUse": {
				"!type": "bool"
			},
			"numberFormatter": {
				"!type": "+NSNumberFormatter"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringFromMeters": {
				"!type": "fn(numberInMeters: number) -> string"
			},
			"unitStringFromValueUnit": {
				"!type": "fn(value: number, unit: number) -> string"
			},
			"stringFromValueUnit": {
				"!type": "fn(value: number, unit: number) -> string"
			},
			"unitStringFromMetersUsedUnit": {
				"!type": "fn(numberInMeters: number, unitp: +Object) -> string"
			},
			"editingStringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription": {
				"!type": "fn(partialStringPtr: +Object, proposedSelRangePtr: +Object, origString: string, origSelRange: +Object, error: +Object) -> bool"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"attributedStringForObjectValueWithDefaultAttributes": {
				"!type": "fn(obj: +Object, attrs: +Object) -> +NSAttributedString"
			},
			"isPartialStringValidNewEditingStringErrorDescription": {
				"!type": "fn(partialString: string, newString: +Object, error: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSLengthFormatter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetExportSession": {
		"allExportPresets": {
			"!type": "fn() -> +Array"
		},
		"determineCompatibilityOfExportPresetWithAssetOutputFileTypeCompletionHandler": {
			"!type": "fn(presetName: string, asset: +AVAsset, outputFileType: string, handler: +Function) -> void"
		},
		"exportSessionWithAssetPresetName": {
			"!type": "fn(asset: +AVAsset, presetName: string) -> +AVAssetExportSession"
		},
		"exportPresetsCompatibleWithAsset": {
			"!type": "fn(asset: +AVAsset) -> +Array"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetExportSession"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetExportSession"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetExportSession"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"status": {
				"!type": "number"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"supportedFileTypes": {
				"!type": "+Array"
			},
			"canPerformMultiplePassesOverSourceMediaData": {
				"!type": "bool"
			},
			"audioTimePitchAlgorithm": {
				"!type": "string"
			},
			"metadata": {
				"!type": "+Array"
			},
			"outputFileType": {
				"!type": "string"
			},
			"videoComposition": {
				"!type": "+AVVideoComposition"
			},
			"metadataItemFilter": {
				"!type": "+AVMetadataItemFilter"
			},
			"fileLengthLimit": {
				"!type": "number"
			},
			"audioMix": {
				"!type": "+AVAudioMix"
			},
			"shouldOptimizeForNetworkUse": {
				"!type": "bool"
			},
			"estimatedOutputFileLength": {
				"!type": "number"
			},
			"error": {
				"!type": "+NSError"
			},
			"customVideoCompositor": {
				"!type": "+Object"
			},
			"progress": {
				"!type": "number"
			},
			"outputURL": {
				"!type": "+NSURL"
			},
			"maxDuration": {
				"!type": "+Object"
			},
			"directoryForTemporaryFiles": {
				"!type": "+NSURL"
			},
			"presetName": {
				"!type": "string"
			},
			"asset": {
				"!type": "+AVAsset"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"determineCompatibleFileTypesWithCompletionHandler": {
				"!type": "fn(handler: +Function) -> void"
			},
			"estimateOutputFileLengthWithCompletionHandler": {
				"!type": "fn(handler: +Function) -> void"
			},
			"estimateMaximumDurationWithCompletionHandler": {
				"!type": "fn(handler: +Function) -> void"
			},
			"cancelExport": {
				"!type": "fn() -> void"
			},
			"initWithAssetPresetName": {
				"!type": "fn(asset: +AVAsset, presetName: string) -> +AVAssetExportSession"
			},
			"exportAsynchronouslyWithCompletionHandler": {
				"!type": "fn(handler: +Function) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetExportSession"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSKeyedUnarchiver": {
		"setClassForClassName": {
			"!type": "fn(cls: +Object, codedName: string) -> void"
		},
		"unarchivedDictionaryWithKeysOfClassesObjectsOfClassesFromDataError": {
			"!type": "fn(keyClasses: +NSSet, valueClasses: +NSSet, data: +NSData, error: +Object) -> +Object"
		},
		"unarchiveTopLevelObjectWithDataError": {
			"!type": "fn(data: +NSData, error: +Object) -> +Object"
		},
		"unarchivedObjectOfClassFromDataError": {
			"!type": "fn(cls: +Object, data: +NSData, error: +Object) -> +Object"
		},
		"unarchiveObjectWithData": {
			"!type": "fn(data: +NSData) -> +Object"
		},
		"unarchivedDictionaryWithKeysOfClassObjectsOfClassFromDataError": {
			"!type": "fn(keyCls: +Object, valueCls: +Object, data: +NSData, error: +Object) -> +Object"
		},
		"unarchivedObjectOfClassesFromDataError": {
			"!type": "fn(classes: +NSSet, data: +NSData, error: +Object) -> +Object"
		},
		"unarchivedArrayOfObjectsOfClassesFromDataError": {
			"!type": "fn(classes: +NSSet, data: +NSData, error: +Object) -> +Array"
		},
		"classForClassName": {
			"!type": "fn(codedName: string) -> +Object"
		},
		"unarchivedArrayOfObjectsOfClassFromDataError": {
			"!type": "fn(cls: +Object, data: +NSData, error: +Object) -> +Array"
		},
		"unarchiveObjectWithFile": {
			"!type": "fn(path: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSKeyedUnarchiver"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSKeyedUnarchiver"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSKeyedUnarchiver"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"requiresSecureCoding": {
				"!type": "bool"
			},
			"decodingFailurePolicy": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"requiresSecureCoding": {
				"!type": "bool"
			},
			"systemVersion": {
				"!type": "number"
			},
			"error": {
				"!type": "+NSError"
			},
			"allowedClasses": {
				"!type": "+NSSet"
			},
			"decodingFailurePolicy": {
				"!type": "number"
			},
			"allowsKeyedCoding": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"finishDecoding": {
				"!type": "fn() -> void"
			},
			"initForReadingWithData": {
				"!type": "fn(data: +NSData) -> +NSKeyedUnarchiver"
			},
			"decodeInt64ForKey": {
				"!type": "fn(key: string) -> number"
			},
			"decodeBoolForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"setClassForClassName": {
				"!type": "fn(cls: +Object, codedName: string) -> void"
			},
			"initForReadingFromDataError": {
				"!type": "fn(data: +NSData, error: +Object) -> +NSKeyedUnarchiver"
			},
			"decodeObjectForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"decodeIntForKey": {
				"!type": "fn(key: string) -> number"
			},
			"decodeDoubleForKey": {
				"!type": "fn(key: string) -> number"
			},
			"jsinit": {
				"!type": "fn() -> +NSKeyedUnarchiver"
			},
			"decodeInt32ForKey": {
				"!type": "fn(key: string) -> number"
			},
			"decodeBytesForKeyReturnedLength": {
				"!type": "fn(key: string, lengthp: +Object) -> +Object"
			},
			"classForClassName": {
				"!type": "fn(codedName: string) -> +Object"
			},
			"containsValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"decodeFloatForKey": {
				"!type": "fn(key: string) -> number"
			},
			"decodeObjectOfClassForKey": {
				"!type": "fn(aClass: +Object, key: string) -> +Object"
			},
			"decodeDataObject": {
				"!type": "fn() -> +NSData"
			},
			"versionForClassName": {
				"!type": "fn(className: string) -> number"
			},
			"encodeBoolForKey": {
				"!type": "fn(value: bool, key: string) -> void"
			},
			"encodeConditionalObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"decodeCMTimeForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"failWithError": {
				"!type": "fn(error: +NSError) -> void"
			},
			"encodeArrayOfObjCTypeCountAt": {
				"!type": "fn(type: +Object, count: number, array: +Object) -> void"
			},
			"setObjectZone": {
				"!type": "fn(zone: +Object) -> void"
			},
			"decodeInt64ForKey": {
				"!type": "fn(key: string) -> number"
			},
			"decodeArrayOfObjectsOfClassesForKey": {
				"!type": "fn(classes: +NSSet, key: string) -> +Array"
			},
			"encodeInt64ForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeInt32ForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeValuesOfObjCTypes": {
				"!type": "fn(types: +Object, args: Array.prototype) -> void"
			},
			"encodeIntegerForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"decodeTopLevelObjectForKeyError": {
				"!type": "fn(key: string, error: +Object) -> +Object"
			},
			"decodeCMTimeRangeForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"decodeValuesOfObjCTypes": {
				"!type": "fn(types: +Object, args: Array.prototype) -> void"
			},
			"decodeValueOfObjCTypeAt": {
				"!type": "fn(type: +Object, data: +Object) -> void"
			},
			"containsValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"encodeFloatForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"objectZone": {
				"!type": "fn() -> +Object"
			},
			"decodeDoubleForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeByrefObject": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"decodeInt32ForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"decodeDictionaryWithKeysOfClassesObjectsOfClassesForKey": {
				"!type": "fn(keyClasses: +NSSet, objectClasses: +NSSet, key: string) -> +Object"
			},
			"encodeDataObject": {
				"!type": "fn(data: +NSData) -> void"
			},
			"decodeTopLevelObjectAndReturnError": {
				"!type": "fn(error: +Object) -> +Object"
			},
			"decodeFloatForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeValueOfObjCTypeAt": {
				"!type": "fn(type: +Object, addr: +Object) -> void"
			},
			"decodeObjectForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"encodeBytesLengthForKey": {
				"!type": "fn(bytes: +Object, length: number, key: string) -> void"
			},
			"decodeArrayOfObjCTypeCountAt": {
				"!type": "fn(itemType: +Object, count: number, array: +Object) -> void"
			},
			"encodeRootObject": {
				"!type": "fn(rootObject: +Object) -> void"
			},
			"decodeBoolForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"encodeBytesLength": {
				"!type": "fn(byteaddr: +Object, length: number) -> void"
			},
			"encodeCMTimeRangeForKey": {
				"!type": "fn(timeRange: +Object, key: string) -> void"
			},
			"decodeBytesWithReturnedLength": {
				"!type": "fn(lengthp: +Object) -> +Object"
			},
			"decodeIntForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeCMTimeMappingForKey": {
				"!type": "fn(timeMapping: +Object, key: string) -> void"
			},
			"decodeArrayOfObjectsOfClassForKey": {
				"!type": "fn(cls: +Object, key: string) -> +Array"
			},
			"encodeDoubleForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeCMTimeForKey": {
				"!type": "fn(time: +Object, key: string) -> void"
			},
			"decodeObjectOfClassesForKey": {
				"!type": "fn(classes: +NSSet, key: string) -> +Object"
			},
			"decodeDictionaryWithKeysOfClassObjectsOfClassForKey": {
				"!type": "fn(keyCls: +Object, objectCls: +Object, key: string) -> +Object"
			},
			"encodeIntForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"decodeCMTimeMappingForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"decodeTopLevelObjectOfClassesForKeyError": {
				"!type": "fn(classes: +NSSet, key: string, error: +Object) -> +Object"
			},
			"encodeObjectForKey": {
				"!type": "fn(object: +Object, key: string) -> void"
			},
			"decodeObject": {
				"!type": "fn() -> +Object"
			},
			"encodeBycopyObject": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"decodePropertyListForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"decodeTopLevelObjectOfClassForKeyError": {
				"!type": "fn(aClass: +Object, key: string, error: +Object) -> +Object"
			},
			"decodeIntegerForKey": {
				"!type": "fn(key: string) -> number"
			},
			"decodeValueOfObjCTypeAtSize": {
				"!type": "fn(type: +Object, data: +Object, size: number) -> void"
			},
			"decodeBytesForKeyReturnedLength": {
				"!type": "fn(key: string, lengthp: +Object) -> +Object"
			},
			"encodeConditionalObjectForKey": {
				"!type": "fn(object: +Object, key: string) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSKeyedUnarchiver"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMutableSet": {
		"setWithCapacity": {
			"!type": "fn(numItems: number) -> +NSMutableSet"
		},
		"setWithObjects": {
			"!type": "fn(firstObj: +Object, args: Array.prototype) -> +NSMutableSet"
		},
		"setWithArray": {
			"!type": "fn(array: +Array) -> +NSMutableSet"
		},
		"set": {
			"!type": "fn() -> +NSMutableSet"
		},
		"setWithSet": {
			"!type": "fn(set: +NSSet) -> +NSMutableSet"
		},
		"setWithObject": {
			"!type": "fn(object: +Object) -> +NSMutableSet"
		},
		"setWithObjectsCount": {
			"!type": "fn(objects: +Object, cnt: number) -> +NSMutableSet"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMutableSet"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMutableSet"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMutableSet"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"allObjects": {
				"!type": "+Array"
			},
			"description": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSMutableSet"
			},
			"removeObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"initWithCapacity": {
				"!type": "fn(numItems: number) -> +NSMutableSet"
			},
			"minusSet": {
				"!type": "fn(otherSet: +NSSet) -> void"
			},
			"filterUsingPredicate": {
				"!type": "fn(predicate: +NSPredicate) -> void"
			},
			"unionSet": {
				"!type": "fn(otherSet: +NSSet) -> void"
			},
			"addObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableSet"
			},
			"removeAllObjects": {
				"!type": "fn() -> void"
			},
			"addObjectsFromArray": {
				"!type": "fn(array: +Array) -> void"
			},
			"intersectSet": {
				"!type": "fn(otherSet: +NSSet) -> void"
			},
			"setSet": {
				"!type": "fn(otherSet: +NSSet) -> void"
			},
			"initWithSet": {
				"!type": "fn(set: +NSSet) -> +NSMutableSet"
			},
			"anyObject": {
				"!type": "fn() -> +Object"
			},
			"initWithObjectsCount": {
				"!type": "fn(objects: +Object, cnt: number) -> +NSMutableSet"
			},
			"containsObject": {
				"!type": "fn(anObject: +Object) -> bool"
			},
			"enumerateObjectsWithOptionsUsingBlock": {
				"!type": "fn(opts: number, block: +Function) -> void"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSMutableSet"
			},
			"isEqualToSet": {
				"!type": "fn(otherSet: +NSSet) -> bool"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"sortedArrayUsingDescriptors": {
				"!type": "fn(sortDescriptors: +Array) -> +Array"
			},
			"makeObjectsPerformSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"initWithObjects": {
				"!type": "fn(firstObj: +Object, args: Array.prototype) -> +NSMutableSet"
			},
			"initWithArray": {
				"!type": "fn(array: +Array) -> +NSMutableSet"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"setByAddingObject": {
				"!type": "fn(anObject: +Object) -> +NSSet"
			},
			"descriptionWithLocale": {
				"!type": "fn(locale: +Object) -> string"
			},
			"isSubsetOfSet": {
				"!type": "fn(otherSet: +NSSet) -> bool"
			},
			"member": {
				"!type": "fn(object: +Object) -> +Object"
			},
			"filteredSetUsingPredicate": {
				"!type": "fn(predicate: +NSPredicate) -> +NSSet"
			},
			"objectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"objectsWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> +NSSet"
			},
			"enumerateObjectsUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"intersectsSet": {
				"!type": "fn(otherSet: +NSSet) -> bool"
			},
			"initWithSetCopyItems": {
				"!type": "fn(set: +NSSet, flag: bool) -> +NSMutableSet"
			},
			"setByAddingObjectsFromSet": {
				"!type": "fn(other: +NSSet) -> +NSSet"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableSet"
			},
			"setByAddingObjectsFromArray": {
				"!type": "fn(other: +Array) -> +NSSet"
			},
			"objectsPassingTest": {
				"!type": "fn(predicate: +Function) -> +NSSet"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"makeObjectsPerformSelectorWithObject": {
				"!type": "fn(aSelector: string, argument: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableSet"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CATransition": {
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"animation": {
			"!type": "fn() -> +CATransition"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CATransition"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CATransition"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CATransition"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"startProgress": {
				"!type": "number"
			},
			"subtype": {
				"!type": "string"
			},
			"type": {
				"!type": "string"
			},
			"endProgress": {
				"!type": "number"
			},
			"timingFunction": {
				"!type": "+CAMediaTimingFunction"
			},
			"delegate": {
				"!type": "+Object"
			},
			"removedOnCompletion": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CATransition"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureOutput": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"connections": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"metadataOutputRectOfInterestForRect": {
				"!type": "fn(rectInOutputCoordinates: +Object) -> +Object"
			},
			"transformedMetadataObjectForMetadataObjectConnection": {
				"!type": "fn(metadataObject: +AVMetadataObject, connection: +AVCaptureConnection) -> +AVMetadataObject"
			},
			"rectForMetadataOutputRectOfInterest": {
				"!type": "fn(rectInMetadataOutputCoordinates: +Object) -> +Object"
			},
			"connectionWithMediaType": {
				"!type": "fn(mediaType: string) -> +AVCaptureConnection"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMediaSelectionGroup": {
		"mediaSelectionOptionsFromArrayWithoutMediaCharacteristics": {
			"!type": "fn(mediaSelectionOptions: +Array, mediaCharacteristics: +Array) -> +Array"
		},
		"mediaSelectionOptionsFromArrayWithMediaCharacteristics": {
			"!type": "fn(mediaSelectionOptions: +Array, mediaCharacteristics: +Array) -> +Array"
		},
		"mediaSelectionOptionsFromArrayFilteredAndSortedAccordingToPreferredLanguages": {
			"!type": "fn(mediaSelectionOptions: +Array, preferredLanguages: +Array) -> +Array"
		},
		"playableMediaSelectionOptionsFromArray": {
			"!type": "fn(mediaSelectionOptions: +Array) -> +Array"
		},
		"mediaSelectionOptionsFromArrayWithLocale": {
			"!type": "fn(mediaSelectionOptions: +Array, locale: +NSLocale) -> +Array"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMediaSelectionGroup"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMediaSelectionGroup"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMediaSelectionGroup"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"defaultOption": {
				"!type": "+AVMediaSelectionOption"
			},
			"options": {
				"!type": "+Array"
			},
			"allowsEmptySelection": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"mediaSelectionOptionWithPropertyList": {
				"!type": "fn(plist: +Object) -> +AVMediaSelectionOption"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMediaSelectionGroup"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSIndexSet": {
		"indexSetWithIndex": {
			"!type": "fn(value: number) -> +NSIndexSet"
		},
		"indexSetWithIndexesInRange": {
			"!type": "fn(range: +Object) -> +NSIndexSet"
		},
		"indexSet": {
			"!type": "fn() -> +NSIndexSet"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSIndexSet"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSIndexSet"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSIndexSet"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"firstIndex": {
				"!type": "number"
			},
			"lastIndex": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"getIndexesMaxCountInIndexRange": {
				"!type": "fn(indexBuffer: +Object, bufferSize: number, range: +Object) -> number"
			},
			"indexPassingTest": {
				"!type": "fn(predicate: +Function) -> number"
			},
			"intersectsIndexesInRange": {
				"!type": "fn(range: +Object) -> bool"
			},
			"enumerateIndexesWithOptionsUsingBlock": {
				"!type": "fn(opts: number, block: +Function) -> void"
			},
			"enumerateRangesInRangeOptionsUsingBlock": {
				"!type": "fn(range: +Object, opts: number, block: +Function) -> void"
			},
			"containsIndex": {
				"!type": "fn(value: number) -> bool"
			},
			"enumerateIndexesInRangeOptionsUsingBlock": {
				"!type": "fn(range: +Object, opts: number, block: +Function) -> void"
			},
			"indexInRangeOptionsPassingTest": {
				"!type": "fn(range: +Object, opts: number, predicate: +Function) -> number"
			},
			"enumerateIndexesUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"initWithIndexesInRange": {
				"!type": "fn(range: +Object) -> +NSIndexSet"
			},
			"indexesWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> +NSIndexSet"
			},
			"containsIndexes": {
				"!type": "fn(indexSet: +NSIndexSet) -> bool"
			},
			"indexGreaterThanOrEqualToIndex": {
				"!type": "fn(value: number) -> number"
			},
			"initWithIndex": {
				"!type": "fn(value: number) -> +NSIndexSet"
			},
			"enumerateRangesWithOptionsUsingBlock": {
				"!type": "fn(opts: number, block: +Function) -> void"
			},
			"indexGreaterThanIndex": {
				"!type": "fn(value: number) -> number"
			},
			"indexesInRangeOptionsPassingTest": {
				"!type": "fn(range: +Object, opts: number, predicate: +Function) -> +NSIndexSet"
			},
			"isEqualToIndexSet": {
				"!type": "fn(indexSet: +NSIndexSet) -> bool"
			},
			"enumerateRangesUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"indexWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> number"
			},
			"containsIndexesInRange": {
				"!type": "fn(range: +Object) -> bool"
			},
			"countOfIndexesInRange": {
				"!type": "fn(range: +Object) -> number"
			},
			"indexLessThanIndex": {
				"!type": "fn(value: number) -> number"
			},
			"indexesPassingTest": {
				"!type": "fn(predicate: +Function) -> +NSIndexSet"
			},
			"initWithIndexSet": {
				"!type": "fn(indexSet: +NSIndexSet) -> +NSIndexSet"
			},
			"indexLessThanOrEqualToIndex": {
				"!type": "fn(value: number) -> number"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSIndexSet"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioRecorder": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioRecorder"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioRecorder"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioRecorder"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"meteringEnabled": {
				"!type": "bool"
			},
			"format": {
				"!type": "+AVAudioFormat"
			},
			"url": {
				"!type": "+NSURL"
			},
			"currentTime": {
				"!type": "number"
			},
			"recording": {
				"!type": "bool"
			},
			"channelAssignments": {
				"!type": "+Array"
			},
			"delegate": {
				"!type": "+Object"
			},
			"deviceCurrentTime": {
				"!type": "number"
			},
			"settings": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"recordForDuration": {
				"!type": "fn(duration: number) -> bool"
			},
			"initWithURLFormatError": {
				"!type": "fn(url: +NSURL, format: +AVAudioFormat, outError: +Object) -> +AVAudioRecorder"
			},
			"averagePowerForChannel": {
				"!type": "fn(channelNumber: number) -> number"
			},
			"peakPowerForChannel": {
				"!type": "fn(channelNumber: number) -> number"
			},
			"prepareToRecord": {
				"!type": "fn() -> bool"
			},
			"deleteRecording": {
				"!type": "fn() -> bool"
			},
			"recordAtTime": {
				"!type": "fn(time: number) -> bool"
			},
			"updateMeters": {
				"!type": "fn() -> void"
			},
			"stop": {
				"!type": "fn() -> void"
			},
			"pause": {
				"!type": "fn() -> void"
			},
			"recordAtTimeForDuration": {
				"!type": "fn(time: number, duration: number) -> bool"
			},
			"record": {
				"!type": "fn() -> bool"
			},
			"initWithURLSettingsError": {
				"!type": "fn(url: +NSURL, settings: +Object, outError: +Object) -> +AVAudioRecorder"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioRecorder"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURL": {
		"fileURLWithPathRelativeToURL": {
			"!type": "fn(path: string, baseURL: +NSURL) -> +NSURL"
		},
		"URLWithStringRelativeToURL": {
			"!type": "fn(URLString: string, baseURL: +NSURL) -> +NSURL"
		},
		"bookmarkDataWithContentsOfURLError": {
			"!type": "fn(bookmarkFileURL: +NSURL, error: +Object) -> +NSData"
		},
		"writeBookmarkDataToURLOptionsError": {
			"!type": "fn(bookmarkData: +NSData, bookmarkFileURL: +NSURL, options: number, error: +Object) -> bool"
		},
		"fileURLWithFileSystemRepresentationIsDirectoryRelativeToURL": {
			"!type": "fn(path: +Object, isDir: bool, baseURL: +NSURL) -> +NSURL"
		},
		"fileURLWithPathIsDirectoryRelativeToURL": {
			"!type": "fn(path: string, isDir: bool, baseURL: +NSURL) -> +NSURL"
		},
		"URLWithString": {
			"!type": "fn(URLString: string) -> +NSURL"
		},
		"URLByResolvingBookmarkDataOptionsRelativeToURLBookmarkDataIsStaleError": {
			"!type": "fn(bookmarkData: +NSData, options: number, relativeURL: +NSURL, isStale: +Object, error: +Object) -> +NSURL"
		},
		"fileURLWithPathIsDirectory": {
			"!type": "fn(path: string, isDir: bool) -> +NSURL"
		},
		"resourceValuesForKeysFromBookmarkData": {
			"!type": "fn(keys: +Array, bookmarkData: +NSData) -> +Object"
		},
		"fileURLWithPath": {
			"!type": "fn(path: string) -> +NSURL"
		},
		"URLByResolvingAliasFileAtURLOptionsError": {
			"!type": "fn(url: +NSURL, options: number, error: +Object) -> +NSURL"
		},
		"absoluteURLWithDataRepresentationRelativeToURL": {
			"!type": "fn(data: +NSData, baseURL: +NSURL) -> +NSURL"
		},
		"fileURLWithPathComponents": {
			"!type": "fn(components: +Array) -> +NSURL"
		},
		"URLWithDataRepresentationRelativeToURL": {
			"!type": "fn(data: +NSData, baseURL: +NSURL) -> +NSURL"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURL"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURL"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURL"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"parameterString": {
				"!type": "string"
			},
			"hasDirectoryPath": {
				"!type": "bool"
			},
			"absoluteString": {
				"!type": "string"
			},
			"lastPathComponent": {
				"!type": "string"
			},
			"fragment": {
				"!type": "string"
			},
			"relativePath": {
				"!type": "string"
			},
			"pathComponents": {
				"!type": "+Array"
			},
			"host": {
				"!type": "string"
			},
			"relativeString": {
				"!type": "string"
			},
			"path": {
				"!type": "string"
			},
			"query": {
				"!type": "string"
			},
			"password": {
				"!type": "string"
			},
			"port": {
				"!type": "number"
			},
			"absoluteURL": {
				"!type": "+NSURL"
			},
			"resourceSpecifier": {
				"!type": "string"
			},
			"pathExtension": {
				"!type": "string"
			},
			"filePathURL": {
				"!type": "+NSURL"
			},
			"standardizedURL": {
				"!type": "+NSURL"
			},
			"baseURL": {
				"!type": "+NSURL"
			},
			"URLByResolvingSymlinksInPath": {
				"!type": "+NSURL"
			},
			"URLByStandardizingPath": {
				"!type": "+NSURL"
			},
			"fileURL": {
				"!type": "bool"
			},
			"scheme": {
				"!type": "string"
			},
			"URLByDeletingLastPathComponent": {
				"!type": "+NSURL"
			},
			"dataRepresentation": {
				"!type": "+NSData"
			},
			"URLByDeletingPathExtension": {
				"!type": "+NSURL"
			},
			"user": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"URLByAppendingPathComponentIsDirectory": {
				"!type": "fn(pathComponent: string, isDirectory: bool) -> +NSURL"
			},
			"initFileURLWithPath": {
				"!type": "fn(path: string) -> +NSURL"
			},
			"URLByAppendingPathExtension": {
				"!type": "fn(pathExtension: string) -> +NSURL"
			},
			"URLByAppendingPathComponent": {
				"!type": "fn(pathComponent: string) -> +NSURL"
			},
			"checkResourceIsReachableAndReturnError": {
				"!type": "fn(error: +Object) -> bool"
			},
			"initWithString": {
				"!type": "fn(URLString: string) -> +NSURL"
			},
			"fileReferenceURL": {
				"!type": "fn() -> +NSURL"
			},
			"removeAllCachedResourceValues": {
				"!type": "fn() -> void"
			},
			"initFileURLWithPathIsDirectory": {
				"!type": "fn(path: string, isDir: bool) -> +NSURL"
			},
			"initFileURLWithPathIsDirectoryRelativeToURL": {
				"!type": "fn(path: string, isDir: bool, baseURL: +NSURL) -> +NSURL"
			},
			"startAccessingSecurityScopedResource": {
				"!type": "fn() -> bool"
			},
			"initFileURLWithPathRelativeToURL": {
				"!type": "fn(path: string, baseURL: +NSURL) -> +NSURL"
			},
			"initAbsoluteURLWithDataRepresentationRelativeToURL": {
				"!type": "fn(data: +NSData, baseURL: +NSURL) -> +NSURL"
			},
			"removeCachedResourceValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"initWithStringRelativeToURL": {
				"!type": "fn(URLString: string, baseURL: +NSURL) -> +NSURL"
			},
			"resourceValuesForKeysError": {
				"!type": "fn(keys: +Array, error: +Object) -> +Object"
			},
			"initWithDataRepresentationRelativeToURL": {
				"!type": "fn(data: +NSData, baseURL: +NSURL) -> +NSURL"
			},
			"stopAccessingSecurityScopedResource": {
				"!type": "fn() -> void"
			},
			"promisedItemResourceValuesForKeysError": {
				"!type": "fn(keys: +Array, error: +Object) -> +Object"
			},
			"initByResolvingBookmarkDataOptionsRelativeToURLBookmarkDataIsStaleError": {
				"!type": "fn(bookmarkData: +NSData, options: number, relativeURL: +NSURL, isStale: +Object, error: +Object) -> +NSURL"
			},
			"checkPromisedItemIsReachableAndReturnError": {
				"!type": "fn(error: +Object) -> bool"
			},
			"getResourceValueForKeyError": {
				"!type": "fn(value: +Object, key: string, error: +Object) -> bool"
			},
			"bookmarkDataWithOptionsIncludingResourceValuesForKeysRelativeToURLError": {
				"!type": "fn(options: number, keys: +Array, relativeURL: +NSURL, error: +Object) -> +NSData"
			},
			"setResourceValueForKeyError": {
				"!type": "fn(value: +Object, key: string, error: +Object) -> bool"
			},
			"isFileReferenceURL": {
				"!type": "fn() -> bool"
			},
			"setTemporaryResourceValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"getPromisedItemResourceValueForKeyError": {
				"!type": "fn(value: +Object, key: string, error: +Object) -> bool"
			},
			"initWithSchemeHostPath": {
				"!type": "fn(scheme: string, host: string, path: string) -> +NSURL"
			},
			"setResourceValuesError": {
				"!type": "fn(keyedValues: +Object, error: +Object) -> bool"
			},
			"initFileURLWithFileSystemRepresentationIsDirectoryRelativeToURL": {
				"!type": "fn(path: +Object, isDir: bool, baseURL: +NSURL) -> +NSURL"
			},
			"getFileSystemRepresentationMaxLength": {
				"!type": "fn(buffer: +Object, maxBufferLength: number) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURL"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSNumber": {
		"numberWithUnsignedInteger": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithUnsignedShort": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithDouble": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithLongLong": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithLong": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithChar": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithInt": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithUnsignedInt": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithUnsignedLong": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithShort": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithUnsignedChar": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithBool": {
			"!type": "fn(value: bool) -> number"
		},
		"numberWithFloat": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithInteger": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithUnsignedLongLong": {
			"!type": "fn(value: number) -> number"
		},
		"valueWithPointer": {
			"!type": "fn(pointer: +Object) -> +NSValue"
		},
		"valueWithBytesObjCType": {
			"!type": "fn(value: +Object, type: +Object) -> +NSValue"
		},
		"valueWithCMTimeRange": {
			"!type": "fn(timeRange: +Object) -> +NSValue"
		},
		"valueWithCMTime": {
			"!type": "fn(time: +Object) -> +NSValue"
		},
		"valueWithRange": {
			"!type": "fn(range: +Object) -> +NSValue"
		},
		"valueWithObjCType": {
			"!type": "fn(value: +Object, type: +Object) -> +NSValue"
		},
		"valueWithCMTimeMapping": {
			"!type": "fn(timeMapping: +Object) -> +NSValue"
		},
		"valueWithCATransform3D": {
			"!type": "fn(t: +Object) -> +NSValue"
		},
		"valueWithNonretainedObject": {
			"!type": "fn(anObject: +Object) -> +NSValue"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> number"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> number"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> number"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"longLongValue": {
				"!type": "number"
			},
			"unsignedLongValue": {
				"!type": "number"
			},
			"boolValue": {
				"!type": "bool"
			},
			"floatValue": {
				"!type": "number"
			},
			"longValue": {
				"!type": "number"
			},
			"doubleValue": {
				"!type": "number"
			},
			"unsignedLongLongValue": {
				"!type": "number"
			},
			"intValue": {
				"!type": "number"
			},
			"shortValue": {
				"!type": "number"
			},
			"unsignedCharValue": {
				"!type": "number"
			},
			"unsignedShortValue": {
				"!type": "number"
			},
			"unsignedIntegerValue": {
				"!type": "number"
			},
			"stringValue": {
				"!type": "string"
			},
			"unsignedIntValue": {
				"!type": "number"
			},
			"integerValue": {
				"!type": "number"
			},
			"charValue": {
				"!type": "number"
			},
			"CMTimeRangeValue": {
				"!type": "+Object"
			},
			"rangeValue": {
				"!type": "+Object"
			},
			"CMTimeValue": {
				"!type": "+Object"
			},
			"CATransform3DValue": {
				"!type": "+Object"
			},
			"CMTimeMappingValue": {
				"!type": "+Object"
			},
			"nonretainedObjectValue": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithUnsignedLong": {
				"!type": "fn(value: number) -> number"
			},
			"initWithLong": {
				"!type": "fn(value: number) -> number"
			},
			"initWithInteger": {
				"!type": "fn(value: number) -> number"
			},
			"initWithDouble": {
				"!type": "fn(value: number) -> number"
			},
			"initWithChar": {
				"!type": "fn(value: number) -> number"
			},
			"initWithLongLong": {
				"!type": "fn(value: number) -> number"
			},
			"isEqualToNumber": {
				"!type": "fn(number: number) -> bool"
			},
			"initWithFloat": {
				"!type": "fn(value: number) -> number"
			},
			"initWithBool": {
				"!type": "fn(value: bool) -> number"
			},
			"descriptionWithLocale": {
				"!type": "fn(locale: +Object) -> string"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> number"
			},
			"initWithInt": {
				"!type": "fn(value: number) -> number"
			},
			"initWithUnsignedChar": {
				"!type": "fn(value: number) -> number"
			},
			"initWithShort": {
				"!type": "fn(value: number) -> number"
			},
			"initWithUnsignedInteger": {
				"!type": "fn(value: number) -> number"
			},
			"initWithUnsignedShort": {
				"!type": "fn(value: number) -> number"
			},
			"initWithUnsignedLongLong": {
				"!type": "fn(value: number) -> number"
			},
			"initWithUnsignedInt": {
				"!type": "fn(value: number) -> number"
			},
			"compare": {
				"!type": "fn(otherNumber: number) -> number"
			},
			"getValueSize": {
				"!type": "fn(value: +Object, size: number) -> void"
			},
			"isEqualToValue": {
				"!type": "fn(value: +NSValue) -> bool"
			},
			"getValue": {
				"!type": "fn(value: +Object) -> void"
			},
			"initWithBytesObjCType": {
				"!type": "fn(value: +Object, type: +Object) -> number"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> number"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> number"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioOutputNode": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioOutputNode"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioOutputNode"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioOutputNode"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"voiceProcessingEnabled": {
				"!type": "bool"
			},
			"presentationLatency": {
				"!type": "number"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setVoiceProcessingEnabledError": {
				"!type": "fn(enabled: bool, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioOutputNode"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureMultiCamSession": {
		"isMultiCamSupported": {
			"!type": "fn() -> bool"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureMultiCamSession"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureMultiCamSession"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureMultiCamSession"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"hardwareCost": {
				"!type": "number"
			},
			"systemPressureCost": {
				"!type": "number"
			},
			"inputs": {
				"!type": "+Array"
			},
			"masterClock": {
				"!type": "+Object"
			},
			"outputs": {
				"!type": "+Array"
			},
			"interrupted": {
				"!type": "bool"
			},
			"automaticallyConfiguresCaptureDeviceForWideColor": {
				"!type": "bool"
			},
			"connections": {
				"!type": "+Array"
			},
			"running": {
				"!type": "bool"
			},
			"automaticallyConfiguresApplicationAudioSession": {
				"!type": "bool"
			},
			"usesApplicationAudioSession": {
				"!type": "bool"
			},
			"sessionPreset": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"addInput": {
				"!type": "fn(input: +AVCaptureInput) -> void"
			},
			"removeConnection": {
				"!type": "fn(connection: +AVCaptureConnection) -> void"
			},
			"addOutputWithNoConnections": {
				"!type": "fn(output: +AVCaptureOutput) -> void"
			},
			"stopRunning": {
				"!type": "fn() -> void"
			},
			"canAddOutput": {
				"!type": "fn(output: +AVCaptureOutput) -> bool"
			},
			"addOutput": {
				"!type": "fn(output: +AVCaptureOutput) -> void"
			},
			"canSetSessionPreset": {
				"!type": "fn(preset: string) -> bool"
			},
			"canAddConnection": {
				"!type": "fn(connection: +AVCaptureConnection) -> bool"
			},
			"addConnection": {
				"!type": "fn(connection: +AVCaptureConnection) -> void"
			},
			"removeInput": {
				"!type": "fn(input: +AVCaptureInput) -> void"
			},
			"removeOutput": {
				"!type": "fn(output: +AVCaptureOutput) -> void"
			},
			"addInputWithNoConnections": {
				"!type": "fn(input: +AVCaptureInput) -> void"
			},
			"commitConfiguration": {
				"!type": "fn() -> void"
			},
			"canAddInput": {
				"!type": "fn(input: +AVCaptureInput) -> bool"
			},
			"beginConfiguration": {
				"!type": "fn() -> void"
			},
			"startRunning": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureMultiCamSession"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitElectricResistance": {
		"microohms": {
			"!type": "fn() -> +NSUnitElectricResistance"
		},
		"ohms": {
			"!type": "fn() -> +NSUnitElectricResistance"
		},
		"kiloohms": {
			"!type": "fn() -> +NSUnitElectricResistance"
		},
		"milliohms": {
			"!type": "fn() -> +NSUnitElectricResistance"
		},
		"megaohms": {
			"!type": "fn() -> +NSUnitElectricResistance"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitElectricResistance"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitElectricResistance"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitElectricResistance"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitElectricResistance"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitElectricResistance"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitElectricResistance"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitElectricResistance"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitElectricCharge": {
		"megaampereHours": {
			"!type": "fn() -> +NSUnitElectricCharge"
		},
		"ampereHours": {
			"!type": "fn() -> +NSUnitElectricCharge"
		},
		"kiloampereHours": {
			"!type": "fn() -> +NSUnitElectricCharge"
		},
		"milliampereHours": {
			"!type": "fn() -> +NSUnitElectricCharge"
		},
		"coulombs": {
			"!type": "fn() -> +NSUnitElectricCharge"
		},
		"microampereHours": {
			"!type": "fn() -> +NSUnitElectricCharge"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitElectricCharge"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitElectricCharge"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitElectricCharge"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitElectricCharge"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitElectricCharge"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitElectricCharge"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitElectricCharge"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureStillImageOutput": {
		"jsnew": {
			"!type": "fn() -> +AVCaptureStillImageOutput"
		},
		"jpegStillImageNSDataRepresentation": {
			"!type": "fn(jpegSampleBuffer: +Object) -> +NSData"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureStillImageOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureStillImageOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureStillImageOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"capturingStillImage": {
				"!type": "bool"
			},
			"stillImageStabilizationActive": {
				"!type": "bool"
			},
			"highResolutionStillImageOutputEnabled": {
				"!type": "bool"
			},
			"outputSettings": {
				"!type": "+Object"
			},
			"availableImageDataCVPixelFormatTypes": {
				"!type": "+Array"
			},
			"lensStabilizationDuringBracketedCaptureSupported": {
				"!type": "bool"
			},
			"automaticallyEnablesStillImageStabilizationWhenAvailable": {
				"!type": "bool"
			},
			"maxBracketedCaptureStillImageCount": {
				"!type": "number"
			},
			"stillImageStabilizationSupported": {
				"!type": "bool"
			},
			"lensStabilizationDuringBracketedCaptureEnabled": {
				"!type": "bool"
			},
			"availableImageDataCodecTypes": {
				"!type": "+Array"
			},
			"connections": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"captureStillImageAsynchronouslyFromConnectionCompletionHandler": {
				"!type": "fn(connection: +AVCaptureConnection, handler: +Function) -> void"
			},
			"prepareToCaptureStillImageBracketFromConnectionWithSettingsArrayCompletionHandler": {
				"!type": "fn(connection: +AVCaptureConnection, settings: +Array, handler: +Function) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureStillImageOutput"
			},
			"captureStillImageBracketAsynchronouslyFromConnectionWithSettingsArrayCompletionHandler": {
				"!type": "fn(connection: +AVCaptureConnection, settings: +Array, handler: +Function) -> void"
			},
			"metadataOutputRectOfInterestForRect": {
				"!type": "fn(rectInOutputCoordinates: +Object) -> +Object"
			},
			"transformedMetadataObjectForMetadataObjectConnection": {
				"!type": "fn(metadataObject: +AVMetadataObject, connection: +AVCaptureConnection) -> +AVMetadataObject"
			},
			"rectForMetadataOutputRectOfInterest": {
				"!type": "fn(rectInMetadataOutputCoordinates: +Object) -> +Object"
			},
			"connectionWithMediaType": {
				"!type": "fn(mediaType: string) -> +AVCaptureConnection"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureStillImageOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSAssertionHandler": {
		"currentHandler": {
			"!type": "fn() -> +NSAssertionHandler"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSAssertionHandler"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSAssertionHandler"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSAssertionHandler"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"handleFailureInFunctionFileLineNumberDescription": {
				"!type": "fn(functionName: string, fileName: string, line: number, format: string, args: Array.prototype) -> void"
			},
			"handleFailureInMethodObjectFileLineNumberDescription": {
				"!type": "fn(selector: string, object: +Object, fileName: string, line: number, format: string, args: Array.prototype) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSAssertionHandler"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitEnergy": {
		"joules": {
			"!type": "fn() -> +NSUnitEnergy"
		},
		"calories": {
			"!type": "fn() -> +NSUnitEnergy"
		},
		"kilojoules": {
			"!type": "fn() -> +NSUnitEnergy"
		},
		"kilocalories": {
			"!type": "fn() -> +NSUnitEnergy"
		},
		"kilowattHours": {
			"!type": "fn() -> +NSUnitEnergy"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitEnergy"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitEnergy"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitEnergy"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitEnergy"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitEnergy"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitEnergy"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitEnergy"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSHTTPURLResponse": {
		"localizedStringForStatusCode": {
			"!type": "fn(statusCode: number) -> string"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSHTTPURLResponse"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSHTTPURLResponse"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSHTTPURLResponse"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"allHeaderFields": {
				"!type": "+Object"
			},
			"statusCode": {
				"!type": "number"
			},
			"URL": {
				"!type": "+NSURL"
			},
			"MIMEType": {
				"!type": "string"
			},
			"expectedContentLength": {
				"!type": "number"
			},
			"suggestedFilename": {
				"!type": "string"
			},
			"textEncodingName": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"valueForHTTPHeaderField": {
				"!type": "fn(field: string) -> string"
			},
			"initWithURLStatusCodeHTTPVersionHeaderFields": {
				"!type": "fn(url: +NSURL, statusCode: number, HTTPVersion: string, headerFields: +Object) -> +NSHTTPURLResponse"
			},
			"initWithURLMIMETypeExpectedContentLengthTextEncodingName": {
				"!type": "fn(URL: +NSURL, MIMEType: string, length: number, name: string) -> +NSHTTPURLResponse"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSHTTPURLResponse"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSFileProviderService": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSFileProviderService"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSFileProviderService"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSFileProviderService"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"name": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"getFileProviderConnectionWithCompletionHandler": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSFileProviderService"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerItemAccessLogEvent": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerItemAccessLogEvent"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerItemAccessLogEvent"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerItemAccessLogEvent"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"switchBitrate": {
				"!type": "number"
			},
			"observedMaxBitrate": {
				"!type": "number"
			},
			"numberOfDroppedVideoFrames": {
				"!type": "number"
			},
			"observedBitrate": {
				"!type": "number"
			},
			"numberOfMediaRequests": {
				"!type": "number"
			},
			"durationWatched": {
				"!type": "number"
			},
			"playbackStartOffset": {
				"!type": "number"
			},
			"playbackStartDate": {
				"!type": "+Date"
			},
			"observedBitrateStandardDeviation": {
				"!type": "number"
			},
			"numberOfStalls": {
				"!type": "number"
			},
			"indicatedBitrate": {
				"!type": "number"
			},
			"playbackType": {
				"!type": "string"
			},
			"numberOfBytesTransferred": {
				"!type": "number"
			},
			"numberOfServerAddressChanges": {
				"!type": "number"
			},
			"startupTime": {
				"!type": "number"
			},
			"averageAudioBitrate": {
				"!type": "number"
			},
			"URI": {
				"!type": "string"
			},
			"segmentsDownloadedDuration": {
				"!type": "number"
			},
			"transferDuration": {
				"!type": "number"
			},
			"serverAddress": {
				"!type": "string"
			},
			"playbackSessionID": {
				"!type": "string"
			},
			"observedMinBitrate": {
				"!type": "number"
			},
			"downloadOverdue": {
				"!type": "number"
			},
			"mediaRequestsWWAN": {
				"!type": "number"
			},
			"numberOfSegmentsDownloaded": {
				"!type": "number"
			},
			"indicatedAverageBitrate": {
				"!type": "number"
			},
			"averageVideoBitrate": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerItemAccessLogEvent"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVDepthData": {
		"depthDataFromDictionaryRepresentationError": {
			"!type": "fn(imageSourceAuxDataInfoDictionary: +Object, outError: +Object) -> +AVDepthData"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVDepthData"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVDepthData"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVDepthData"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"depthDataType": {
				"!type": "number"
			},
			"depthDataQuality": {
				"!type": "number"
			},
			"availableDepthDataTypes": {
				"!type": "+Array"
			},
			"depthDataFiltered": {
				"!type": "bool"
			},
			"cameraCalibrationData": {
				"!type": "+AVCameraCalibrationData"
			},
			"depthDataMap": {
				"!type": "+Object"
			},
			"depthDataAccuracy": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"depthDataByApplyingExifOrientation": {
				"!type": "fn(exifOrientation: number) -> +AVDepthData"
			},
			"depthDataByConvertingToDepthDataType": {
				"!type": "fn(depthDataType: number) -> +AVDepthData"
			},
			"dictionaryRepresentationForAuxiliaryDataType": {
				"!type": "fn(outAuxDataType: +Object) -> +Object"
			},
			"depthDataByReplacingDepthDataMapWithPixelBufferError": {
				"!type": "fn(pixelBuffer: +Object, outError: +Object) -> +AVDepthData"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVDepthData"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitVolume": {
		"imperialFluidOunces": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"pints": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"kiloliters": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"teaspoons": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"cubicMiles": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"metricCups": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"acreFeet": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"cubicDecimeters": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"cubicYards": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"deciliters": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"liters": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"centiliters": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"cubicMeters": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"imperialGallons": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"milliliters": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"imperialTeaspoons": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"cups": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"quarts": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"cubicInches": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"cubicCentimeters": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"bushels": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"cubicFeet": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"cubicKilometers": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"megaliters": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"imperialQuarts": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"tablespoons": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"fluidOunces": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"cubicMillimeters": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"imperialTablespoons": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"gallons": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"imperialPints": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitVolume"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitVolume"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitVolume"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitVolume"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitVolume"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSExtensionContext": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSExtensionContext"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSExtensionContext"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSExtensionContext"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"inputItems": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"completeRequestReturningItemsCompletionHandler": {
				"!type": "fn(items: +Array, completionHandler: +Function) -> void"
			},
			"cancelRequestWithError": {
				"!type": "fn(error: +NSError) -> void"
			},
			"openURLCompletionHandler": {
				"!type": "fn(URL: +NSURL, completionHandler: +Function) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSExtensionContext"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSDecimalNumber": {
		"decimalNumberWithStringLocale": {
			"!type": "fn(numberValue: string, locale: +Object) -> +NSDecimalNumber"
		},
		"setDefaultBehavior": {
			"!type": "fn(defaultBehavior: +Object) -> void"
		},
		"minimumDecimalNumber": {
			"!type": "fn() -> +NSDecimalNumber"
		},
		"one": {
			"!type": "fn() -> +NSDecimalNumber"
		},
		"notANumber": {
			"!type": "fn() -> +NSDecimalNumber"
		},
		"zero": {
			"!type": "fn() -> +NSDecimalNumber"
		},
		"decimalNumberWithMantissaExponentIsNegative": {
			"!type": "fn(mantissa: number, exponent: number, flag: bool) -> +NSDecimalNumber"
		},
		"decimalNumberWithString": {
			"!type": "fn(numberValue: string) -> +NSDecimalNumber"
		},
		"decimalNumberWithDecimal": {
			"!type": "fn(dcm: +Object) -> +NSDecimalNumber"
		},
		"maximumDecimalNumber": {
			"!type": "fn() -> +NSDecimalNumber"
		},
		"defaultBehavior": {
			"!type": "fn() -> +Object"
		},
		"numberWithUnsignedInteger": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithUnsignedShort": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithDouble": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithLongLong": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithLong": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithChar": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithInt": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithUnsignedInt": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithUnsignedLong": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithShort": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithUnsignedChar": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithBool": {
			"!type": "fn(value: bool) -> number"
		},
		"numberWithFloat": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithInteger": {
			"!type": "fn(value: number) -> number"
		},
		"numberWithUnsignedLongLong": {
			"!type": "fn(value: number) -> number"
		},
		"valueWithPointer": {
			"!type": "fn(pointer: +Object) -> +NSValue"
		},
		"valueWithBytesObjCType": {
			"!type": "fn(value: +Object, type: +Object) -> +NSValue"
		},
		"valueWithCMTimeRange": {
			"!type": "fn(timeRange: +Object) -> +NSValue"
		},
		"valueWithCMTime": {
			"!type": "fn(time: +Object) -> +NSValue"
		},
		"valueWithRange": {
			"!type": "fn(range: +Object) -> +NSValue"
		},
		"valueWithObjCType": {
			"!type": "fn(value: +Object, type: +Object) -> +NSValue"
		},
		"valueWithCMTimeMapping": {
			"!type": "fn(timeMapping: +Object) -> +NSValue"
		},
		"valueWithCATransform3D": {
			"!type": "fn(t: +Object) -> +NSValue"
		},
		"valueWithNonretainedObject": {
			"!type": "fn(anObject: +Object) -> +NSValue"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSDecimalNumber"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSDecimalNumber"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSDecimalNumber"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"doubleValue": {
				"!type": "number"
			},
			"longLongValue": {
				"!type": "number"
			},
			"unsignedLongValue": {
				"!type": "number"
			},
			"boolValue": {
				"!type": "bool"
			},
			"floatValue": {
				"!type": "number"
			},
			"longValue": {
				"!type": "number"
			},
			"doubleValue": {
				"!type": "number"
			},
			"unsignedLongLongValue": {
				"!type": "number"
			},
			"intValue": {
				"!type": "number"
			},
			"shortValue": {
				"!type": "number"
			},
			"unsignedCharValue": {
				"!type": "number"
			},
			"unsignedShortValue": {
				"!type": "number"
			},
			"unsignedIntegerValue": {
				"!type": "number"
			},
			"stringValue": {
				"!type": "string"
			},
			"unsignedIntValue": {
				"!type": "number"
			},
			"integerValue": {
				"!type": "number"
			},
			"charValue": {
				"!type": "number"
			},
			"CMTimeRangeValue": {
				"!type": "+Object"
			},
			"rangeValue": {
				"!type": "+Object"
			},
			"CMTimeValue": {
				"!type": "+Object"
			},
			"CATransform3DValue": {
				"!type": "+Object"
			},
			"CMTimeMappingValue": {
				"!type": "+Object"
			},
			"nonretainedObjectValue": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"decimalNumberByRaisingToPower": {
				"!type": "fn(power: number) -> +NSDecimalNumber"
			},
			"decimalNumberByDividingBy": {
				"!type": "fn(decimalNumber: +NSDecimalNumber) -> +NSDecimalNumber"
			},
			"decimalNumberByAddingWithBehavior": {
				"!type": "fn(decimalNumber: +NSDecimalNumber, behavior: +Object) -> +NSDecimalNumber"
			},
			"decimalNumberByMultiplyingByWithBehavior": {
				"!type": "fn(decimalNumber: +NSDecimalNumber, behavior: +Object) -> +NSDecimalNumber"
			},
			"initWithString": {
				"!type": "fn(numberValue: string) -> +NSDecimalNumber"
			},
			"decimalNumberBySubtracting": {
				"!type": "fn(decimalNumber: +NSDecimalNumber) -> +NSDecimalNumber"
			},
			"initWithStringLocale": {
				"!type": "fn(numberValue: string, locale: +Object) -> +NSDecimalNumber"
			},
			"descriptionWithLocale": {
				"!type": "fn(locale: +Object) -> string"
			},
			"decimalNumberByDividingByWithBehavior": {
				"!type": "fn(decimalNumber: +NSDecimalNumber, behavior: +Object) -> +NSDecimalNumber"
			},
			"decimalNumberByMultiplyingByPowerOf10WithBehavior": {
				"!type": "fn(power: number, behavior: +Object) -> +NSDecimalNumber"
			},
			"decimalNumberByRoundingAccordingToBehavior": {
				"!type": "fn(behavior: +Object) -> +NSDecimalNumber"
			},
			"decimalNumberByMultiplyingBy": {
				"!type": "fn(decimalNumber: +NSDecimalNumber) -> +NSDecimalNumber"
			},
			"decimalNumberBySubtractingWithBehavior": {
				"!type": "fn(decimalNumber: +NSDecimalNumber, behavior: +Object) -> +NSDecimalNumber"
			},
			"initWithDecimal": {
				"!type": "fn(dcm: +Object) -> +NSDecimalNumber"
			},
			"decimalNumberByRaisingToPowerWithBehavior": {
				"!type": "fn(power: number, behavior: +Object) -> +NSDecimalNumber"
			},
			"decimalNumberByMultiplyingByPowerOf10": {
				"!type": "fn(power: number) -> +NSDecimalNumber"
			},
			"decimalNumberByAdding": {
				"!type": "fn(decimalNumber: +NSDecimalNumber) -> +NSDecimalNumber"
			},
			"initWithMantissaExponentIsNegative": {
				"!type": "fn(mantissa: number, exponent: number, flag: bool) -> +NSDecimalNumber"
			},
			"compare": {
				"!type": "fn(decimalNumber: number) -> number"
			},
			"initWithUnsignedLong": {
				"!type": "fn(value: number) -> number"
			},
			"initWithLong": {
				"!type": "fn(value: number) -> number"
			},
			"initWithInteger": {
				"!type": "fn(value: number) -> number"
			},
			"initWithDouble": {
				"!type": "fn(value: number) -> number"
			},
			"initWithChar": {
				"!type": "fn(value: number) -> number"
			},
			"initWithLongLong": {
				"!type": "fn(value: number) -> number"
			},
			"isEqualToNumber": {
				"!type": "fn(number: number) -> bool"
			},
			"initWithFloat": {
				"!type": "fn(value: number) -> number"
			},
			"initWithBool": {
				"!type": "fn(value: bool) -> number"
			},
			"descriptionWithLocale": {
				"!type": "fn(locale: +Object) -> string"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSDecimalNumber"
			},
			"initWithInt": {
				"!type": "fn(value: number) -> number"
			},
			"initWithUnsignedChar": {
				"!type": "fn(value: number) -> number"
			},
			"initWithShort": {
				"!type": "fn(value: number) -> number"
			},
			"initWithUnsignedInteger": {
				"!type": "fn(value: number) -> number"
			},
			"initWithUnsignedShort": {
				"!type": "fn(value: number) -> number"
			},
			"initWithUnsignedLongLong": {
				"!type": "fn(value: number) -> number"
			},
			"initWithUnsignedInt": {
				"!type": "fn(value: number) -> number"
			},
			"compare": {
				"!type": "fn(otherNumber: number) -> number"
			},
			"getValueSize": {
				"!type": "fn(value: +Object, size: number) -> void"
			},
			"isEqualToValue": {
				"!type": "fn(value: +NSValue) -> bool"
			},
			"getValue": {
				"!type": "fn(value: +Object) -> void"
			},
			"initWithBytesObjCType": {
				"!type": "fn(value: +Object, type: +Object) -> +NSDecimalNumber"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSDecimalNumber"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSDecimalNumber"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVContentKeyRequest": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVContentKeyRequest"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVContentKeyRequest"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVContentKeyRequest"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"status": {
				"!type": "number"
			},
			"renewsExpiringResponseData": {
				"!type": "bool"
			},
			"canProvidePersistableContentKey": {
				"!type": "bool"
			},
			"initializationData": {
				"!type": "+NSData"
			},
			"error": {
				"!type": "+NSError"
			},
			"identifier": {
				"!type": "+Object"
			},
			"options": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"respondByRequestingPersistableContentKeyRequestAndReturnError": {
				"!type": "fn(outError: +Object) -> bool"
			},
			"processContentKeyResponseError": {
				"!type": "fn(error: +NSError) -> void"
			},
			"respondByRequestingPersistableContentKeyRequest": {
				"!type": "fn() -> void"
			},
			"makeStreamingContentKeyRequestDataForAppContentIdentifierOptionsCompletionHandler": {
				"!type": "fn(appIdentifier: +NSData, contentIdentifier: +NSData, options: +Object, handler: +Function) -> void"
			},
			"processContentKeyResponse": {
				"!type": "fn(keyResponse: +AVContentKeyResponse) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVContentKeyRequest"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CAEAGLLayer": {
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +CAEAGLLayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CAEAGLLayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CAEAGLLayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CAEAGLLayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"presentsWithTransaction": {
				"!type": "bool"
			},
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAEAGLLayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +CAEAGLLayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +CAEAGLLayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +CAEAGLLayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAEAGLLayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMusicTrack": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMusicTrack"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMusicTrack"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMusicTrack"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"destinationAudioUnit": {
				"!type": "+AVAudioUnit"
			},
			"offsetTime": {
				"!type": "number"
			},
			"lengthInSeconds": {
				"!type": "number"
			},
			"destinationMIDIEndpoint": {
				"!type": "number"
			},
			"muted": {
				"!type": "bool"
			},
			"lengthInBeats": {
				"!type": "number"
			},
			"loopingEnabled": {
				"!type": "bool"
			},
			"loopRange": {
				"!type": "+Object"
			},
			"numberOfLoops": {
				"!type": "number"
			},
			"timeResolution": {
				"!type": "number"
			},
			"soloed": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMusicTrack"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioMixerNode": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioMixerNode"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioMixerNode"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioMixerNode"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"outputVolume": {
				"!type": "number"
			},
			"nextAvailableInputBus": {
				"!type": "number"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioMixerNode"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioMixerNode"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSXPCConnection": {
		"currentConnection": {
			"!type": "fn() -> +NSXPCConnection"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSXPCConnection"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSXPCConnection"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSXPCConnection"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"auditSessionIdentifier": {
				"!type": "number"
			},
			"exportedObject": {
				"!type": "+Object"
			},
			"endpoint": {
				"!type": "+NSXPCListenerEndpoint"
			},
			"effectiveGroupIdentifier": {
				"!type": "number"
			},
			"processIdentifier": {
				"!type": "number"
			},
			"jsinvalidationHandler": {
				"!type": "+Function"
			},
			"jsinterruptionHandler": {
				"!type": "+Function"
			},
			"exportedInterface": {
				"!type": "+NSXPCInterface"
			},
			"effectiveUserIdentifier": {
				"!type": "number"
			},
			"remoteObjectInterface": {
				"!type": "+NSXPCInterface"
			},
			"remoteObjectProxy": {
				"!type": "+Object"
			},
			"serviceName": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"invalidate": {
				"!type": "fn() -> void"
			},
			"suspend": {
				"!type": "fn() -> void"
			},
			"synchronousRemoteObjectProxyWithErrorHandler": {
				"!type": "fn(handler: +Function) -> +Object"
			},
			"scheduleSendBarrierBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"resume": {
				"!type": "fn() -> void"
			},
			"initWithListenerEndpoint": {
				"!type": "fn(endpoint: +NSXPCListenerEndpoint) -> +NSXPCConnection"
			},
			"remoteObjectProxyWithErrorHandler": {
				"!type": "fn(handler: +Function) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSXPCConnection"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioNode": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioNode"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioNode"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioNode"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioNode"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AUParameterGroup": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AUParameterGroup"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AUParameterGroup"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AUParameterGroup"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"allParameters": {
				"!type": "+Array"
			},
			"children": {
				"!type": "+Array"
			},
			"displayName": {
				"!type": "string"
			},
			"jsimplementorDisplayNameWithLengthCallback": {
				"!type": "+Function"
			},
			"jsimplementorValueFromStringCallback": {
				"!type": "+Function"
			},
			"jsimplementorStringFromValueCallback": {
				"!type": "+Function"
			},
			"jsimplementorValueProvider": {
				"!type": "+Function"
			},
			"jsimplementorValueObserver": {
				"!type": "+Function"
			},
			"identifier": {
				"!type": "string"
			},
			"keyPath": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"tokenByAddingParameterObserver": {
				"!type": "fn(observer: +Function) -> +Object"
			},
			"tokenByAddingParameterAutomationObserver": {
				"!type": "fn(observer: +Function) -> +Object"
			},
			"removeParameterObserver": {
				"!type": "fn(token: +Object) -> void"
			},
			"tokenByAddingParameterRecordingObserver": {
				"!type": "fn(observer: +Function) -> +Object"
			},
			"displayNameWithLength": {
				"!type": "fn(maximumLength: number) -> string"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AUParameterGroup"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSRelativeDateTimeFormatter": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSRelativeDateTimeFormatter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSRelativeDateTimeFormatter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSRelativeDateTimeFormatter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"locale": {
				"!type": "+NSLocale"
			},
			"unitsStyle": {
				"!type": "number"
			},
			"formattingContext": {
				"!type": "number"
			},
			"calendar": {
				"!type": "+NSCalendar"
			},
			"dateTimeStyle": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"localizedStringForDateRelativeToDate": {
				"!type": "fn(date: +Date, referenceDate: +Date) -> string"
			},
			"localizedStringFromDateComponents": {
				"!type": "fn(dateComponents: +NSDateComponents) -> string"
			},
			"localizedStringFromTimeInterval": {
				"!type": "fn(timeInterval: number) -> string"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"editingStringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription": {
				"!type": "fn(partialStringPtr: +Object, proposedSelRangePtr: +Object, origString: string, origSelRange: +Object, error: +Object) -> bool"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"attributedStringForObjectValueWithDefaultAttributes": {
				"!type": "fn(obj: +Object, attrs: +Object) -> +NSAttributedString"
			},
			"isPartialStringValidNewEditingStringErrorDescription": {
				"!type": "fn(partialString: string, newString: +Object, error: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSRelativeDateTimeFormatter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CAKeyframeAnimation": {
		"animationWithKeyPath": {
			"!type": "fn(path: string) -> +CAKeyframeAnimation"
		},
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"animation": {
			"!type": "fn() -> +CAKeyframeAnimation"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CAKeyframeAnimation"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CAKeyframeAnimation"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CAKeyframeAnimation"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"timingFunctions": {
				"!type": "+Array"
			},
			"rotationMode": {
				"!type": "string"
			},
			"continuityValues": {
				"!type": "+Array"
			},
			"calculationMode": {
				"!type": "string"
			},
			"biasValues": {
				"!type": "+Array"
			},
			"values": {
				"!type": "+Array"
			},
			"tensionValues": {
				"!type": "+Array"
			},
			"path": {
				"!type": "+Object"
			},
			"keyTimes": {
				"!type": "+Array"
			},
			"valueFunction": {
				"!type": "+CAValueFunction"
			},
			"cumulative": {
				"!type": "bool"
			},
			"additive": {
				"!type": "bool"
			},
			"keyPath": {
				"!type": "string"
			},
			"timingFunction": {
				"!type": "+CAMediaTimingFunction"
			},
			"delegate": {
				"!type": "+Object"
			},
			"removedOnCompletion": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAKeyframeAnimation"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioFormat": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioFormat"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioFormat"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioFormat"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"channelCount": {
				"!type": "number"
			},
			"magicCookie": {
				"!type": "+NSData"
			},
			"channelLayout": {
				"!type": "+AVAudioChannelLayout"
			},
			"settings": {
				"!type": "+Object"
			},
			"standard": {
				"!type": "bool"
			},
			"commonFormat": {
				"!type": "number"
			},
			"sampleRate": {
				"!type": "number"
			},
			"formatDescription": {
				"!type": "+Object"
			},
			"interleaved": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithStreamDescription": {
				"!type": "fn(asbd: +Object) -> +AVAudioFormat"
			},
			"initWithSettings": {
				"!type": "fn(settings: +Object) -> +AVAudioFormat"
			},
			"initStandardFormatWithSampleRateChannels": {
				"!type": "fn(sampleRate: number, channels: number) -> +AVAudioFormat"
			},
			"initWithCommonFormatSampleRateChannelsInterleaved": {
				"!type": "fn(format: number, sampleRate: number, channels: number, interleaved: bool) -> +AVAudioFormat"
			},
			"isEqual": {
				"!type": "fn(object: +Object) -> bool"
			},
			"initWithStreamDescriptionChannelLayout": {
				"!type": "fn(asbd: +Object, layout: +AVAudioChannelLayout) -> +AVAudioFormat"
			},
			"initWithCommonFormatSampleRateInterleavedChannelLayout": {
				"!type": "fn(format: number, sampleRate: number, interleaved: bool, layout: +AVAudioChannelLayout) -> +AVAudioFormat"
			},
			"initWithCMAudioFormatDescription": {
				"!type": "fn(formatDescription: +Object) -> +AVAudioFormat"
			},
			"initStandardFormatWithSampleRateChannelLayout": {
				"!type": "fn(sampleRate: number, layout: +AVAudioChannelLayout) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioFormat"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureMetadataOutput": {
		"jsnew": {
			"!type": "fn() -> +AVCaptureMetadataOutput"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureMetadataOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureMetadataOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureMetadataOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"availableMetadataObjectTypes": {
				"!type": "+Array"
			},
			"metadataObjectsDelegate": {
				"!type": "+Object"
			},
			"metadataObjectTypes": {
				"!type": "+Array"
			},
			"rectOfInterest": {
				"!type": "+Object"
			},
			"connections": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureMetadataOutput"
			},
			"setMetadataObjectsDelegateQueue": {
				"!type": "fn(objectsDelegate: +Object, objectsCallbackQueue: +Object) -> void"
			},
			"metadataOutputRectOfInterestForRect": {
				"!type": "fn(rectInOutputCoordinates: +Object) -> +Object"
			},
			"transformedMetadataObjectForMetadataObjectConnection": {
				"!type": "fn(metadataObject: +AVMetadataObject, connection: +AVCaptureConnection) -> +AVMetadataObject"
			},
			"rectForMetadataOutputRectOfInterest": {
				"!type": "fn(rectInMetadataOutputCoordinates: +Object) -> +Object"
			},
			"connectionWithMediaType": {
				"!type": "fn(mediaType: string) -> +AVCaptureConnection"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureMetadataOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLConnection": {
		"sendSynchronousRequestReturningResponseError": {
			"!type": "fn(request: +NSURLRequest, response: +Object, error: +Object) -> +NSData"
		},
		"connectionWithRequestDelegate": {
			"!type": "fn(request: +NSURLRequest, delegate: +Object) -> +NSURLConnection"
		},
		"sendAsynchronousRequestQueueCompletionHandler": {
			"!type": "fn(request: +NSURLRequest, queue: +NSOperationQueue, handler: +Function) -> void"
		},
		"canHandleRequest": {
			"!type": "fn(request: +NSURLRequest) -> bool"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLConnection"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLConnection"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLConnection"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"currentRequest": {
				"!type": "+NSURLRequest"
			},
			"originalRequest": {
				"!type": "+NSURLRequest"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithRequestDelegateStartImmediately": {
				"!type": "fn(request: +NSURLRequest, delegate: +Object, startImmediately: bool) -> +NSURLConnection"
			},
			"unscheduleFromRunLoopForMode": {
				"!type": "fn(aRunLoop: +NSRunLoop, mode: string) -> void"
			},
			"scheduleInRunLoopForMode": {
				"!type": "fn(aRunLoop: +NSRunLoop, mode: string) -> void"
			},
			"initWithRequestDelegate": {
				"!type": "fn(request: +NSURLRequest, delegate: +Object) -> +NSURLConnection"
			},
			"start": {
				"!type": "fn() -> void"
			},
			"setDelegateQueue": {
				"!type": "fn(queue: +NSOperationQueue) -> void"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLConnection"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AUParameterNode": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AUParameterNode"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AUParameterNode"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AUParameterNode"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"displayName": {
				"!type": "string"
			},
			"jsimplementorDisplayNameWithLengthCallback": {
				"!type": "+Function"
			},
			"jsimplementorValueFromStringCallback": {
				"!type": "+Function"
			},
			"jsimplementorStringFromValueCallback": {
				"!type": "+Function"
			},
			"jsimplementorValueProvider": {
				"!type": "+Function"
			},
			"jsimplementorValueObserver": {
				"!type": "+Function"
			},
			"identifier": {
				"!type": "string"
			},
			"keyPath": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"tokenByAddingParameterObserver": {
				"!type": "fn(observer: +Function) -> +Object"
			},
			"tokenByAddingParameterAutomationObserver": {
				"!type": "fn(observer: +Function) -> +Object"
			},
			"removeParameterObserver": {
				"!type": "fn(token: +Object) -> void"
			},
			"tokenByAddingParameterRecordingObserver": {
				"!type": "fn(observer: +Function) -> +Object"
			},
			"displayNameWithLength": {
				"!type": "fn(maximumLength: number) -> string"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AUParameterNode"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSProgress": {
		"progressWithTotalUnitCount": {
			"!type": "fn(unitCount: number) -> +NSProgress"
		},
		"currentProgress": {
			"!type": "fn() -> +NSProgress"
		},
		"discreteProgressWithTotalUnitCount": {
			"!type": "fn(unitCount: number) -> +NSProgress"
		},
		"progressWithTotalUnitCountParentPendingUnitCount": {
			"!type": "fn(unitCount: number, parent: +NSProgress, portionOfParentTotalUnitCount: number) -> +NSProgress"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSProgress"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSProgress"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSProgress"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"localizedDescription": {
				"!type": "string"
			},
			"paused": {
				"!type": "bool"
			},
			"fractionCompleted": {
				"!type": "number"
			},
			"fileOperationKind": {
				"!type": "string"
			},
			"estimatedTimeRemaining": {
				"!type": "number"
			},
			"indeterminate": {
				"!type": "bool"
			},
			"jscancellationHandler": {
				"!type": "+Function"
			},
			"fileURL": {
				"!type": "+NSURL"
			},
			"fileCompletedCount": {
				"!type": "number"
			},
			"pausable": {
				"!type": "bool"
			},
			"totalUnitCount": {
				"!type": "number"
			},
			"finished": {
				"!type": "bool"
			},
			"fileTotalCount": {
				"!type": "number"
			},
			"completedUnitCount": {
				"!type": "number"
			},
			"userInfo": {
				"!type": "+Object"
			},
			"kind": {
				"!type": "string"
			},
			"jsresumingHandler": {
				"!type": "+Function"
			},
			"cancellable": {
				"!type": "bool"
			},
			"localizedAdditionalDescription": {
				"!type": "string"
			},
			"jspausingHandler": {
				"!type": "+Function"
			},
			"throughput": {
				"!type": "number"
			},
			"cancelled": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"becomeCurrentWithPendingUnitCount": {
				"!type": "fn(unitCount: number) -> void"
			},
			"setUserInfoObjectForKey": {
				"!type": "fn(objectOrNil: +Object, key: string) -> void"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"pause": {
				"!type": "fn() -> void"
			},
			"resume": {
				"!type": "fn() -> void"
			},
			"initWithParentUserInfo": {
				"!type": "fn(parentProgressOrNil: +NSProgress, userInfoOrNil: +Object) -> +NSProgress"
			},
			"addChildWithPendingUnitCount": {
				"!type": "fn(child: +NSProgress, inUnitCount: number) -> void"
			},
			"performAsCurrentWithPendingUnitCountUsingBlock": {
				"!type": "fn(unitCount: number, work: +Function) -> void"
			},
			"resignCurrent": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSProgress"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSKeyedArchiver": {
		"archivedDataWithRootObjectRequiringSecureCodingError": {
			"!type": "fn(object: +Object, requiresSecureCoding: bool, error: +Object) -> +NSData"
		},
		"setClassNameForClass": {
			"!type": "fn(codedName: string, cls: +Object) -> void"
		},
		"archivedDataWithRootObject": {
			"!type": "fn(rootObject: +Object) -> +NSData"
		},
		"archiveRootObjectToFile": {
			"!type": "fn(rootObject: +Object, path: string) -> bool"
		},
		"classNameForClass": {
			"!type": "fn(cls: +Object) -> string"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSKeyedArchiver"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSKeyedArchiver"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSKeyedArchiver"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"requiresSecureCoding": {
				"!type": "bool"
			},
			"outputFormat": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"encodedData": {
				"!type": "+NSData"
			},
			"requiresSecureCoding": {
				"!type": "bool"
			},
			"systemVersion": {
				"!type": "number"
			},
			"error": {
				"!type": "+NSError"
			},
			"allowedClasses": {
				"!type": "+NSSet"
			},
			"decodingFailurePolicy": {
				"!type": "number"
			},
			"allowsKeyedCoding": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initRequiringSecureCoding": {
				"!type": "fn(requiresSecureCoding: bool) -> +NSKeyedArchiver"
			},
			"classNameForClass": {
				"!type": "fn(cls: +Object) -> string"
			},
			"encodeBoolForKey": {
				"!type": "fn(value: bool, key: string) -> void"
			},
			"setClassNameForClass": {
				"!type": "fn(codedName: string, cls: +Object) -> void"
			},
			"encodeInt32ForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeInt64ForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeFloatForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSKeyedArchiver"
			},
			"finishEncoding": {
				"!type": "fn() -> void"
			},
			"encodeBytesLengthForKey": {
				"!type": "fn(bytes: +Object, length: number, key: string) -> void"
			},
			"encodeDoubleForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeIntForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"initForWritingWithMutableData": {
				"!type": "fn(data: +NSMutableData) -> +NSKeyedArchiver"
			},
			"encodeObjectForKey": {
				"!type": "fn(object: +Object, key: string) -> void"
			},
			"encodeConditionalObjectForKey": {
				"!type": "fn(object: +Object, key: string) -> void"
			},
			"decodeObjectOfClassForKey": {
				"!type": "fn(aClass: +Object, key: string) -> +Object"
			},
			"decodeDataObject": {
				"!type": "fn() -> +NSData"
			},
			"versionForClassName": {
				"!type": "fn(className: string) -> number"
			},
			"encodeBoolForKey": {
				"!type": "fn(value: bool, key: string) -> void"
			},
			"encodeConditionalObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"decodeCMTimeForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"failWithError": {
				"!type": "fn(error: +NSError) -> void"
			},
			"encodeArrayOfObjCTypeCountAt": {
				"!type": "fn(type: +Object, count: number, array: +Object) -> void"
			},
			"setObjectZone": {
				"!type": "fn(zone: +Object) -> void"
			},
			"decodeInt64ForKey": {
				"!type": "fn(key: string) -> number"
			},
			"decodeArrayOfObjectsOfClassesForKey": {
				"!type": "fn(classes: +NSSet, key: string) -> +Array"
			},
			"encodeInt64ForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeInt32ForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeValuesOfObjCTypes": {
				"!type": "fn(types: +Object, args: Array.prototype) -> void"
			},
			"encodeIntegerForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"decodeTopLevelObjectForKeyError": {
				"!type": "fn(key: string, error: +Object) -> +Object"
			},
			"decodeCMTimeRangeForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"decodeValuesOfObjCTypes": {
				"!type": "fn(types: +Object, args: Array.prototype) -> void"
			},
			"decodeValueOfObjCTypeAt": {
				"!type": "fn(type: +Object, data: +Object) -> void"
			},
			"containsValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"encodeFloatForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"objectZone": {
				"!type": "fn() -> +Object"
			},
			"decodeDoubleForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeByrefObject": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"decodeInt32ForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"decodeDictionaryWithKeysOfClassesObjectsOfClassesForKey": {
				"!type": "fn(keyClasses: +NSSet, objectClasses: +NSSet, key: string) -> +Object"
			},
			"encodeDataObject": {
				"!type": "fn(data: +NSData) -> void"
			},
			"decodeTopLevelObjectAndReturnError": {
				"!type": "fn(error: +Object) -> +Object"
			},
			"decodeFloatForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeValueOfObjCTypeAt": {
				"!type": "fn(type: +Object, addr: +Object) -> void"
			},
			"decodeObjectForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"encodeBytesLengthForKey": {
				"!type": "fn(bytes: +Object, length: number, key: string) -> void"
			},
			"decodeArrayOfObjCTypeCountAt": {
				"!type": "fn(itemType: +Object, count: number, array: +Object) -> void"
			},
			"encodeRootObject": {
				"!type": "fn(rootObject: +Object) -> void"
			},
			"decodeBoolForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"encodeBytesLength": {
				"!type": "fn(byteaddr: +Object, length: number) -> void"
			},
			"encodeCMTimeRangeForKey": {
				"!type": "fn(timeRange: +Object, key: string) -> void"
			},
			"decodeBytesWithReturnedLength": {
				"!type": "fn(lengthp: +Object) -> +Object"
			},
			"decodeIntForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeCMTimeMappingForKey": {
				"!type": "fn(timeMapping: +Object, key: string) -> void"
			},
			"decodeArrayOfObjectsOfClassForKey": {
				"!type": "fn(cls: +Object, key: string) -> +Array"
			},
			"encodeDoubleForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeCMTimeForKey": {
				"!type": "fn(time: +Object, key: string) -> void"
			},
			"decodeObjectOfClassesForKey": {
				"!type": "fn(classes: +NSSet, key: string) -> +Object"
			},
			"decodeDictionaryWithKeysOfClassObjectsOfClassForKey": {
				"!type": "fn(keyCls: +Object, objectCls: +Object, key: string) -> +Object"
			},
			"encodeIntForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"decodeCMTimeMappingForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"decodeTopLevelObjectOfClassesForKeyError": {
				"!type": "fn(classes: +NSSet, key: string, error: +Object) -> +Object"
			},
			"encodeObjectForKey": {
				"!type": "fn(object: +Object, key: string) -> void"
			},
			"decodeObject": {
				"!type": "fn() -> +Object"
			},
			"encodeBycopyObject": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"decodePropertyListForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"decodeTopLevelObjectOfClassForKeyError": {
				"!type": "fn(aClass: +Object, key: string, error: +Object) -> +Object"
			},
			"decodeIntegerForKey": {
				"!type": "fn(key: string) -> number"
			},
			"decodeValueOfObjCTypeAtSize": {
				"!type": "fn(type: +Object, data: +Object, size: number) -> void"
			},
			"decodeBytesForKeyReturnedLength": {
				"!type": "fn(key: string, lengthp: +Object) -> +Object"
			},
			"encodeConditionalObjectForKey": {
				"!type": "fn(object: +Object, key: string) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSKeyedArchiver"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioPCMBuffer": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioPCMBuffer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioPCMBuffer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioPCMBuffer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"frameLength": {
				"!type": "number"
			},
			"stride": {
				"!type": "number"
			},
			"frameCapacity": {
				"!type": "number"
			},
			"format": {
				"!type": "+AVAudioFormat"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithPCMFormatFrameCapacity": {
				"!type": "fn(format: +AVAudioFormat, frameCapacity: number) -> +AVAudioPCMBuffer"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioPCMBuffer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitAcceleration": {
		"metersPerSecondSquared": {
			"!type": "fn() -> +NSUnitAcceleration"
		},
		"gravity": {
			"!type": "fn() -> +NSUnitAcceleration"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitAcceleration"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitAcceleration"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitAcceleration"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitAcceleration"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitAcceleration"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitAcceleration"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitAcceleration"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVSampleBufferAudioRenderer": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVSampleBufferAudioRenderer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVSampleBufferAudioRenderer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVSampleBufferAudioRenderer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"status": {
				"!type": "number"
			},
			"volume": {
				"!type": "number"
			},
			"audioTimePitchAlgorithm": {
				"!type": "string"
			},
			"muted": {
				"!type": "bool"
			},
			"error": {
				"!type": "+NSError"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"flushFromSourceTimeCompletionHandler": {
				"!type": "fn(time: +Object, completionHandler: +Function) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVSampleBufferAudioRenderer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnitGenerator": {
		"instantiateWithComponentDescriptionOptionsCompletionHandler": {
			"!type": "fn(audioComponentDescription: +Object, options: number, completionHandler: +Function) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnitGenerator"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnitGenerator"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnitGenerator"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"bypass": {
				"!type": "bool"
			},
			"name": {
				"!type": "string"
			},
			"audioComponentDescription": {
				"!type": "+Object"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"version": {
				"!type": "number"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithAudioComponentDescription": {
				"!type": "fn(audioComponentDescription: +Object) -> +AVAudioUnitGenerator"
			},
			"loadAudioUnitPresetAtURLError": {
				"!type": "fn(url: +NSURL, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnitGenerator"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitFuelEfficiency": {
		"litersPer100Kilometers": {
			"!type": "fn() -> +NSUnitFuelEfficiency"
		},
		"milesPerImperialGallon": {
			"!type": "fn() -> +NSUnitFuelEfficiency"
		},
		"milesPerGallon": {
			"!type": "fn() -> +NSUnitFuelEfficiency"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitFuelEfficiency"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitFuelEfficiency"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitFuelEfficiency"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitFuelEfficiency"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitFuelEfficiency"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitFuelEfficiency"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitFuelEfficiency"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureAudioDataOutput": {
		"jsnew": {
			"!type": "fn() -> +AVCaptureAudioDataOutput"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureAudioDataOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureAudioDataOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureAudioDataOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"sampleBufferDelegate": {
				"!type": "+Object"
			},
			"connections": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"recommendedAudioSettingsForAssetWriterWithOutputFileType": {
				"!type": "fn(outputFileType: string) -> +Object"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureAudioDataOutput"
			},
			"setSampleBufferDelegateQueue": {
				"!type": "fn(sampleBufferDelegate: +Object, sampleBufferCallbackQueue: +Object) -> void"
			},
			"metadataOutputRectOfInterestForRect": {
				"!type": "fn(rectInOutputCoordinates: +Object) -> +Object"
			},
			"transformedMetadataObjectForMetadataObjectConnection": {
				"!type": "fn(metadataObject: +AVMetadataObject, connection: +AVCaptureConnection) -> +AVMetadataObject"
			},
			"rectForMetadataOutputRectOfInterest": {
				"!type": "fn(rectInMetadataOutputCoordinates: +Object) -> +Object"
			},
			"connectionWithMediaType": {
				"!type": "fn(mediaType: string) -> +AVCaptureConnection"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureAudioDataOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMetadataItem": {
		"metadataItemWithPropertiesOfMetadataItemValueLoadingHandler": {
			"!type": "fn(metadataItem: +AVMetadataItem, handler: +Function) -> +AVMetadataItem"
		},
		"keySpaceForIdentifier": {
			"!type": "fn(identifier: string) -> string"
		},
		"identifierForKeyKeySpace": {
			"!type": "fn(key: +Object, keySpace: string) -> string"
		},
		"metadataItemsFromArrayWithKeyKeySpace": {
			"!type": "fn(metadataItems: +Array, key: +Object, keySpace: string) -> +Array"
		},
		"metadataItemsFromArrayFilteredByIdentifier": {
			"!type": "fn(metadataItems: +Array, identifier: string) -> +Array"
		},
		"metadataItemsFromArrayWithLocale": {
			"!type": "fn(metadataItems: +Array, locale: +NSLocale) -> +Array"
		},
		"metadataItemsFromArrayFilteredAndSortedAccordingToPreferredLanguages": {
			"!type": "fn(metadataItems: +Array, preferredLanguages: +Array) -> +Array"
		},
		"keyForIdentifier": {
			"!type": "fn(identifier: string) -> +Object"
		},
		"metadataItemsFromArrayFilteredByMetadataItemFilter": {
			"!type": "fn(metadataItems: +Array, metadataItemFilter: +AVMetadataItemFilter) -> +Array"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMetadataItem"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMetadataItem"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMetadataItem"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"startDate": {
				"!type": "+Date"
			},
			"dateValue": {
				"!type": "+Date"
			},
			"keySpace": {
				"!type": "string"
			},
			"locale": {
				"!type": "+NSLocale"
			},
			"commonKey": {
				"!type": "string"
			},
			"dataValue": {
				"!type": "+NSData"
			},
			"extendedLanguageTag": {
				"!type": "string"
			},
			"value": {
				"!type": "+Object"
			},
			"dataType": {
				"!type": "string"
			},
			"numberValue": {
				"!type": "number"
			},
			"extraAttributes": {
				"!type": "+Object"
			},
			"key": {
				"!type": "+Object"
			},
			"time": {
				"!type": "+Object"
			},
			"duration": {
				"!type": "+Object"
			},
			"stringValue": {
				"!type": "string"
			},
			"identifier": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"statusOfValueForKeyError": {
				"!type": "fn(key: string, outError: +Object) -> number"
			},
			"loadValuesAsynchronouslyForKeysCompletionHandler": {
				"!type": "fn(keys: +Array, handler: +Function) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMetadataItem"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitConverterLinear": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitConverterLinear"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitConverterLinear"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitConverterLinear"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"coefficient": {
				"!type": "number"
			},
			"constant": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithCoefficientConstant": {
				"!type": "fn(coefficient: number, constant: number) -> +NSUnitConverterLinear"
			},
			"initWithCoefficient": {
				"!type": "fn(coefficient: number) -> +NSUnitConverterLinear"
			},
			"baseUnitValueFromValue": {
				"!type": "fn(value: number) -> number"
			},
			"valueFromBaseUnitValue": {
				"!type": "fn(baseUnitValue: number) -> number"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitConverterLinear"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUbiquitousKeyValueStore": {
		"defaultStore": {
			"!type": "fn() -> +NSUbiquitousKeyValueStore"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUbiquitousKeyValueStore"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUbiquitousKeyValueStore"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUbiquitousKeyValueStore"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"dictionaryRepresentation": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"doubleForKey": {
				"!type": "fn(aKey: string) -> number"
			},
			"setDataForKey": {
				"!type": "fn(aData: +NSData, aKey: string) -> void"
			},
			"setArrayForKey": {
				"!type": "fn(anArray: +Array, aKey: string) -> void"
			},
			"boolForKey": {
				"!type": "fn(aKey: string) -> bool"
			},
			"setLongLongForKey": {
				"!type": "fn(value: number, aKey: string) -> void"
			},
			"synchronize": {
				"!type": "fn() -> bool"
			},
			"dataForKey": {
				"!type": "fn(aKey: string) -> +NSData"
			},
			"setStringForKey": {
				"!type": "fn(aString: string, aKey: string) -> void"
			},
			"arrayForKey": {
				"!type": "fn(aKey: string) -> +Array"
			},
			"setObjectForKey": {
				"!type": "fn(anObject: +Object, aKey: string) -> void"
			},
			"setDoubleForKey": {
				"!type": "fn(value: number, aKey: string) -> void"
			},
			"setBoolForKey": {
				"!type": "fn(value: bool, aKey: string) -> void"
			},
			"removeObjectForKey": {
				"!type": "fn(aKey: string) -> void"
			},
			"dictionaryForKey": {
				"!type": "fn(aKey: string) -> +Object"
			},
			"longLongForKey": {
				"!type": "fn(aKey: string) -> number"
			},
			"stringForKey": {
				"!type": "fn(aKey: string) -> string"
			},
			"objectForKey": {
				"!type": "fn(aKey: string) -> +Object"
			},
			"setDictionaryForKey": {
				"!type": "fn(aDictionary: +Object, aKey: string) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUbiquitousKeyValueStore"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetResourceLoadingRequestor": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetResourceLoadingRequestor"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetResourceLoadingRequestor"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetResourceLoadingRequestor"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"providesExpiredSessionReports": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetResourceLoadingRequestor"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetResourceLoadingDataRequest": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetResourceLoadingDataRequest"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetResourceLoadingDataRequest"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetResourceLoadingDataRequest"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"requestedLength": {
				"!type": "number"
			},
			"currentOffset": {
				"!type": "number"
			},
			"requestsAllDataToEndOfResource": {
				"!type": "bool"
			},
			"requestedOffset": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"respondWithData": {
				"!type": "fn(data: +NSData) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetResourceLoadingDataRequest"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetReaderTrackOutput": {
		"assetReaderTrackOutputWithTrackOutputSettings": {
			"!type": "fn(track: +AVAssetTrack, outputSettings: +Object) -> +AVAssetReaderTrackOutput"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetReaderTrackOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetReaderTrackOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetReaderTrackOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"track": {
				"!type": "+AVAssetTrack"
			},
			"audioTimePitchAlgorithm": {
				"!type": "string"
			},
			"outputSettings": {
				"!type": "+Object"
			},
			"alwaysCopiesSampleData": {
				"!type": "bool"
			},
			"mediaType": {
				"!type": "string"
			},
			"supportsRandomAccess": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithTrackOutputSettings": {
				"!type": "fn(track: +AVAssetTrack, outputSettings: +Object) -> +AVAssetReaderTrackOutput"
			},
			"copyNextSampleBuffer": {
				"!type": "fn() -> +Object"
			},
			"resetForReadingTimeRanges": {
				"!type": "fn(timeRanges: +Array) -> void"
			},
			"markConfigurationAsFinal": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetReaderTrackOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureSession": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureSession"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureSession"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureSession"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"inputs": {
				"!type": "+Array"
			},
			"masterClock": {
				"!type": "+Object"
			},
			"outputs": {
				"!type": "+Array"
			},
			"interrupted": {
				"!type": "bool"
			},
			"automaticallyConfiguresCaptureDeviceForWideColor": {
				"!type": "bool"
			},
			"connections": {
				"!type": "+Array"
			},
			"running": {
				"!type": "bool"
			},
			"automaticallyConfiguresApplicationAudioSession": {
				"!type": "bool"
			},
			"usesApplicationAudioSession": {
				"!type": "bool"
			},
			"sessionPreset": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"addInput": {
				"!type": "fn(input: +AVCaptureInput) -> void"
			},
			"removeConnection": {
				"!type": "fn(connection: +AVCaptureConnection) -> void"
			},
			"addOutputWithNoConnections": {
				"!type": "fn(output: +AVCaptureOutput) -> void"
			},
			"stopRunning": {
				"!type": "fn() -> void"
			},
			"canAddOutput": {
				"!type": "fn(output: +AVCaptureOutput) -> bool"
			},
			"addOutput": {
				"!type": "fn(output: +AVCaptureOutput) -> void"
			},
			"canSetSessionPreset": {
				"!type": "fn(preset: string) -> bool"
			},
			"canAddConnection": {
				"!type": "fn(connection: +AVCaptureConnection) -> bool"
			},
			"addConnection": {
				"!type": "fn(connection: +AVCaptureConnection) -> void"
			},
			"removeInput": {
				"!type": "fn(input: +AVCaptureInput) -> void"
			},
			"removeOutput": {
				"!type": "fn(output: +AVCaptureOutput) -> void"
			},
			"addInputWithNoConnections": {
				"!type": "fn(input: +AVCaptureInput) -> void"
			},
			"commitConfiguration": {
				"!type": "fn() -> void"
			},
			"canAddInput": {
				"!type": "fn(input: +AVCaptureInput) -> bool"
			},
			"beginConfiguration": {
				"!type": "fn() -> void"
			},
			"startRunning": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureSession"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSDataDetector": {
		"dataDetectorWithTypesError": {
			"!type": "fn(checkingTypes: number, error: +Object) -> +NSDataDetector"
		},
		"regularExpressionWithPatternOptionsError": {
			"!type": "fn(pattern: string, options: number, error: +Object) -> +NSRegularExpression"
		},
		"escapedTemplateForString": {
			"!type": "fn(string: string) -> string"
		},
		"escapedPatternForString": {
			"!type": "fn(string: string) -> string"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSDataDetector"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSDataDetector"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSDataDetector"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"checkingTypes": {
				"!type": "number"
			},
			"pattern": {
				"!type": "string"
			},
			"options": {
				"!type": "number"
			},
			"numberOfCaptureGroups": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithTypesError": {
				"!type": "fn(checkingTypes: number, error: +Object) -> +NSDataDetector"
			},
			"initWithPatternOptionsError": {
				"!type": "fn(pattern: string, options: number, error: +Object) -> +NSDataDetector"
			},
			"numberOfMatchesInStringOptionsRange": {
				"!type": "fn(string: string, options: number, range: +Object) -> number"
			},
			"matchesInStringOptionsRange": {
				"!type": "fn(string: string, options: number, range: +Object) -> +Array"
			},
			"stringByReplacingMatchesInStringOptionsRangeWithTemplate": {
				"!type": "fn(string: string, options: number, range: +Object, templ: string) -> string"
			},
			"enumerateMatchesInStringOptionsRangeUsingBlock": {
				"!type": "fn(string: string, options: number, range: +Object, block: +Function) -> void"
			},
			"rangeOfFirstMatchInStringOptionsRange": {
				"!type": "fn(string: string, options: number, range: +Object) -> +Object"
			},
			"firstMatchInStringOptionsRange": {
				"!type": "fn(string: string, options: number, range: +Object) -> +NSTextCheckingResult"
			},
			"replaceMatchesInStringOptionsRangeWithTemplate": {
				"!type": "fn(string: +NSMutableString, options: number, range: +Object, templ: string) -> number"
			},
			"replacementStringForResultInStringOffsetTemplate": {
				"!type": "fn(result: +NSTextCheckingResult, string: string, offset: number, templ: string) -> string"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSDataDetector"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSPurgeableData": {
		"dataWithLength": {
			"!type": "fn(length: number) -> +NSPurgeableData"
		},
		"dataWithCapacity": {
			"!type": "fn(aNumItems: number) -> +NSPurgeableData"
		},
		"dataWithContentsOfFile": {
			"!type": "fn(path: string) -> +NSPurgeableData"
		},
		"dataWithContentsOfMappedFile": {
			"!type": "fn(path: string) -> +Object"
		},
		"dataWithBytesNoCopyLength": {
			"!type": "fn(bytes: +Object, length: number) -> +NSPurgeableData"
		},
		"dataWithContentsOfURL": {
			"!type": "fn(url: +NSURL) -> +NSPurgeableData"
		},
		"dataWithBytesNoCopyLengthFreeWhenDone": {
			"!type": "fn(bytes: +Object, length: number, b: bool) -> +NSPurgeableData"
		},
		"dataWithData": {
			"!type": "fn(data: +NSData) -> +NSPurgeableData"
		},
		"dataWithContentsOfURLOptionsError": {
			"!type": "fn(url: +NSURL, readOptionsMask: number, errorPtr: +Object) -> +NSPurgeableData"
		},
		"dataWithBytesLength": {
			"!type": "fn(bytes: +Object, length: number) -> +NSPurgeableData"
		},
		"dataWithContentsOfFileOptionsError": {
			"!type": "fn(path: string, readOptionsMask: number, errorPtr: +Object) -> +NSPurgeableData"
		},
		"data": {
			"!type": "fn() -> +NSPurgeableData"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSPurgeableData"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSPurgeableData"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSPurgeableData"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"length": {
				"!type": "number"
			},
			"length": {
				"!type": "number"
			},
			"description": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"appendData": {
				"!type": "fn(other: +NSData) -> void"
			},
			"resetBytesInRange": {
				"!type": "fn(range: +Object) -> void"
			},
			"initWithCapacity": {
				"!type": "fn(capacity: number) -> +NSPurgeableData"
			},
			"appendBytesLength": {
				"!type": "fn(bytes: +Object, length: number) -> void"
			},
			"decompressUsingAlgorithmError": {
				"!type": "fn(algorithm: number, error: +Object) -> bool"
			},
			"replaceBytesInRangeWithBytes": {
				"!type": "fn(range: +Object, bytes: +Object) -> void"
			},
			"replaceBytesInRangeWithBytesLength": {
				"!type": "fn(range: +Object, replacementBytes: +Object, replacementLength: number) -> void"
			},
			"initWithLength": {
				"!type": "fn(length: number) -> +NSPurgeableData"
			},
			"compressUsingAlgorithmError": {
				"!type": "fn(algorithm: number, error: +Object) -> bool"
			},
			"setData": {
				"!type": "fn(data: +NSData) -> void"
			},
			"increaseLengthBy": {
				"!type": "fn(extraLength: number) -> void"
			},
			"initWithContentsOfFileOptionsError": {
				"!type": "fn(path: string, readOptionsMask: number, errorPtr: +Object) -> +NSPurgeableData"
			},
			"initWithBase64Encoding": {
				"!type": "fn(base64String: string) -> +Object"
			},
			"subdataWithRange": {
				"!type": "fn(range: +Object) -> +NSData"
			},
			"initWithBytesNoCopyLengthFreeWhenDone": {
				"!type": "fn(bytes: +Object, length: number, b: bool) -> +NSPurgeableData"
			},
			"writeToURLOptionsError": {
				"!type": "fn(url: +NSURL, writeOptionsMask: number, errorPtr: +Object) -> bool"
			},
			"rangeOfDataOptionsRange": {
				"!type": "fn(dataToFind: +NSData, mask: number, searchRange: +Object) -> +Object"
			},
			"base64Encoding": {
				"!type": "fn() -> string"
			},
			"initWithContentsOfURL": {
				"!type": "fn(url: +NSURL) -> +NSPurgeableData"
			},
			"compressedDataUsingAlgorithmError": {
				"!type": "fn(algorithm: number, error: +Object) -> +NSPurgeableData"
			},
			"enumerateByteRangesUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"base64EncodedStringWithOptions": {
				"!type": "fn(options: number) -> string"
			},
			"getBytesLength": {
				"!type": "fn(buffer: +Object, length: number) -> void"
			},
			"initWithBytesNoCopyLengthDeallocator": {
				"!type": "fn(bytes: +Object, length: number, deallocator: +Function) -> +NSPurgeableData"
			},
			"initWithContentsOfFile": {
				"!type": "fn(path: string) -> +NSPurgeableData"
			},
			"writeToFileAtomically": {
				"!type": "fn(path: string, useAuxiliaryFile: bool) -> bool"
			},
			"initWithBytesLength": {
				"!type": "fn(bytes: +Object, length: number) -> +NSPurgeableData"
			},
			"writeToFileOptionsError": {
				"!type": "fn(path: string, writeOptionsMask: number, errorPtr: +Object) -> bool"
			},
			"base64EncodedDataWithOptions": {
				"!type": "fn(options: number) -> +NSData"
			},
			"getBytes": {
				"!type": "fn(buffer: +Object) -> void"
			},
			"isEqualToData": {
				"!type": "fn(other: +NSData) -> bool"
			},
			"writeToURLAtomically": {
				"!type": "fn(url: +NSURL, atomically: bool) -> bool"
			},
			"getBytesRange": {
				"!type": "fn(buffer: +Object, range: +Object) -> void"
			},
			"initWithBase64EncodedDataOptions": {
				"!type": "fn(base64Data: +NSData, options: number) -> +NSPurgeableData"
			},
			"initWithContentsOfMappedFile": {
				"!type": "fn(path: string) -> +Object"
			},
			"decompressedDataUsingAlgorithmError": {
				"!type": "fn(algorithm: number, error: +Object) -> +NSPurgeableData"
			},
			"initWithContentsOfURLOptionsError": {
				"!type": "fn(url: +NSURL, readOptionsMask: number, errorPtr: +Object) -> +NSPurgeableData"
			},
			"initWithBytesNoCopyLength": {
				"!type": "fn(bytes: +Object, length: number) -> +NSPurgeableData"
			},
			"initWithData": {
				"!type": "fn(data: +NSData) -> +NSPurgeableData"
			},
			"initWithBase64EncodedStringOptions": {
				"!type": "fn(base64String: string, options: number) -> +NSPurgeableData"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSPurgeableData"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AUAudioUnitBus": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AUAudioUnitBus"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AUAudioUnitBus"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AUAudioUnitBus"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"supportedChannelLayoutTags": {
				"!type": "+Array"
			},
			"index": {
				"!type": "number"
			},
			"contextPresentationLatency": {
				"!type": "number"
			},
			"name": {
				"!type": "string"
			},
			"format": {
				"!type": "+AVAudioFormat"
			},
			"shouldAllocateBuffer": {
				"!type": "bool"
			},
			"enabled": {
				"!type": "bool"
			},
			"busType": {
				"!type": "number"
			},
			"ownerAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"maximumChannelCount": {
				"!type": "number"
			},
			"supportedChannelCounts": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setFormatError": {
				"!type": "fn(format: +AVAudioFormat, outError: +Object) -> bool"
			},
			"initWithFormatError": {
				"!type": "fn(format: +AVAudioFormat, outError: +Object) -> +AUAudioUnitBus"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AUAudioUnitBus"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSHashTable": {
		"weakObjectsHashTable": {
			"!type": "fn() -> +NSHashTable"
		},
		"hashTableWithOptions": {
			"!type": "fn(options: number) -> +NSHashTable"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSHashTable"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSHashTable"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSHashTable"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"allObjects": {
				"!type": "+Array"
			},
			"anyObject": {
				"!type": "+Object"
			},
			"setRepresentation": {
				"!type": "+NSSet"
			},
			"pointerFunctions": {
				"!type": "+NSPointerFunctions"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"objectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"containsObject": {
				"!type": "fn(anObject: +Object) -> bool"
			},
			"isEqualToHashTable": {
				"!type": "fn(other: +NSHashTable) -> bool"
			},
			"addObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"minusHashTable": {
				"!type": "fn(other: +NSHashTable) -> void"
			},
			"unionHashTable": {
				"!type": "fn(other: +NSHashTable) -> void"
			},
			"isSubsetOfHashTable": {
				"!type": "fn(other: +NSHashTable) -> bool"
			},
			"initWithOptionsCapacity": {
				"!type": "fn(options: number, initialCapacity: number) -> +NSHashTable"
			},
			"removeAllObjects": {
				"!type": "fn() -> void"
			},
			"initWithPointerFunctionsCapacity": {
				"!type": "fn(functions: +NSPointerFunctions, initialCapacity: number) -> +NSHashTable"
			},
			"intersectHashTable": {
				"!type": "fn(other: +NSHashTable) -> void"
			},
			"member": {
				"!type": "fn(object: +Object) -> +Object"
			},
			"intersectsHashTable": {
				"!type": "fn(other: +NSHashTable) -> bool"
			},
			"removeObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSHashTable"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureDataOutputSynchronizer": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureDataOutputSynchronizer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureDataOutputSynchronizer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureDataOutputSynchronizer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"dataOutputs": {
				"!type": "+Array"
			},
			"delegate": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithDataOutputs": {
				"!type": "fn(dataOutputs: +Array) -> +AVCaptureDataOutputSynchronizer"
			},
			"setDelegateQueue": {
				"!type": "fn(delegate: +Object, delegateCallbackQueue: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureDataOutputSynchronizer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSNetServiceBrowser": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSNetServiceBrowser"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSNetServiceBrowser"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSNetServiceBrowser"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"delegate": {
				"!type": "+Object"
			},
			"includesPeerToPeer": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"searchForServicesOfTypeInDomain": {
				"!type": "fn(type: string, domainString: string) -> void"
			},
			"scheduleInRunLoopForMode": {
				"!type": "fn(aRunLoop: +NSRunLoop, mode: string) -> void"
			},
			"stop": {
				"!type": "fn() -> void"
			},
			"searchForRegistrationDomains": {
				"!type": "fn() -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSNetServiceBrowser"
			},
			"removeFromRunLoopForMode": {
				"!type": "fn(aRunLoop: +NSRunLoop, mode: string) -> void"
			},
			"searchForBrowsableDomains": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSNetServiceBrowser"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMutableDictionary": {
		"dictionaryWithContentsOfFile": {
			"!type": "fn(path: string) -> +NSMutableDictionary"
		},
		"dictionaryWithSharedKeySet": {
			"!type": "fn(keyset: +Object) -> +NSMutableDictionary"
		},
		"dictionaryWithCapacity": {
			"!type": "fn(numItems: number) -> +NSMutableDictionary"
		},
		"dictionaryWithContentsOfURL": {
			"!type": "fn(url: +NSURL) -> +NSMutableDictionary"
		},
		"dictionaryWithObjectsForKeysCount": {
			"!type": "fn(objects: +Object, keys: +Object, cnt: number) -> +NSMutableDictionary"
		},
		"dictionaryWithDictionary": {
			"!type": "fn(dict: +Object) -> +NSMutableDictionary"
		},
		"dictionaryWithContentsOfFile": {
			"!type": "fn(path: string) -> +Object"
		},
		"dictionary": {
			"!type": "fn() -> +NSMutableDictionary"
		},
		"dictionaryWithObjectsForKeys": {
			"!type": "fn(objects: +Array, keys: +Array) -> +NSMutableDictionary"
		},
		"sharedKeySetForKeys": {
			"!type": "fn(keys: +Array) -> +Object"
		},
		"dictionaryWithObjectsAndKeys": {
			"!type": "fn(firstObject: +Object, args: Array.prototype) -> +NSMutableDictionary"
		},
		"dictionaryWithContentsOfURLError": {
			"!type": "fn(url: +NSURL, error: +Object) -> +Object"
		},
		"dictionaryWithObjectForKey": {
			"!type": "fn(object: +Object, key: +Object) -> +NSMutableDictionary"
		},
		"dictionaryWithContentsOfURL": {
			"!type": "fn(url: +NSURL) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMutableDictionary"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMutableDictionary"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMutableDictionary"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"allValues": {
				"!type": "+Array"
			},
			"description": {
				"!type": "string"
			},
			"allKeys": {
				"!type": "+Array"
			},
			"descriptionInStringsFileFormat": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithContentsOfURL": {
				"!type": "fn(url: +NSURL) -> +NSMutableDictionary"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSMutableDictionary"
			},
			"initWithCapacity": {
				"!type": "fn(numItems: number) -> +NSMutableDictionary"
			},
			"removeObjectsForKeys": {
				"!type": "fn(keyArray: +Array) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableDictionary"
			},
			"setObjectForKeyedSubscript": {
				"!type": "fn(obj: +Object, key: +Object) -> void"
			},
			"setDictionary": {
				"!type": "fn(otherDictionary: +Object) -> void"
			},
			"setObjectForKey": {
				"!type": "fn(anObject: +Object, aKey: +Object) -> void"
			},
			"removeAllObjects": {
				"!type": "fn() -> void"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"removeObjectForKey": {
				"!type": "fn(aKey: +Object) -> void"
			},
			"addEntriesFromDictionary": {
				"!type": "fn(otherDictionary: +Object) -> void"
			},
			"initWithContentsOfFile": {
				"!type": "fn(path: string) -> +NSMutableDictionary"
			},
			"keysSortedByValueUsingComparator": {
				"!type": "fn(cmptr: +Function) -> +Array"
			},
			"fileSystemNumber": {
				"!type": "fn() -> number"
			},
			"countByEnumeratingWithStateObjectsCount": {
				"!type": "fn(state: +Object, buffer: +Object, len: number) -> number"
			},
			"keysOfEntriesWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> +NSSet"
			},
			"initWithContentsOfURLError": {
				"!type": "fn(url: +NSURL, error: +Object) -> +Object"
			},
			"fileGroupOwnerAccountName": {
				"!type": "fn() -> string"
			},
			"initWithContentsOfFile": {
				"!type": "fn(path: string) -> +Object"
			},
			"getObjectsAndKeysCount": {
				"!type": "fn(objects: +Object, keys: +Object, count: number) -> void"
			},
			"enumerateKeysAndObjectsWithOptionsUsingBlock": {
				"!type": "fn(opts: number, block: +Function) -> void"
			},
			"fileCreationDate": {
				"!type": "fn() -> +Date"
			},
			"fileModificationDate": {
				"!type": "fn() -> +Date"
			},
			"objectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"fileExtensionHidden": {
				"!type": "fn() -> bool"
			},
			"allKeysForObject": {
				"!type": "fn(anObject: +Object) -> +Array"
			},
			"fileType": {
				"!type": "fn() -> string"
			},
			"fileIsImmutable": {
				"!type": "fn() -> bool"
			},
			"writeToURLAtomically": {
				"!type": "fn(url: +NSURL, atomically: bool) -> bool"
			},
			"enumerateKeysAndObjectsUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableDictionary"
			},
			"initWithDictionaryCopyItems": {
				"!type": "fn(otherDictionary: +Object, flag: bool) -> +NSMutableDictionary"
			},
			"keysOfEntriesPassingTest": {
				"!type": "fn(predicate: +Function) -> +NSSet"
			},
			"fileGroupOwnerAccountID": {
				"!type": "fn() -> number"
			},
			"initWithObjectsForKeysCount": {
				"!type": "fn(objects: +Object, keys: +Object, cnt: number) -> +NSMutableDictionary"
			},
			"keysSortedByValueWithOptionsUsingComparator": {
				"!type": "fn(opts: number, cmptr: +Function) -> +Array"
			},
			"descriptionWithLocale": {
				"!type": "fn(locale: +Object) -> string"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"keyEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSMutableDictionary"
			},
			"fileIsAppendOnly": {
				"!type": "fn() -> bool"
			},
			"fileOwnerAccountName": {
				"!type": "fn() -> string"
			},
			"fileSize": {
				"!type": "fn() -> number"
			},
			"getObjectsAndKeys": {
				"!type": "fn(objects: +Object, keys: +Object) -> void"
			},
			"keysSortedByValueUsingSelector": {
				"!type": "fn(comparator: string) -> +Array"
			},
			"fileSystemFileNumber": {
				"!type": "fn() -> number"
			},
			"fileHFSTypeCode": {
				"!type": "fn() -> number"
			},
			"initWithObjectsForKeys": {
				"!type": "fn(objects: +Array, keys: +Array) -> +NSMutableDictionary"
			},
			"initWithObjectsAndKeys": {
				"!type": "fn(firstObject: +Object, args: Array.prototype) -> +NSMutableDictionary"
			},
			"fileHFSCreatorCode": {
				"!type": "fn() -> number"
			},
			"initWithContentsOfURL": {
				"!type": "fn(url: +NSURL) -> +Object"
			},
			"objectForKeyedSubscript": {
				"!type": "fn(key: +Object) -> +Object"
			},
			"filePosixPermissions": {
				"!type": "fn() -> number"
			},
			"writeToFileAtomically": {
				"!type": "fn(path: string, useAuxiliaryFile: bool) -> bool"
			},
			"descriptionWithLocaleIndent": {
				"!type": "fn(locale: +Object, level: number) -> string"
			},
			"fileOwnerAccountID": {
				"!type": "fn() -> number"
			},
			"objectsForKeysNotFoundMarker": {
				"!type": "fn(keys: +Array, marker: +Object) -> +Array"
			},
			"isEqualToDictionary": {
				"!type": "fn(otherDictionary: +Object) -> bool"
			},
			"writeToURLError": {
				"!type": "fn(url: +NSURL, error: +Object) -> bool"
			},
			"initWithDictionary": {
				"!type": "fn(otherDictionary: +Object) -> +NSMutableDictionary"
			},
			"objectForKey": {
				"!type": "fn(aKey: +Object) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableDictionary"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureInputPort": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureInputPort"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureInputPort"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureInputPort"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"clock": {
				"!type": "+Object"
			},
			"enabled": {
				"!type": "bool"
			},
			"mediaType": {
				"!type": "string"
			},
			"sourceDevicePosition": {
				"!type": "number"
			},
			"sourceDeviceType": {
				"!type": "string"
			},
			"input": {
				"!type": "+AVCaptureInput"
			},
			"formatDescription": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureInputPort"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSExpression": {
		"expressionForKeyPath": {
			"!type": "fn(keyPath: string) -> +NSExpression"
		},
		"expressionForConditionalTrueExpressionFalseExpression": {
			"!type": "fn(predicate: +NSPredicate, trueExpression: +NSExpression, falseExpression: +NSExpression) -> +NSExpression"
		},
		"expressionWithFormat": {
			"!type": "fn(expressionFormat: string, args: Array.prototype) -> +NSExpression"
		},
		"expressionForUnionSetWith": {
			"!type": "fn(left: +NSExpression, right: +NSExpression) -> +NSExpression"
		},
		"expressionForVariable": {
			"!type": "fn(string: string) -> +NSExpression"
		},
		"expressionWithFormatArgumentArray": {
			"!type": "fn(expressionFormat: string, arguments: +Array) -> +NSExpression"
		},
		"expressionForConstantValue": {
			"!type": "fn(obj: +Object) -> +NSExpression"
		},
		"expressionForSubqueryUsingIteratorVariablePredicate": {
			"!type": "fn(expression: +NSExpression, variable: string, predicate: +NSPredicate) -> +NSExpression"
		},
		"expressionWithFormatArguments": {
			"!type": "fn(expressionFormat: string, argList: +Object) -> +NSExpression"
		},
		"expressionForFunctionArguments": {
			"!type": "fn(name: string, parameters: +Array) -> +NSExpression"
		},
		"expressionForAggregate": {
			"!type": "fn(subexpressions: +Array) -> +NSExpression"
		},
		"expressionForAnyKey": {
			"!type": "fn() -> +NSExpression"
		},
		"expressionForIntersectSetWith": {
			"!type": "fn(left: +NSExpression, right: +NSExpression) -> +NSExpression"
		},
		"expressionForBlockArguments": {
			"!type": "fn(block: +Function, arguments: +Array) -> +NSExpression"
		},
		"expressionForFunctionSelectorNameArguments": {
			"!type": "fn(target: +NSExpression, name: string, parameters: +Array) -> +NSExpression"
		},
		"expressionForEvaluatedObject": {
			"!type": "fn() -> +NSExpression"
		},
		"expressionForMinusSetWith": {
			"!type": "fn(left: +NSExpression, right: +NSExpression) -> +NSExpression"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSExpression"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSExpression"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSExpression"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"function": {
				"!type": "string"
			},
			"trueExpression": {
				"!type": "+NSExpression"
			},
			"constantValue": {
				"!type": "+Object"
			},
			"leftExpression": {
				"!type": "+NSExpression"
			},
			"jsexpressionBlock": {
				"!type": "+Function"
			},
			"expressionType": {
				"!type": "number"
			},
			"falseExpression": {
				"!type": "+NSExpression"
			},
			"predicate": {
				"!type": "+NSPredicate"
			},
			"collection": {
				"!type": "+Object"
			},
			"rightExpression": {
				"!type": "+NSExpression"
			},
			"operand": {
				"!type": "+NSExpression"
			},
			"arguments": {
				"!type": "+Array"
			},
			"variable": {
				"!type": "string"
			},
			"keyPath": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSExpression"
			},
			"expressionValueWithObjectContext": {
				"!type": "fn(object: +Object, context: +NSMutableDictionary) -> +Object"
			},
			"allowEvaluation": {
				"!type": "fn() -> void"
			},
			"initWithExpressionType": {
				"!type": "fn(type: number) -> +NSExpression"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSExpression"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureAudioChannel": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureAudioChannel"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureAudioChannel"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureAudioChannel"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"averagePowerLevel": {
				"!type": "number"
			},
			"peakHoldLevel": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureAudioChannel"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitInformationStorage": {
		"petabytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"zebibytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"exabits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"yottabytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"gibibits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"gigabits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"terabytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"kibibytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"megabytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"gibibytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"exbibytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"megabits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"kilobits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"yottabits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"zettabits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"mebibytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"kilobytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"tebibits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"bits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"yobibits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"exbibits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"mebibits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"gigabytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"yobibytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"petabits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"pebibits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"zebibits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"zettabytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"tebibytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"nibbles": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"kibibits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"bytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"terabits": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"pebibytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"exabytes": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitInformationStorage"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitInformationStorage"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitInformationStorage"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitInformationStorage"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitInformationStorage"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVContentKeySession": {
		"contentKeySessionWithKeySystemStorageDirectoryAtURL": {
			"!type": "fn(keySystem: string, storageURL: +NSURL) -> +AVContentKeySession"
		},
		"contentKeySessionWithKeySystem": {
			"!type": "fn(keySystem: string) -> +AVContentKeySession"
		},
		"removePendingExpiredSessionReportsWithAppIdentifierStorageDirectoryAtURL": {
			"!type": "fn(expiredSessionReports: +Array, appIdentifier: +NSData, storageURL: +NSURL) -> void"
		},
		"pendingExpiredSessionReportsWithAppIdentifierStorageDirectoryAtURL": {
			"!type": "fn(appIdentifier: +NSData, storageURL: +NSURL) -> +Array"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVContentKeySession"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVContentKeySession"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVContentKeySession"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"keySystem": {
				"!type": "string"
			},
			"contentKeyRecipients": {
				"!type": "+Array"
			},
			"delegate": {
				"!type": "+Object"
			},
			"storageURL": {
				"!type": "+NSURL"
			},
			"contentProtectionSessionIdentifier": {
				"!type": "+NSData"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"removeContentKeyRecipient": {
				"!type": "fn(recipient: +Object) -> void"
			},
			"processContentKeyRequestWithIdentifierInitializationDataOptions": {
				"!type": "fn(identifier: +Object, initializationData: +NSData, options: +Object) -> void"
			},
			"setDelegateQueue": {
				"!type": "fn(delegate: +Object, delegateQueue: +Object) -> void"
			},
			"invalidatePersistableContentKeyOptionsCompletionHandler": {
				"!type": "fn(persistableContentKeyData: +NSData, options: +Object, handler: +Function) -> void"
			},
			"addContentKeyRecipient": {
				"!type": "fn(recipient: +Object) -> void"
			},
			"makeSecureTokenForExpirationDateOfPersistableContentKeyCompletionHandler": {
				"!type": "fn(persistableContentKeyData: +NSData, handler: +Function) -> void"
			},
			"expire": {
				"!type": "fn() -> void"
			},
			"invalidateAllPersistableContentKeysForAppOptionsCompletionHandler": {
				"!type": "fn(appIdentifier: +NSData, options: +Object, handler: +Function) -> void"
			},
			"renewExpiringResponseDataForContentKeyRequest": {
				"!type": "fn(contentKeyRequest: +AVContentKeyRequest) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVContentKeySession"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AUParameter": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AUParameter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AUParameter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AUParameter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"valueStrings": {
				"!type": "+Array"
			},
			"unitName": {
				"!type": "string"
			},
			"dependentParameters": {
				"!type": "+Array"
			},
			"maxValue": {
				"!type": "number"
			},
			"value": {
				"!type": "number"
			},
			"minValue": {
				"!type": "number"
			},
			"flags": {
				"!type": "number"
			},
			"address": {
				"!type": "number"
			},
			"unit": {
				"!type": "number"
			},
			"displayName": {
				"!type": "string"
			},
			"jsimplementorDisplayNameWithLengthCallback": {
				"!type": "+Function"
			},
			"jsimplementorValueFromStringCallback": {
				"!type": "+Function"
			},
			"jsimplementorStringFromValueCallback": {
				"!type": "+Function"
			},
			"jsimplementorValueProvider": {
				"!type": "+Function"
			},
			"jsimplementorValueObserver": {
				"!type": "+Function"
			},
			"identifier": {
				"!type": "string"
			},
			"keyPath": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setValueOriginatorAtHostTimeEventType": {
				"!type": "fn(value: number, originator: +Object, hostTime: number, eventType: number) -> void"
			},
			"setValueOriginatorAtHostTime": {
				"!type": "fn(value: number, originator: +Object, hostTime: number) -> void"
			},
			"valueFromString": {
				"!type": "fn(string: string) -> number"
			},
			"stringFromValue": {
				"!type": "fn(value: +Object) -> string"
			},
			"setValueOriginator": {
				"!type": "fn(value: number, originator: +Object) -> void"
			},
			"tokenByAddingParameterObserver": {
				"!type": "fn(observer: +Function) -> +Object"
			},
			"tokenByAddingParameterAutomationObserver": {
				"!type": "fn(observer: +Function) -> +Object"
			},
			"removeParameterObserver": {
				"!type": "fn(token: +Object) -> void"
			},
			"tokenByAddingParameterRecordingObserver": {
				"!type": "fn(observer: +Function) -> +Object"
			},
			"displayNameWithLength": {
				"!type": "fn(maximumLength: number) -> string"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AUParameter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSNotificationCenter": {
		"defaultCenter": {
			"!type": "fn() -> +NSNotificationCenter"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSNotificationCenter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSNotificationCenter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSNotificationCenter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"removeObserver": {
				"!type": "fn(observer: +Object) -> void"
			},
			"removeObserverNameObject": {
				"!type": "fn(observer: +Object, aName: string, anObject: +Object) -> void"
			},
			"addObserverForNameObjectQueueUsingBlock": {
				"!type": "fn(name: string, obj: +Object, queue: +NSOperationQueue, block: +Function) -> +Object"
			},
			"postNotification": {
				"!type": "fn(notification: +NSNotification) -> void"
			},
			"addObserverSelectorNameObject": {
				"!type": "fn(observer: +Object, aSelector: string, aName: string, anObject: +Object) -> void"
			},
			"postNotificationNameObject": {
				"!type": "fn(aName: string, anObject: +Object) -> void"
			},
			"postNotificationNameObjectUserInfo": {
				"!type": "fn(aName: string, anObject: +Object, aUserInfo: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSNotificationCenter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetReaderOutputMetadataAdaptor": {
		"assetReaderOutputMetadataAdaptorWithAssetReaderTrackOutput": {
			"!type": "fn(trackOutput: +AVAssetReaderTrackOutput) -> +AVAssetReaderOutputMetadataAdaptor"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetReaderOutputMetadataAdaptor"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetReaderOutputMetadataAdaptor"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetReaderOutputMetadataAdaptor"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"assetReaderTrackOutput": {
				"!type": "+AVAssetReaderTrackOutput"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithAssetReaderTrackOutput": {
				"!type": "fn(trackOutput: +AVAssetReaderTrackOutput) -> +AVAssetReaderOutputMetadataAdaptor"
			},
			"nextTimedMetadataGroup": {
				"!type": "fn() -> +AVTimedMetadataGroup"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetReaderOutputMetadataAdaptor"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CAMetalLayer": {
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +CAMetalLayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CAMetalLayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CAMetalLayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CAMetalLayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"drawableSize": {
				"!type": "+Object"
			},
			"colorspace": {
				"!type": "+Object"
			},
			"allowsNextDrawableTimeout": {
				"!type": "bool"
			},
			"presentsWithTransaction": {
				"!type": "bool"
			},
			"framebufferOnly": {
				"!type": "bool"
			},
			"maximumDrawableCount": {
				"!type": "number"
			},
			"pixelFormat": {
				"!type": "number"
			},
			"device": {
				"!type": "+Object"
			},
			"preferredDevice": {
				"!type": "+Object"
			},
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"nextDrawable": {
				"!type": "fn() -> +Object"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAMetalLayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +CAMetalLayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +CAMetalLayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +CAMetalLayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAMetalLayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSLocale": {
		"canonicalLocaleIdentifierFromString": {
			"!type": "fn(string: string) -> string"
		},
		"ISOLanguageCodes": {
			"!type": "fn() -> +Array"
		},
		"windowsLocaleCodeFromLocaleIdentifier": {
			"!type": "fn(localeIdentifier: string) -> number"
		},
		"ISOCountryCodes": {
			"!type": "fn() -> +Array"
		},
		"canonicalLanguageIdentifierFromString": {
			"!type": "fn(string: string) -> string"
		},
		"localeIdentifierFromComponents": {
			"!type": "fn(dict: +Object) -> string"
		},
		"autoupdatingCurrentLocale": {
			"!type": "fn() -> +NSLocale"
		},
		"preferredLanguages": {
			"!type": "fn() -> +Array"
		},
		"lineDirectionForLanguage": {
			"!type": "fn(isoLangCode: string) -> number"
		},
		"commonISOCurrencyCodes": {
			"!type": "fn() -> +Array"
		},
		"characterDirectionForLanguage": {
			"!type": "fn(isoLangCode: string) -> number"
		},
		"componentsFromLocaleIdentifier": {
			"!type": "fn(string: string) -> +Object"
		},
		"localeIdentifierFromWindowsLocaleCode": {
			"!type": "fn(lcid: number) -> string"
		},
		"currentLocale": {
			"!type": "fn() -> +NSLocale"
		},
		"systemLocale": {
			"!type": "fn() -> +NSLocale"
		},
		"ISOCurrencyCodes": {
			"!type": "fn() -> +Array"
		},
		"availableLocaleIdentifiers": {
			"!type": "fn() -> +Array"
		},
		"localeWithLocaleIdentifier": {
			"!type": "fn(ident: string) -> +NSLocale"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSLocale"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSLocale"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSLocale"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"languageCode": {
				"!type": "string"
			},
			"countryCode": {
				"!type": "string"
			},
			"exemplarCharacterSet": {
				"!type": "+NSCharacterSet"
			},
			"variantCode": {
				"!type": "string"
			},
			"currencySymbol": {
				"!type": "string"
			},
			"groupingSeparator": {
				"!type": "string"
			},
			"localeIdentifier": {
				"!type": "string"
			},
			"calendarIdentifier": {
				"!type": "string"
			},
			"decimalSeparator": {
				"!type": "string"
			},
			"currencyCode": {
				"!type": "string"
			},
			"collationIdentifier": {
				"!type": "string"
			},
			"collatorIdentifier": {
				"!type": "string"
			},
			"alternateQuotationBeginDelimiter": {
				"!type": "string"
			},
			"alternateQuotationEndDelimiter": {
				"!type": "string"
			},
			"quotationBeginDelimiter": {
				"!type": "string"
			},
			"scriptCode": {
				"!type": "string"
			},
			"quotationEndDelimiter": {
				"!type": "string"
			},
			"usesMetricSystem": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithLocaleIdentifier": {
				"!type": "fn(string: string) -> +NSLocale"
			},
			"localizedStringForCountryCode": {
				"!type": "fn(countryCode: string) -> string"
			},
			"localizedStringForLanguageCode": {
				"!type": "fn(languageCode: string) -> string"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSLocale"
			},
			"localizedStringForVariantCode": {
				"!type": "fn(variantCode: string) -> string"
			},
			"localizedStringForLocaleIdentifier": {
				"!type": "fn(localeIdentifier: string) -> string"
			},
			"localizedStringForCollatorIdentifier": {
				"!type": "fn(collatorIdentifier: string) -> string"
			},
			"localizedStringForCalendarIdentifier": {
				"!type": "fn(calendarIdentifier: string) -> string"
			},
			"localizedStringForScriptCode": {
				"!type": "fn(scriptCode: string) -> string"
			},
			"objectForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"localizedStringForCurrencyCode": {
				"!type": "fn(currencyCode: string) -> string"
			},
			"localizedStringForCollationIdentifier": {
				"!type": "fn(collationIdentifier: string) -> string"
			},
			"displayNameForKeyValue": {
				"!type": "fn(key: string, value: +Object) -> string"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSLocale"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMutableAudioMix": {
		"audioMix": {
			"!type": "fn() -> +AVMutableAudioMix"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMutableAudioMix"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMutableAudioMix"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMutableAudioMix"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"inputParameters": {
				"!type": "+Array"
			},
			"inputParameters": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMutableAudioMix"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSTimeZone": {
		"timeZoneForSecondsFromGMT": {
			"!type": "fn(seconds: number) -> +NSTimeZone"
		},
		"timeZoneWithAbbreviation": {
			"!type": "fn(abbreviation: string) -> +NSTimeZone"
		},
		"knownTimeZoneNames": {
			"!type": "fn() -> +Array"
		},
		"systemTimeZone": {
			"!type": "fn() -> +NSTimeZone"
		},
		"defaultTimeZone": {
			"!type": "fn() -> +NSTimeZone"
		},
		"timeZoneWithNameData": {
			"!type": "fn(tzName: string, aData: +NSData) -> +NSTimeZone"
		},
		"setDefaultTimeZone": {
			"!type": "fn(defaultTimeZone: +NSTimeZone) -> void"
		},
		"timeZoneDataVersion": {
			"!type": "fn() -> string"
		},
		"localTimeZone": {
			"!type": "fn() -> +NSTimeZone"
		},
		"setAbbreviationDictionary": {
			"!type": "fn(abbreviationDictionary: +Object) -> void"
		},
		"resetSystemTimeZone": {
			"!type": "fn() -> void"
		},
		"timeZoneWithName": {
			"!type": "fn(tzName: string) -> +NSTimeZone"
		},
		"abbreviationDictionary": {
			"!type": "fn() -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSTimeZone"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSTimeZone"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSTimeZone"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"secondsFromGMT": {
				"!type": "number"
			},
			"name": {
				"!type": "string"
			},
			"daylightSavingTime": {
				"!type": "bool"
			},
			"daylightSavingTimeOffset": {
				"!type": "number"
			},
			"abbreviation": {
				"!type": "string"
			},
			"nextDaylightSavingTimeTransition": {
				"!type": "+Date"
			},
			"data": {
				"!type": "+NSData"
			},
			"description": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"isDaylightSavingTimeForDate": {
				"!type": "fn(aDate: +Date) -> bool"
			},
			"localizedNameLocale": {
				"!type": "fn(style: number, locale: +NSLocale) -> string"
			},
			"secondsFromGMTForDate": {
				"!type": "fn(aDate: +Date) -> number"
			},
			"isEqualToTimeZone": {
				"!type": "fn(aTimeZone: +NSTimeZone) -> bool"
			},
			"initWithNameData": {
				"!type": "fn(tzName: string, aData: +NSData) -> +NSTimeZone"
			},
			"abbreviationForDate": {
				"!type": "fn(aDate: +Date) -> string"
			},
			"daylightSavingTimeOffsetForDate": {
				"!type": "fn(aDate: +Date) -> number"
			},
			"initWithName": {
				"!type": "fn(tzName: string) -> +NSTimeZone"
			},
			"nextDaylightSavingTimeTransitionAfterDate": {
				"!type": "fn(aDate: +Date) -> +Date"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSTimeZone"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMutableVideoCompositionLayerInstruction": {
		"videoCompositionLayerInstruction": {
			"!type": "fn() -> +AVMutableVideoCompositionLayerInstruction"
		},
		"videoCompositionLayerInstructionWithAssetTrack": {
			"!type": "fn(track: +AVAssetTrack) -> +AVMutableVideoCompositionLayerInstruction"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMutableVideoCompositionLayerInstruction"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMutableVideoCompositionLayerInstruction"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMutableVideoCompositionLayerInstruction"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"trackID": {
				"!type": "number"
			},
			"trackID": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setOpacityAtTime": {
				"!type": "fn(opacity: number, time: +Object) -> void"
			},
			"setCropRectangleRampFromStartCropRectangleToEndCropRectangleTimeRange": {
				"!type": "fn(startCropRectangle: +Object, endCropRectangle: +Object, timeRange: +Object) -> void"
			},
			"setTransformAtTime": {
				"!type": "fn(transform: +Object, time: +Object) -> void"
			},
			"setCropRectangleAtTime": {
				"!type": "fn(cropRectangle: +Object, time: +Object) -> void"
			},
			"setTransformRampFromStartTransformToEndTransformTimeRange": {
				"!type": "fn(startTransform: +Object, endTransform: +Object, timeRange: +Object) -> void"
			},
			"setOpacityRampFromStartOpacityToEndOpacityTimeRange": {
				"!type": "fn(startOpacity: number, endOpacity: number, timeRange: +Object) -> void"
			},
			"getTransformRampForTimeStartTransformEndTransformTimeRange": {
				"!type": "fn(time: +Object, startTransform: +Object, endTransform: +Object, timeRange: +Object) -> bool"
			},
			"getCropRectangleRampForTimeStartCropRectangleEndCropRectangleTimeRange": {
				"!type": "fn(time: +Object, startCropRectangle: +Object, endCropRectangle: +Object, timeRange: +Object) -> bool"
			},
			"getOpacityRampForTimeStartOpacityEndOpacityTimeRange": {
				"!type": "fn(time: +Object, startOpacity: +Object, endOpacity: +Object, timeRange: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMutableVideoCompositionLayerInstruction"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVSpeechSynthesizer": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVSpeechSynthesizer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVSpeechSynthesizer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVSpeechSynthesizer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"outputChannels": {
				"!type": "+Array"
			},
			"mixToTelephonyUplink": {
				"!type": "bool"
			},
			"paused": {
				"!type": "bool"
			},
			"delegate": {
				"!type": "+Object"
			},
			"usesApplicationAudioSession": {
				"!type": "bool"
			},
			"speaking": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"continueSpeaking": {
				"!type": "fn() -> bool"
			},
			"writeUtteranceToBufferCallback": {
				"!type": "fn(utterance: +AVSpeechUtterance, bufferCallback: +Function) -> void"
			},
			"speakUtterance": {
				"!type": "fn(utterance: +AVSpeechUtterance) -> void"
			},
			"pauseSpeakingAtBoundary": {
				"!type": "fn(boundary: number) -> bool"
			},
			"stopSpeakingAtBoundary": {
				"!type": "fn(boundary: number) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVSpeechSynthesizer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSInvocationOperation": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSInvocationOperation"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSInvocationOperation"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSInvocationOperation"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"invocation": {
				"!type": "+NSInvocation"
			},
			"result": {
				"!type": "+Object"
			},
			"ready": {
				"!type": "bool"
			},
			"name": {
				"!type": "string"
			},
			"jscompletionBlock": {
				"!type": "+Function"
			},
			"concurrent": {
				"!type": "bool"
			},
			"qualityOfService": {
				"!type": "number"
			},
			"queuePriority": {
				"!type": "number"
			},
			"executing": {
				"!type": "bool"
			},
			"finished": {
				"!type": "bool"
			},
			"dependencies": {
				"!type": "+Array"
			},
			"asynchronous": {
				"!type": "bool"
			},
			"threadPriority": {
				"!type": "number"
			},
			"cancelled": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithInvocation": {
				"!type": "fn(inv: +NSInvocation) -> +NSInvocationOperation"
			},
			"initWithTargetSelectorObject": {
				"!type": "fn(target: +Object, sel: string, arg: +Object) -> +NSInvocationOperation"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"waitUntilFinished": {
				"!type": "fn() -> void"
			},
			"start": {
				"!type": "fn() -> void"
			},
			"main": {
				"!type": "fn() -> void"
			},
			"addDependency": {
				"!type": "fn(op: +NSOperation) -> void"
			},
			"removeDependency": {
				"!type": "fn(op: +NSOperation) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSInvocationOperation"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureAutoExposureBracketedStillImageSettings": {
		"autoExposureSettingsWithExposureTargetBias": {
			"!type": "fn(exposureTargetBias: number) -> +AVCaptureAutoExposureBracketedStillImageSettings"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureAutoExposureBracketedStillImageSettings"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureAutoExposureBracketedStillImageSettings"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureAutoExposureBracketedStillImageSettings"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"exposureTargetBias": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureAutoExposureBracketedStillImageSettings"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVQueuePlayer": {
		"queuePlayerWithItems": {
			"!type": "fn(items: +Array) -> +AVQueuePlayer"
		},
		"availableHDRModes": {
			"!type": "fn() -> number"
		},
		"eligibleForHDRPlayback": {
			"!type": "fn() -> bool"
		},
		"playerWithPlayerItem": {
			"!type": "fn(item: +AVPlayerItem) -> +AVQueuePlayer"
		},
		"playerWithURL": {
			"!type": "fn(URL: +NSURL) -> +AVQueuePlayer"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVQueuePlayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVQueuePlayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVQueuePlayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"status": {
				"!type": "number"
			},
			"masterClock": {
				"!type": "+Object"
			},
			"automaticallyWaitsToMinimizeStalling": {
				"!type": "bool"
			},
			"error": {
				"!type": "+NSError"
			},
			"reasonForWaitingToPlay": {
				"!type": "string"
			},
			"airPlayVideoActive": {
				"!type": "bool"
			},
			"volume": {
				"!type": "number"
			},
			"rate": {
				"!type": "number"
			},
			"closedCaptionDisplayEnabled": {
				"!type": "bool"
			},
			"preventsDisplaySleepDuringVideoPlayback": {
				"!type": "bool"
			},
			"externalPlaybackActive": {
				"!type": "bool"
			},
			"externalPlaybackVideoGravity": {
				"!type": "string"
			},
			"actionAtItemEnd": {
				"!type": "number"
			},
			"usesAirPlayVideoWhileAirPlayScreenIsActive": {
				"!type": "bool"
			},
			"muted": {
				"!type": "bool"
			},
			"outputObscuredDueToInsufficientExternalProtection": {
				"!type": "bool"
			},
			"usesExternalPlaybackWhileExternalScreenIsActive": {
				"!type": "bool"
			},
			"timeControlStatus": {
				"!type": "number"
			},
			"appliesMediaSelectionCriteriaAutomatically": {
				"!type": "bool"
			},
			"allowsAirPlayVideo": {
				"!type": "bool"
			},
			"currentItem": {
				"!type": "+AVPlayerItem"
			},
			"allowsExternalPlayback": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"removeAllItems": {
				"!type": "fn() -> void"
			},
			"removeItem": {
				"!type": "fn(item: +AVPlayerItem) -> void"
			},
			"items": {
				"!type": "fn() -> +Array"
			},
			"initWithItems": {
				"!type": "fn(items: +Array) -> +AVQueuePlayer"
			},
			"insertItemAfterItem": {
				"!type": "fn(item: +AVPlayerItem, afterItem: +AVPlayerItem) -> void"
			},
			"canInsertItemAfterItem": {
				"!type": "fn(item: +AVPlayerItem, afterItem: +AVPlayerItem) -> bool"
			},
			"advanceToNextItem": {
				"!type": "fn() -> void"
			},
			"play": {
				"!type": "fn() -> void"
			},
			"pause": {
				"!type": "fn() -> void"
			},
			"addBoundaryTimeObserverForTimesQueueUsingBlock": {
				"!type": "fn(times: +Array, queue: +Object, block: +Function) -> +Object"
			},
			"setRateTimeAtHostTime": {
				"!type": "fn(rate: number, itemTime: +Object, hostClockTime: +Object) -> void"
			},
			"seekToDateCompletionHandler": {
				"!type": "fn(date: +Date, completionHandler: +Function) -> void"
			},
			"currentTime": {
				"!type": "fn() -> +Object"
			},
			"initWithPlayerItem": {
				"!type": "fn(item: +AVPlayerItem) -> +AVQueuePlayer"
			},
			"removeTimeObserver": {
				"!type": "fn(observer: +Object) -> void"
			},
			"playImmediatelyAtRate": {
				"!type": "fn(rate: number) -> void"
			},
			"mediaSelectionCriteriaForMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +AVPlayerMediaSelectionCriteria"
			},
			"seekToTimeCompletionHandler": {
				"!type": "fn(time: +Object, completionHandler: +Function) -> void"
			},
			"initWithURL": {
				"!type": "fn(URL: +NSURL) -> +AVQueuePlayer"
			},
			"seekToTimeToleranceBeforeToleranceAfterCompletionHandler": {
				"!type": "fn(time: +Object, toleranceBefore: +Object, toleranceAfter: +Object, completionHandler: +Function) -> void"
			},
			"replaceCurrentItemWithPlayerItem": {
				"!type": "fn(item: +AVPlayerItem) -> void"
			},
			"prerollAtRateCompletionHandler": {
				"!type": "fn(rate: number, completionHandler: +Function) -> void"
			},
			"cancelPendingPrerolls": {
				"!type": "fn() -> void"
			},
			"setMediaSelectionCriteriaForMediaCharacteristic": {
				"!type": "fn(criteria: +AVPlayerMediaSelectionCriteria, mediaCharacteristic: string) -> void"
			},
			"seekToTime": {
				"!type": "fn(time: +Object) -> void"
			},
			"seekToTimeToleranceBeforeToleranceAfter": {
				"!type": "fn(time: +Object, toleranceBefore: +Object, toleranceAfter: +Object) -> void"
			},
			"seekToDate": {
				"!type": "fn(date: +Date) -> void"
			},
			"addPeriodicTimeObserverForIntervalQueueUsingBlock": {
				"!type": "fn(interval: +Object, queue: +Object, block: +Function) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVQueuePlayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AUAudioUnitBusArray": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AUAudioUnitBusArray"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AUAudioUnitBusArray"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AUAudioUnitBusArray"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"countChangeable": {
				"!type": "bool"
			},
			"ownerAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"busType": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithAudioUnitBusType": {
				"!type": "fn(owner: +AUAudioUnit, busType: number) -> +AUAudioUnitBusArray"
			},
			"replaceBusses": {
				"!type": "fn(busArray: +Array) -> void"
			},
			"setBusCountError": {
				"!type": "fn(count: number, outError: +Object) -> bool"
			},
			"objectAtIndexedSubscript": {
				"!type": "fn(index: number) -> +AUAudioUnitBus"
			},
			"addObserverToAllBussesForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"initWithAudioUnitBusTypeBusses": {
				"!type": "fn(owner: +AUAudioUnit, busType: number, busArray: +Array) -> +AUAudioUnitBusArray"
			},
			"removeObserverFromAllBussesForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AUAudioUnitBusArray"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CATiledLayer": {
		"fadeDuration": {
			"!type": "fn() -> number"
		},
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +CATiledLayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CATiledLayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CATiledLayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CATiledLayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"tileSize": {
				"!type": "+Object"
			},
			"levelsOfDetailBias": {
				"!type": "number"
			},
			"levelsOfDetail": {
				"!type": "number"
			},
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CATiledLayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +CATiledLayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +CATiledLayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +CATiledLayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CATiledLayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnitComponent": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnitComponent"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnitComponent"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnitComponent"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"allTagNames": {
				"!type": "+Array"
			},
			"name": {
				"!type": "string"
			},
			"audioComponentDescription": {
				"!type": "+Object"
			},
			"hasMIDIInput": {
				"!type": "bool"
			},
			"localizedTypeName": {
				"!type": "string"
			},
			"typeName": {
				"!type": "string"
			},
			"versionString": {
				"!type": "string"
			},
			"version": {
				"!type": "number"
			},
			"sandboxSafe": {
				"!type": "bool"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"audioComponent": {
				"!type": "+Object"
			},
			"hasMIDIOutput": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnitComponent"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSXPCInterface": {
		"interfaceWithProtocol": {
			"!type": "fn(protocol: +Protocol) -> +NSXPCInterface"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSXPCInterface"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSXPCInterface"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSXPCInterface"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"protocol": {
				"!type": "+Protocol"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setInterfaceForSelectorArgumentIndexOfReply": {
				"!type": "fn(ifc: +NSXPCInterface, sel: string, arg: number, ofReply: bool) -> void"
			},
			"classesForSelectorArgumentIndexOfReply": {
				"!type": "fn(sel: string, arg: number, ofReply: bool) -> +NSSet"
			},
			"setClassesForSelectorArgumentIndexOfReply": {
				"!type": "fn(classes: +NSSet, sel: string, arg: number, ofReply: bool) -> void"
			},
			"interfaceForSelectorArgumentIndexOfReply": {
				"!type": "fn(sel: string, arg: number, ofReply: bool) -> +NSXPCInterface"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSXPCInterface"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSEnergyFormatter": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSEnergyFormatter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSEnergyFormatter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSEnergyFormatter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"unitStyle": {
				"!type": "number"
			},
			"numberFormatter": {
				"!type": "+NSNumberFormatter"
			},
			"forFoodEnergyUse": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"unitStringFromJoulesUsedUnit": {
				"!type": "fn(numberInJoules: number, unitp: +Object) -> string"
			},
			"stringFromJoules": {
				"!type": "fn(numberInJoules: number) -> string"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"unitStringFromValueUnit": {
				"!type": "fn(value: number, unit: number) -> string"
			},
			"stringFromValueUnit": {
				"!type": "fn(value: number, unit: number) -> string"
			},
			"editingStringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription": {
				"!type": "fn(partialStringPtr: +Object, proposedSelRangePtr: +Object, origString: string, origSelRange: +Object, error: +Object) -> bool"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"attributedStringForObjectValueWithDefaultAttributes": {
				"!type": "fn(obj: +Object, attrs: +Object) -> +NSAttributedString"
			},
			"isPartialStringValidNewEditingStringErrorDescription": {
				"!type": "fn(partialString: string, newString: +Object, error: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSEnergyFormatter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerLayer": {
		"playerLayerWithPlayer": {
			"!type": "fn(player: +AVPlayer) -> +AVPlayerLayer"
		},
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +AVPlayerLayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerLayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerLayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerLayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"pixelBufferAttributes": {
				"!type": "+Object"
			},
			"player": {
				"!type": "+AVPlayer"
			},
			"videoGravity": {
				"!type": "string"
			},
			"videoRect": {
				"!type": "+Object"
			},
			"readyForDisplay": {
				"!type": "bool"
			},
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerLayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +AVPlayerLayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +AVPlayerLayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +AVPlayerLayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerLayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSPointerArray": {
		"strongObjectsPointerArray": {
			"!type": "fn() -> +NSPointerArray"
		},
		"pointerArrayWithOptions": {
			"!type": "fn(options: number) -> +NSPointerArray"
		},
		"weakObjectsPointerArray": {
			"!type": "fn() -> +NSPointerArray"
		},
		"pointerArrayWithPointerFunctions": {
			"!type": "fn(functions: +NSPointerFunctions) -> +NSPointerArray"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSPointerArray"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSPointerArray"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSPointerArray"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"allObjects": {
				"!type": "+Array"
			},
			"pointerFunctions": {
				"!type": "+NSPointerFunctions"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"compact": {
				"!type": "fn() -> void"
			},
			"replacePointerAtIndexWithPointer": {
				"!type": "fn(index: number, item: +Object) -> void"
			},
			"insertPointerAtIndex": {
				"!type": "fn(item: +Object, index: number) -> void"
			},
			"addPointer": {
				"!type": "fn(pointer: +Object) -> void"
			},
			"initWithOptions": {
				"!type": "fn(options: number) -> +NSPointerArray"
			},
			"pointerAtIndex": {
				"!type": "fn(index: number) -> +Object"
			},
			"initWithPointerFunctions": {
				"!type": "fn(functions: +NSPointerFunctions) -> +NSPointerArray"
			},
			"removePointerAtIndex": {
				"!type": "fn(index: number) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSPointerArray"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioMix": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioMix"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioMix"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioMix"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"inputParameters": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioMix"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPersistableContentKeyRequest": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPersistableContentKeyRequest"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPersistableContentKeyRequest"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPersistableContentKeyRequest"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"status": {
				"!type": "number"
			},
			"renewsExpiringResponseData": {
				"!type": "bool"
			},
			"canProvidePersistableContentKey": {
				"!type": "bool"
			},
			"initializationData": {
				"!type": "+NSData"
			},
			"error": {
				"!type": "+NSError"
			},
			"identifier": {
				"!type": "+Object"
			},
			"options": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"persistableContentKeyFromKeyVendorResponseOptionsError": {
				"!type": "fn(keyVendorResponse: +NSData, options: +Object, outError: +Object) -> +NSData"
			},
			"respondByRequestingPersistableContentKeyRequestAndReturnError": {
				"!type": "fn(outError: +Object) -> bool"
			},
			"processContentKeyResponseError": {
				"!type": "fn(error: +NSError) -> void"
			},
			"respondByRequestingPersistableContentKeyRequest": {
				"!type": "fn() -> void"
			},
			"makeStreamingContentKeyRequestDataForAppContentIdentifierOptionsCompletionHandler": {
				"!type": "fn(appIdentifier: +NSData, contentIdentifier: +NSData, options: +Object, handler: +Function) -> void"
			},
			"processContentKeyResponse": {
				"!type": "fn(keyResponse: +AVContentKeyResponse) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPersistableContentKeyRequest"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSExtensionItem": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSExtensionItem"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSExtensionItem"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSExtensionItem"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"attributedTitle": {
				"!type": "+NSAttributedString"
			},
			"attributedContentText": {
				"!type": "+NSAttributedString"
			},
			"attachments": {
				"!type": "+Array"
			},
			"userInfo": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSExtensionItem"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVTimedMetadataGroup": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVTimedMetadataGroup"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVTimedMetadataGroup"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVTimedMetadataGroup"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"items": {
				"!type": "+Array"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"items": {
				"!type": "+Array"
			},
			"classifyingLabel": {
				"!type": "string"
			},
			"uniqueID": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSampleBuffer": {
				"!type": "fn(sampleBuffer: +Object) -> +AVTimedMetadataGroup"
			},
			"initWithItemsTimeRange": {
				"!type": "fn(items: +Array, timeRange: +Object) -> +AVTimedMetadataGroup"
			},
			"copyFormatDescription": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVTimedMetadataGroup"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureSynchronizedMetadataObjectData": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureSynchronizedMetadataObjectData"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureSynchronizedMetadataObjectData"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureSynchronizedMetadataObjectData"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"metadataObjects": {
				"!type": "+Array"
			},
			"timestamp": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureSynchronizedMetadataObjectData"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitConverter": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitConverter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitConverter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitConverter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"baseUnitValueFromValue": {
				"!type": "fn(value: number) -> number"
			},
			"valueFromBaseUnitValue": {
				"!type": "fn(baseUnitValue: number) -> number"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitConverter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSPipe": {
		"pipe": {
			"!type": "fn() -> +NSPipe"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSPipe"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSPipe"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSPipe"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"fileHandleForReading": {
				"!type": "+NSFileHandle"
			},
			"fileHandleForWriting": {
				"!type": "+NSFileHandle"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSPipe"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMetadataSalientObject": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMetadataSalientObject"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMetadataSalientObject"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMetadataSalientObject"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"objectID": {
				"!type": "number"
			},
			"duration": {
				"!type": "+Object"
			},
			"type": {
				"!type": "string"
			},
			"bounds": {
				"!type": "+Object"
			},
			"time": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMetadataSalientObject"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVFragmentedAsset": {
		"fragmentedAssetWithURLOptions": {
			"!type": "fn(URL: +NSURL, options: +Object) -> +AVFragmentedAsset"
		},
		"URLAssetWithURLOptions": {
			"!type": "fn(URL: +NSURL, options: +Object) -> +AVFragmentedAsset"
		},
		"audiovisualMIMETypes": {
			"!type": "fn() -> +Array"
		},
		"isPlayableExtendedMIMEType": {
			"!type": "fn(extendedMIMEType: string) -> bool"
		},
		"audiovisualTypes": {
			"!type": "fn() -> +Array"
		},
		"assetWithURL": {
			"!type": "fn(URL: +NSURL) -> +AVFragmentedAsset"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVFragmentedAsset"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVFragmentedAsset"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVFragmentedAsset"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"tracks": {
				"!type": "+Array"
			},
			"URL": {
				"!type": "+NSURL"
			},
			"resourceLoader": {
				"!type": "+AVAssetResourceLoader"
			},
			"assetCache": {
				"!type": "+AVAssetCache"
			},
			"mayRequireContentKeysForMediaDataProcessing": {
				"!type": "bool"
			},
			"creationDate": {
				"!type": "+AVMetadataItem"
			},
			"referenceRestrictions": {
				"!type": "number"
			},
			"canContainFragments": {
				"!type": "bool"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"preferredRate": {
				"!type": "number"
			},
			"composable": {
				"!type": "bool"
			},
			"tracks": {
				"!type": "+Array"
			},
			"containsFragments": {
				"!type": "bool"
			},
			"availableMediaCharacteristicsWithMediaSelectionOptions": {
				"!type": "+Array"
			},
			"preferredMediaSelection": {
				"!type": "+AVMediaSelection"
			},
			"duration": {
				"!type": "+Object"
			},
			"providesPreciseDurationAndTiming": {
				"!type": "bool"
			},
			"compatibleWithAirPlayVideo": {
				"!type": "bool"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"exportable": {
				"!type": "bool"
			},
			"lyrics": {
				"!type": "string"
			},
			"trackGroups": {
				"!type": "+Array"
			},
			"compatibleWithSavedPhotosAlbum": {
				"!type": "bool"
			},
			"readable": {
				"!type": "bool"
			},
			"hasProtectedContent": {
				"!type": "bool"
			},
			"overallDurationHint": {
				"!type": "+Object"
			},
			"availableChapterLocales": {
				"!type": "+Array"
			},
			"minimumTimeOffsetFromLive": {
				"!type": "+Object"
			},
			"allMediaSelections": {
				"!type": "+Array"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVFragmentedAssetTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"compatibleTrackForCompositionTrack": {
				"!type": "fn(compositionTrack: +AVCompositionTrack) -> +AVAssetTrack"
			},
			"initWithURLOptions": {
				"!type": "fn(URL: +NSURL, options: +Object) -> +AVFragmentedAsset"
			},
			"unusedTrackID": {
				"!type": "fn() -> number"
			},
			"chapterMetadataGroupsWithTitleLocaleContainingItemsWithCommonKeys": {
				"!type": "fn(locale: +NSLocale, commonKeys: +Array) -> +Array"
			},
			"cancelLoading": {
				"!type": "fn() -> void"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVAssetTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"mediaSelectionGroupForMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +AVMediaSelectionGroup"
			},
			"chapterMetadataGroupsBestMatchingPreferredLanguages": {
				"!type": "fn(preferredLanguages: +Array) -> +Array"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVFragmentedAsset"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVComposition": {
		"assetWithURL": {
			"!type": "fn(URL: +NSURL) -> +AVComposition"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVComposition"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVComposition"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVComposition"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"URLAssetInitializationOptions": {
				"!type": "+Object"
			},
			"tracks": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"creationDate": {
				"!type": "+AVMetadataItem"
			},
			"referenceRestrictions": {
				"!type": "number"
			},
			"canContainFragments": {
				"!type": "bool"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"preferredRate": {
				"!type": "number"
			},
			"composable": {
				"!type": "bool"
			},
			"tracks": {
				"!type": "+Array"
			},
			"containsFragments": {
				"!type": "bool"
			},
			"availableMediaCharacteristicsWithMediaSelectionOptions": {
				"!type": "+Array"
			},
			"preferredMediaSelection": {
				"!type": "+AVMediaSelection"
			},
			"duration": {
				"!type": "+Object"
			},
			"providesPreciseDurationAndTiming": {
				"!type": "bool"
			},
			"compatibleWithAirPlayVideo": {
				"!type": "bool"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"exportable": {
				"!type": "bool"
			},
			"lyrics": {
				"!type": "string"
			},
			"trackGroups": {
				"!type": "+Array"
			},
			"compatibleWithSavedPhotosAlbum": {
				"!type": "bool"
			},
			"readable": {
				"!type": "bool"
			},
			"hasProtectedContent": {
				"!type": "bool"
			},
			"overallDurationHint": {
				"!type": "+Object"
			},
			"availableChapterLocales": {
				"!type": "+Array"
			},
			"minimumTimeOffsetFromLive": {
				"!type": "+Object"
			},
			"allMediaSelections": {
				"!type": "+Array"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVCompositionTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"unusedTrackID": {
				"!type": "fn() -> number"
			},
			"chapterMetadataGroupsWithTitleLocaleContainingItemsWithCommonKeys": {
				"!type": "fn(locale: +NSLocale, commonKeys: +Array) -> +Array"
			},
			"cancelLoading": {
				"!type": "fn() -> void"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVAssetTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"mediaSelectionGroupForMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +AVMediaSelectionGroup"
			},
			"chapterMetadataGroupsBestMatchingPreferredLanguages": {
				"!type": "fn(preferredLanguages: +Array) -> +Array"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVComposition"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerItem": {
		"playerItemWithAsset": {
			"!type": "fn(asset: +AVAsset) -> +AVPlayerItem"
		},
		"playerItemWithURL": {
			"!type": "fn(URL: +NSURL) -> +AVPlayerItem"
		},
		"playerItemWithAssetAutomaticallyLoadedAssetKeys": {
			"!type": "fn(asset: +AVAsset, automaticallyLoadedAssetKeys: +Array) -> +AVPlayerItem"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerItem"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerItem"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerItem"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"startsOnFirstEligibleVariant": {
				"!type": "bool"
			},
			"playbackBufferFull": {
				"!type": "bool"
			},
			"reversePlaybackEndTime": {
				"!type": "+Object"
			},
			"currentMediaSelection": {
				"!type": "+AVMediaSelection"
			},
			"preferredMaximumResolution": {
				"!type": "+Object"
			},
			"canStepForward": {
				"!type": "bool"
			},
			"mediaDataCollectors": {
				"!type": "+Array"
			},
			"forwardPlaybackEndTime": {
				"!type": "+Object"
			},
			"duration": {
				"!type": "+Object"
			},
			"seekingWaitsForVideoCompositionRendering": {
				"!type": "bool"
			},
			"timebase": {
				"!type": "+Object"
			},
			"canUseNetworkResourcesForLiveStreamingWhilePaused": {
				"!type": "bool"
			},
			"audioSpatializationAllowed": {
				"!type": "bool"
			},
			"videoApertureMode": {
				"!type": "string"
			},
			"customVideoCompositor": {
				"!type": "+Object"
			},
			"loadedTimeRanges": {
				"!type": "+Array"
			},
			"playbackBufferEmpty": {
				"!type": "bool"
			},
			"preferredPeakBitRate": {
				"!type": "number"
			},
			"asset": {
				"!type": "+AVAsset"
			},
			"outputs": {
				"!type": "+Array"
			},
			"textStyleRules": {
				"!type": "+Array"
			},
			"status": {
				"!type": "number"
			},
			"timedMetadata": {
				"!type": "+Array"
			},
			"configuredTimeOffsetFromLive": {
				"!type": "+Object"
			},
			"canPlaySlowReverse": {
				"!type": "bool"
			},
			"error": {
				"!type": "+NSError"
			},
			"automaticallyLoadedAssetKeys": {
				"!type": "+Array"
			},
			"canPlayFastForward": {
				"!type": "bool"
			},
			"tracks": {
				"!type": "+Array"
			},
			"audioMix": {
				"!type": "+AVAudioMix"
			},
			"allowedAudioSpatializationFormats": {
				"!type": "number"
			},
			"canStepBackward": {
				"!type": "bool"
			},
			"canPlayReverse": {
				"!type": "bool"
			},
			"appliesPerFrameHDRDisplayMetadata": {
				"!type": "bool"
			},
			"audioTimePitchAlgorithm": {
				"!type": "string"
			},
			"automaticallyPreservesTimeOffsetFromLive": {
				"!type": "bool"
			},
			"recommendedTimeOffsetFromLive": {
				"!type": "+Object"
			},
			"preferredForwardBufferDuration": {
				"!type": "number"
			},
			"canPlaySlowForward": {
				"!type": "bool"
			},
			"videoComposition": {
				"!type": "+AVVideoComposition"
			},
			"playbackLikelyToKeepUp": {
				"!type": "bool"
			},
			"seekableTimeRanges": {
				"!type": "+Array"
			},
			"presentationSize": {
				"!type": "+Object"
			},
			"canPlayFastReverse": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"accessLog": {
				"!type": "fn() -> +AVPlayerItemAccessLog"
			},
			"seekToDate": {
				"!type": "fn(date: +Date) -> bool"
			},
			"selectMediaOptionAutomaticallyInMediaSelectionGroup": {
				"!type": "fn(mediaSelectionGroup: +AVMediaSelectionGroup) -> void"
			},
			"errorLog": {
				"!type": "fn() -> +AVPlayerItemErrorLog"
			},
			"initWithAsset": {
				"!type": "fn(asset: +AVAsset) -> +AVPlayerItem"
			},
			"seekToTimeCompletionHandler": {
				"!type": "fn(time: +Object, completionHandler: +Function) -> void"
			},
			"currentDate": {
				"!type": "fn() -> +Date"
			},
			"removeOutput": {
				"!type": "fn(output: +AVPlayerItemOutput) -> void"
			},
			"seekToTimeToleranceBeforeToleranceAfterCompletionHandler": {
				"!type": "fn(time: +Object, toleranceBefore: +Object, toleranceAfter: +Object, completionHandler: +Function) -> void"
			},
			"seekToTimeToleranceBeforeToleranceAfter": {
				"!type": "fn(time: +Object, toleranceBefore: +Object, toleranceAfter: +Object) -> void"
			},
			"stepByCount": {
				"!type": "fn(stepCount: number) -> void"
			},
			"initWithAssetAutomaticallyLoadedAssetKeys": {
				"!type": "fn(asset: +AVAsset, automaticallyLoadedAssetKeys: +Array) -> +AVPlayerItem"
			},
			"seekToDateCompletionHandler": {
				"!type": "fn(date: +Date, completionHandler: +Function) -> bool"
			},
			"currentTime": {
				"!type": "fn() -> +Object"
			},
			"removeMediaDataCollector": {
				"!type": "fn(collector: +AVPlayerItemMediaDataCollector) -> void"
			},
			"initWithURL": {
				"!type": "fn(URL: +NSURL) -> +AVPlayerItem"
			},
			"addOutput": {
				"!type": "fn(output: +AVPlayerItemOutput) -> void"
			},
			"selectMediaOptionInMediaSelectionGroup": {
				"!type": "fn(mediaSelectionOption: +AVMediaSelectionOption, mediaSelectionGroup: +AVMediaSelectionGroup) -> void"
			},
			"addMediaDataCollector": {
				"!type": "fn(collector: +AVPlayerItemMediaDataCollector) -> void"
			},
			"selectedMediaOptionInMediaSelectionGroup": {
				"!type": "fn(mediaSelectionGroup: +AVMediaSelectionGroup) -> +AVMediaSelectionOption"
			},
			"cancelPendingSeeks": {
				"!type": "fn() -> void"
			},
			"seekToTime": {
				"!type": "fn(time: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerItem"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVSynchronizedLayer": {
		"synchronizedLayerWithPlayerItem": {
			"!type": "fn(playerItem: +AVPlayerItem) -> +AVSynchronizedLayer"
		},
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +AVSynchronizedLayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVSynchronizedLayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVSynchronizedLayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVSynchronizedLayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"playerItem": {
				"!type": "+AVPlayerItem"
			},
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVSynchronizedLayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +AVSynchronizedLayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +AVSynchronizedLayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +AVSynchronizedLayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVSynchronizedLayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMetadataItem": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMetadataItem"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMetadataItem"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMetadataItem"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"attributes": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"valuesForAttributes": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"valueForAttribute": {
				"!type": "fn(key: string) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMetadataItem"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSISO8601DateFormatter": {
		"stringFromDateTimeZoneFormatOptions": {
			"!type": "fn(date: +Date, timeZone: +NSTimeZone, formatOptions: number) -> string"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSISO8601DateFormatter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSISO8601DateFormatter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSISO8601DateFormatter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"formatOptions": {
				"!type": "number"
			},
			"timeZone": {
				"!type": "+NSTimeZone"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"dateFromString": {
				"!type": "fn(string: string) -> +Date"
			},
			"jsinit": {
				"!type": "fn() -> +NSISO8601DateFormatter"
			},
			"stringFromDate": {
				"!type": "fn(date: +Date) -> string"
			},
			"editingStringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription": {
				"!type": "fn(partialStringPtr: +Object, proposedSelRangePtr: +Object, origString: string, origSelRange: +Object, error: +Object) -> bool"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"attributedStringForObjectValueWithDefaultAttributes": {
				"!type": "fn(obj: +Object, attrs: +Object) -> +NSAttributedString"
			},
			"isPartialStringValidNewEditingStringErrorDescription": {
				"!type": "fn(partialString: string, newString: +Object, error: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSISO8601DateFormatter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureManualExposureBracketedStillImageSettings": {
		"manualExposureSettingsWithExposureDurationISO": {
			"!type": "fn(duration: +Object, ISO: number) -> +AVCaptureManualExposureBracketedStillImageSettings"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureManualExposureBracketedStillImageSettings"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureManualExposureBracketedStillImageSettings"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureManualExposureBracketedStillImageSettings"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"ISO": {
				"!type": "number"
			},
			"exposureDuration": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureManualExposureBracketedStillImageSettings"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioSequencer": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioSequencer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioSequencer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioSequencer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"currentPositionInBeats": {
				"!type": "number"
			},
			"tracks": {
				"!type": "+Array"
			},
			"tempoTrack": {
				"!type": "+AVMusicTrack"
			},
			"userInfo": {
				"!type": "+Object"
			},
			"currentPositionInSeconds": {
				"!type": "number"
			},
			"rate": {
				"!type": "number"
			},
			"playing": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithAudioEngine": {
				"!type": "fn(engine: +AVAudioEngine) -> +AVAudioSequencer"
			},
			"loadFromDataOptionsError": {
				"!type": "fn(data: +NSData, options: number, outError: +Object) -> bool"
			},
			"beatsForSeconds": {
				"!type": "fn(seconds: number) -> number"
			},
			"loadFromURLOptionsError": {
				"!type": "fn(fileURL: +NSURL, options: number, outError: +Object) -> bool"
			},
			"hostTimeForBeatsError": {
				"!type": "fn(inBeats: number, outError: +Object) -> number"
			},
			"stop": {
				"!type": "fn() -> void"
			},
			"prepareToPlay": {
				"!type": "fn() -> void"
			},
			"writeToURLSMPTEResolutionReplaceExistingError": {
				"!type": "fn(fileURL: +NSURL, resolution: number, replace: bool, outError: +Object) -> bool"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioSequencer"
			},
			"beatsForHostTimeError": {
				"!type": "fn(inHostTime: number, outError: +Object) -> number"
			},
			"secondsForBeats": {
				"!type": "fn(beats: number) -> number"
			},
			"startAndReturnError": {
				"!type": "fn(outError: +Object) -> bool"
			},
			"dataWithSMPTEResolutionError": {
				"!type": "fn(SMPTEResolution: number, outError: +Object) -> +NSData"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioSequencer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetWriterInput": {
		"assetWriterInputWithMediaTypeOutputSettings": {
			"!type": "fn(mediaType: string, outputSettings: +Object) -> +AVAssetWriterInput"
		},
		"assetWriterInputWithMediaTypeOutputSettingsSourceFormatHint": {
			"!type": "fn(mediaType: string, outputSettings: +Object, sourceFormatHint: +Object) -> +AVAssetWriterInput"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetWriterInput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetWriterInput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetWriterInput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"languageCode": {
				"!type": "string"
			},
			"performsMultiPassEncodingIfSupported": {
				"!type": "bool"
			},
			"preferredMediaChunkAlignment": {
				"!type": "number"
			},
			"marksOutputTrackAsEnabled": {
				"!type": "bool"
			},
			"currentPassDescription": {
				"!type": "+AVAssetWriterInputPassDescription"
			},
			"expectsMediaDataInRealTime": {
				"!type": "bool"
			},
			"extendedLanguageTag": {
				"!type": "string"
			},
			"mediaType": {
				"!type": "string"
			},
			"outputSettings": {
				"!type": "+Object"
			},
			"transform": {
				"!type": "+Object"
			},
			"mediaTimeScale": {
				"!type": "number"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"sourceFormatHint": {
				"!type": "+Object"
			},
			"canPerformMultiplePasses": {
				"!type": "bool"
			},
			"sampleReferenceBaseURL": {
				"!type": "+NSURL"
			},
			"mediaDataLocation": {
				"!type": "string"
			},
			"readyForMoreMediaData": {
				"!type": "bool"
			},
			"preferredMediaChunkDuration": {
				"!type": "+Object"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"markAsFinished": {
				"!type": "fn() -> void"
			},
			"initWithMediaTypeOutputSettings": {
				"!type": "fn(mediaType: string, outputSettings: +Object) -> +AVAssetWriterInput"
			},
			"respondToEachPassDescriptionOnQueueUsingBlock": {
				"!type": "fn(queue: +Object, block: +Function) -> void"
			},
			"addTrackAssociationWithTrackOfInputType": {
				"!type": "fn(input: +AVAssetWriterInput, trackAssociationType: string) -> void"
			},
			"appendSampleBuffer": {
				"!type": "fn(sampleBuffer: +Object) -> bool"
			},
			"canAddTrackAssociationWithTrackOfInputType": {
				"!type": "fn(input: +AVAssetWriterInput, trackAssociationType: string) -> bool"
			},
			"initWithMediaTypeOutputSettingsSourceFormatHint": {
				"!type": "fn(mediaType: string, outputSettings: +Object, sourceFormatHint: +Object) -> +AVAssetWriterInput"
			},
			"requestMediaDataWhenReadyOnQueueUsingBlock": {
				"!type": "fn(queue: +Object, block: +Function) -> void"
			},
			"markCurrentPassAsFinished": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetWriterInput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSHTTPCookie": {
		"cookieWithProperties": {
			"!type": "fn(properties: +Object) -> +NSHTTPCookie"
		},
		"requestHeaderFieldsWithCookies": {
			"!type": "fn(cookies: +Array) -> +Object"
		},
		"cookiesWithResponseHeaderFieldsForURL": {
			"!type": "fn(headerFields: +Object, URL: +NSURL) -> +Array"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSHTTPCookie"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSHTTPCookie"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSHTTPCookie"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"comment": {
				"!type": "string"
			},
			"domain": {
				"!type": "string"
			},
			"sameSitePolicy": {
				"!type": "string"
			},
			"name": {
				"!type": "string"
			},
			"sessionOnly": {
				"!type": "bool"
			},
			"expiresDate": {
				"!type": "+Date"
			},
			"value": {
				"!type": "string"
			},
			"commentURL": {
				"!type": "+NSURL"
			},
			"version": {
				"!type": "number"
			},
			"portList": {
				"!type": "+Array"
			},
			"path": {
				"!type": "string"
			},
			"properties": {
				"!type": "+Object"
			},
			"HTTPOnly": {
				"!type": "bool"
			},
			"secure": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithProperties": {
				"!type": "fn(properties: +Object) -> +NSHTTPCookie"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSHTTPCookie"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLResponse": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLResponse"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLResponse"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLResponse"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"URL": {
				"!type": "+NSURL"
			},
			"MIMEType": {
				"!type": "string"
			},
			"expectedContentLength": {
				"!type": "number"
			},
			"suggestedFilename": {
				"!type": "string"
			},
			"textEncodingName": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithURLMIMETypeExpectedContentLengthTextEncodingName": {
				"!type": "fn(URL: +NSURL, MIMEType: string, length: number, name: string) -> +NSURLResponse"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLResponse"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSOrthography": {
		"orthographyWithDominantScriptLanguageMap": {
			"!type": "fn(script: string, map: +Object) -> +NSOrthography"
		},
		"defaultOrthographyForLanguage": {
			"!type": "fn(language: string) -> +NSOrthography"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSOrthography"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSOrthography"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSOrthography"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"allScripts": {
				"!type": "+Array"
			},
			"dominantLanguage": {
				"!type": "string"
			},
			"dominantScript": {
				"!type": "string"
			},
			"allLanguages": {
				"!type": "+Array"
			},
			"languageMap": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"languagesForScript": {
				"!type": "fn(script: string) -> +Array"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSOrthography"
			},
			"initWithDominantScriptLanguageMap": {
				"!type": "fn(script: string, map: +Object) -> +NSOrthography"
			},
			"dominantLanguageForScript": {
				"!type": "fn(script: string) -> string"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSOrthography"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLSessionUploadTask": {
		"jsnew": {
			"!type": "fn() -> +NSURLSessionUploadTask"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionUploadTask"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionUploadTask"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLSessionUploadTask"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLSessionUploadTask"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionUploadTask"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"countOfBytesSent": {
				"!type": "number"
			},
			"earliestBeginDate": {
				"!type": "+Date"
			},
			"countOfBytesExpectedToReceive": {
				"!type": "number"
			},
			"taskDescription": {
				"!type": "string"
			},
			"countOfBytesExpectedToSend": {
				"!type": "number"
			},
			"state": {
				"!type": "number"
			},
			"priority": {
				"!type": "number"
			},
			"countOfBytesClientExpectsToSend": {
				"!type": "number"
			},
			"taskIdentifier": {
				"!type": "number"
			},
			"countOfBytesReceived": {
				"!type": "number"
			},
			"error": {
				"!type": "+NSError"
			},
			"currentRequest": {
				"!type": "+NSURLRequest"
			},
			"progress": {
				"!type": "+NSProgress"
			},
			"countOfBytesClientExpectsToReceive": {
				"!type": "number"
			},
			"response": {
				"!type": "+NSURLResponse"
			},
			"originalRequest": {
				"!type": "+NSURLRequest"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionUploadTask"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionUploadTask"
			},
			"suspend": {
				"!type": "fn() -> void"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"resume": {
				"!type": "fn() -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionUploadTask"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionUploadTask"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioSinkNode": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioSinkNode"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioSinkNode"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioSinkNode"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithReceiverBlock": {
				"!type": "fn(block: +Function) -> +AVAudioSinkNode"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioSinkNode"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSCharacterSet": {
		"URLHostAllowedCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"URLFragmentAllowedCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"letterCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"nonBaseCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"characterSetWithCharactersInString": {
			"!type": "fn(aString: string) -> +NSCharacterSet"
		},
		"punctuationCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"symbolCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"capitalizedLetterCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"characterSetWithContentsOfFile": {
			"!type": "fn(fName: string) -> +NSCharacterSet"
		},
		"illegalCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"URLUserAllowedCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"decomposableCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"newlineCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"whitespaceAndNewlineCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"alphanumericCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"URLPathAllowedCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"uppercaseLetterCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"URLPasswordAllowedCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"whitespaceCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"lowercaseLetterCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"characterSetWithBitmapRepresentation": {
			"!type": "fn(data: +NSData) -> +NSCharacterSet"
		},
		"controlCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"characterSetWithRange": {
			"!type": "fn(aRange: +Object) -> +NSCharacterSet"
		},
		"URLQueryAllowedCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"decimalDigitCharacterSet": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSCharacterSet"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSCharacterSet"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"invertedSet": {
				"!type": "+NSCharacterSet"
			},
			"bitmapRepresentation": {
				"!type": "+NSData"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"isSupersetOfSet": {
				"!type": "fn(theOtherSet: +NSCharacterSet) -> bool"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSCharacterSet"
			},
			"characterIsMember": {
				"!type": "fn(aCharacter: number) -> bool"
			},
			"longCharacterIsMember": {
				"!type": "fn(theLongChar: number) -> bool"
			},
			"hasMemberInPlane": {
				"!type": "fn(thePlane: number) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSCharacterSet"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetReaderOutput": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetReaderOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetReaderOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetReaderOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"alwaysCopiesSampleData": {
				"!type": "bool"
			},
			"mediaType": {
				"!type": "string"
			},
			"supportsRandomAccess": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"copyNextSampleBuffer": {
				"!type": "fn() -> +Object"
			},
			"resetForReadingTimeRanges": {
				"!type": "fn(timeRanges: +Array) -> void"
			},
			"markConfigurationAsFinal": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetReaderOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetTrack": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetTrack"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetTrack"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetTrack"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"languageCode": {
				"!type": "string"
			},
			"minFrameDuration": {
				"!type": "+Object"
			},
			"formatDescriptions": {
				"!type": "+Array"
			},
			"availableTrackAssociationTypes": {
				"!type": "+Array"
			},
			"nominalFrameRate": {
				"!type": "number"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"estimatedDataRate": {
				"!type": "number"
			},
			"naturalTimeScale": {
				"!type": "number"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"requiresFrameReordering": {
				"!type": "bool"
			},
			"hasAudioSampleDependencies": {
				"!type": "bool"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"selfContained": {
				"!type": "bool"
			},
			"segments": {
				"!type": "+Array"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"extendedLanguageTag": {
				"!type": "string"
			},
			"mediaType": {
				"!type": "string"
			},
			"asset": {
				"!type": "+AVAsset"
			},
			"trackID": {
				"!type": "number"
			},
			"totalSampleDataLength": {
				"!type": "number"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"decodable": {
				"!type": "bool"
			},
			"enabled": {
				"!type": "bool"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hasMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> bool"
			},
			"samplePresentationTimeForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +Object"
			},
			"associatedTracksOfType": {
				"!type": "fn(trackAssociationType: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"segmentForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +AVAssetTrackSegment"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetTrack"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureDeviceInput": {
		"deviceInputWithDeviceError": {
			"!type": "fn(device: +AVCaptureDevice, outError: +Object) -> +AVCaptureDeviceInput"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureDeviceInput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureDeviceInput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureDeviceInput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"device": {
				"!type": "+AVCaptureDevice"
			},
			"videoMinFrameDurationOverride": {
				"!type": "+Object"
			},
			"unifiedAutoExposureDefaultsEnabled": {
				"!type": "bool"
			},
			"ports": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithDeviceError": {
				"!type": "fn(device: +AVCaptureDevice, outError: +Object) -> +AVCaptureDeviceInput"
			},
			"portsWithMediaTypeSourceDeviceTypeSourceDevicePosition": {
				"!type": "fn(mediaType: string, sourceDeviceType: string, sourceDevicePosition: number) -> +Array"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureDeviceInput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVVideoCompositionCoreAnimationTool": {
		"videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayerInLayer": {
			"!type": "fn(videoLayer: +CALayer, animationLayer: +CALayer) -> +AVVideoCompositionCoreAnimationTool"
		},
		"videoCompositionCoreAnimationToolWithAdditionalLayerAsTrackID": {
			"!type": "fn(layer: +CALayer, trackID: number) -> +AVVideoCompositionCoreAnimationTool"
		},
		"videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayersInLayer": {
			"!type": "fn(videoLayers: +Array, animationLayer: +CALayer) -> +AVVideoCompositionCoreAnimationTool"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVVideoCompositionCoreAnimationTool"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVVideoCompositionCoreAnimationTool"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVVideoCompositionCoreAnimationTool"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVVideoCompositionCoreAnimationTool"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CAScrollLayer": {
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +CAScrollLayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CAScrollLayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CAScrollLayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CAScrollLayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"scrollMode": {
				"!type": "string"
			},
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"scrollToRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"scrollToPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAScrollLayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +CAScrollLayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +CAScrollLayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +CAScrollLayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAScrollLayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerItemOutput": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerItemOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerItemOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerItemOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"suppressesPlayerRendering": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"itemTimeForHostTime": {
				"!type": "fn(hostTimeInSeconds: number) -> +Object"
			},
			"itemTimeForMachAbsoluteTime": {
				"!type": "fn(machAbsoluteTime: number) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerItemOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAsynchronousVideoCompositionRequest": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAsynchronousVideoCompositionRequest"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAsynchronousVideoCompositionRequest"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAsynchronousVideoCompositionRequest"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"videoCompositionInstruction": {
				"!type": "+Object"
			},
			"sourceTrackIDs": {
				"!type": "+Array"
			},
			"renderContext": {
				"!type": "+AVVideoCompositionRenderContext"
			},
			"compositionTime": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"sourceFrameByTrackID": {
				"!type": "fn(trackID: number) -> +Object"
			},
			"finishWithComposedVideoFrame": {
				"!type": "fn(composedVideoFrame: +Object) -> void"
			},
			"finishCancelledRequest": {
				"!type": "fn() -> void"
			},
			"finishWithError": {
				"!type": "fn(error: +NSError) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAsynchronousVideoCompositionRequest"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitElectricCurrent": {
		"amperes": {
			"!type": "fn() -> +NSUnitElectricCurrent"
		},
		"kiloamperes": {
			"!type": "fn() -> +NSUnitElectricCurrent"
		},
		"milliamperes": {
			"!type": "fn() -> +NSUnitElectricCurrent"
		},
		"megaamperes": {
			"!type": "fn() -> +NSUnitElectricCurrent"
		},
		"microamperes": {
			"!type": "fn() -> +NSUnitElectricCurrent"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitElectricCurrent"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitElectricCurrent"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitElectricCurrent"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitElectricCurrent"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitElectricCurrent"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitElectricCurrent"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitElectricCurrent"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CAGradientLayer": {
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +CAGradientLayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CAGradientLayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CAGradientLayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CAGradientLayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"type": {
				"!type": "string"
			},
			"colors": {
				"!type": "+Array"
			},
			"endPoint": {
				"!type": "+Object"
			},
			"startPoint": {
				"!type": "+Object"
			},
			"locations": {
				"!type": "+Array"
			},
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAGradientLayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +CAGradientLayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +CAGradientLayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +CAGradientLayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAGradientLayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSFormatter": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSFormatter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSFormatter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSFormatter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"editingStringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription": {
				"!type": "fn(partialStringPtr: +Object, proposedSelRangePtr: +Object, origString: string, origSelRange: +Object, error: +Object) -> bool"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"attributedStringForObjectValueWithDefaultAttributes": {
				"!type": "fn(obj: +Object, attrs: +Object) -> +NSAttributedString"
			},
			"isPartialStringValidNewEditingStringErrorDescription": {
				"!type": "fn(partialString: string, newString: +Object, error: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSFormatter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSXPCListenerEndpoint": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSXPCListenerEndpoint"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSXPCListenerEndpoint"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSXPCListenerEndpoint"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSXPCListenerEndpoint"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLSessionTask": {
		"jsnew": {
			"!type": "fn() -> +NSURLSessionTask"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLSessionTask"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLSessionTask"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionTask"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"countOfBytesSent": {
				"!type": "number"
			},
			"earliestBeginDate": {
				"!type": "+Date"
			},
			"countOfBytesExpectedToReceive": {
				"!type": "number"
			},
			"taskDescription": {
				"!type": "string"
			},
			"countOfBytesExpectedToSend": {
				"!type": "number"
			},
			"state": {
				"!type": "number"
			},
			"priority": {
				"!type": "number"
			},
			"countOfBytesClientExpectsToSend": {
				"!type": "number"
			},
			"taskIdentifier": {
				"!type": "number"
			},
			"countOfBytesReceived": {
				"!type": "number"
			},
			"error": {
				"!type": "+NSError"
			},
			"currentRequest": {
				"!type": "+NSURLRequest"
			},
			"progress": {
				"!type": "+NSProgress"
			},
			"countOfBytesClientExpectsToReceive": {
				"!type": "number"
			},
			"response": {
				"!type": "+NSURLResponse"
			},
			"originalRequest": {
				"!type": "+NSURLRequest"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"suspend": {
				"!type": "fn() -> void"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"resume": {
				"!type": "fn() -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionTask"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionTask"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnit": {
		"instantiateWithComponentDescriptionOptionsCompletionHandler": {
			"!type": "fn(audioComponentDescription: +Object, options: number, completionHandler: +Function) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnit"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnit"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnit"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"name": {
				"!type": "string"
			},
			"audioComponentDescription": {
				"!type": "+Object"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"version": {
				"!type": "number"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"loadAudioUnitPresetAtURLError": {
				"!type": "fn(url: +NSURL, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnit"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMutableAttributedString": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMutableAttributedString"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMutableAttributedString"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMutableAttributedString"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"mutableString": {
				"!type": "+NSMutableString"
			},
			"length": {
				"!type": "number"
			},
			"string": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setAttributedString": {
				"!type": "fn(attrString: +NSAttributedString) -> void"
			},
			"replaceCharactersInRangeWithString": {
				"!type": "fn(range: +Object, str: string) -> void"
			},
			"replaceCharactersInRangeWithAttributedString": {
				"!type": "fn(range: +Object, attrString: +NSAttributedString) -> void"
			},
			"insertAttributedStringAtIndex": {
				"!type": "fn(attrString: +NSAttributedString, loc: number) -> void"
			},
			"beginEditing": {
				"!type": "fn() -> void"
			},
			"addAttributeValueRange": {
				"!type": "fn(name: string, value: +Object, range: +Object) -> void"
			},
			"endEditing": {
				"!type": "fn() -> void"
			},
			"appendAttributedString": {
				"!type": "fn(attrString: +NSAttributedString) -> void"
			},
			"addAttributesRange": {
				"!type": "fn(attrs: +Object, range: +Object) -> void"
			},
			"setAttributesRange": {
				"!type": "fn(attrs: +Object, range: +Object) -> void"
			},
			"removeAttributeRange": {
				"!type": "fn(name: string, range: +Object) -> void"
			},
			"deleteCharactersInRange": {
				"!type": "fn(range: +Object) -> void"
			},
			"attributeAtIndexEffectiveRange": {
				"!type": "fn(attrName: string, location: number, range: +Object) -> +Object"
			},
			"initWithAttributedString": {
				"!type": "fn(attrStr: +NSAttributedString) -> +NSMutableAttributedString"
			},
			"initWithStringAttributes": {
				"!type": "fn(str: string, attrs: +Object) -> +NSMutableAttributedString"
			},
			"enumerateAttributeInRangeOptionsUsingBlock": {
				"!type": "fn(attrName: string, enumerationRange: +Object, opts: number, block: +Function) -> void"
			},
			"attributesAtIndexLongestEffectiveRangeInRange": {
				"!type": "fn(location: number, range: +Object, rangeLimit: +Object) -> +Object"
			},
			"attributesAtIndexEffectiveRange": {
				"!type": "fn(location: number, range: +Object) -> +Object"
			},
			"attributeAtIndexLongestEffectiveRangeInRange": {
				"!type": "fn(attrName: string, location: number, range: +Object, rangeLimit: +Object) -> +Object"
			},
			"isEqualToAttributedString": {
				"!type": "fn(other: +NSAttributedString) -> bool"
			},
			"enumerateAttributesInRangeOptionsUsingBlock": {
				"!type": "fn(enumerationRange: +Object, opts: number, block: +Function) -> void"
			},
			"initWithString": {
				"!type": "fn(str: string) -> +NSMutableAttributedString"
			},
			"attributedSubstringFromRange": {
				"!type": "fn(range: +Object) -> +NSAttributedString"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableAttributedString"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMediaDataStorage": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMediaDataStorage"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMediaDataStorage"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMediaDataStorage"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"URL": {
				"!type": "fn() -> +NSURL"
			},
			"initWithURLOptions": {
				"!type": "fn(URL: +NSURL, options: +Object) -> +AVMediaDataStorage"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMediaDataStorage"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitArea": {
		"squareKilometers": {
			"!type": "fn() -> +NSUnitArea"
		},
		"squareNanometers": {
			"!type": "fn() -> +NSUnitArea"
		},
		"squareFeet": {
			"!type": "fn() -> +NSUnitArea"
		},
		"squareMillimeters": {
			"!type": "fn() -> +NSUnitArea"
		},
		"squareMiles": {
			"!type": "fn() -> +NSUnitArea"
		},
		"squareYards": {
			"!type": "fn() -> +NSUnitArea"
		},
		"acres": {
			"!type": "fn() -> +NSUnitArea"
		},
		"squareMicrometers": {
			"!type": "fn() -> +NSUnitArea"
		},
		"hectares": {
			"!type": "fn() -> +NSUnitArea"
		},
		"squareMeters": {
			"!type": "fn() -> +NSUnitArea"
		},
		"squareMegameters": {
			"!type": "fn() -> +NSUnitArea"
		},
		"squareInches": {
			"!type": "fn() -> +NSUnitArea"
		},
		"squareCentimeters": {
			"!type": "fn() -> +NSUnitArea"
		},
		"ares": {
			"!type": "fn() -> +NSUnitArea"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitArea"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitArea"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitArea"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitArea"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitArea"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitArea"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitArea"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CATextLayer": {
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +CATextLayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CATextLayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CATextLayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CATextLayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"foregroundColor": {
				"!type": "+Object"
			},
			"string": {
				"!type": "+Object"
			},
			"truncationMode": {
				"!type": "string"
			},
			"alignmentMode": {
				"!type": "string"
			},
			"fontSize": {
				"!type": "number"
			},
			"wrapped": {
				"!type": "bool"
			},
			"font": {
				"!type": "+Object"
			},
			"allowsFontSubpixelQuantization": {
				"!type": "bool"
			},
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CATextLayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +CATextLayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +CATextLayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +CATextLayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CATextLayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSNotificationQueue": {
		"defaultQueue": {
			"!type": "fn() -> +NSNotificationQueue"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSNotificationQueue"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSNotificationQueue"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSNotificationQueue"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"enqueueNotificationPostingStyleCoalesceMaskForModes": {
				"!type": "fn(notification: +NSNotification, postingStyle: number, coalesceMask: number, modes: +Array) -> void"
			},
			"initWithNotificationCenter": {
				"!type": "fn(notificationCenter: +NSNotificationCenter) -> +NSNotificationQueue"
			},
			"dequeueNotificationsMatchingCoalesceMask": {
				"!type": "fn(notification: +NSNotification, coalesceMask: number) -> void"
			},
			"enqueueNotificationPostingStyle": {
				"!type": "fn(notification: +NSNotification, postingStyle: number) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSNotificationQueue"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSValue": {
		"valueWithPointer": {
			"!type": "fn(pointer: +Object) -> +NSValue"
		},
		"valueWithBytesObjCType": {
			"!type": "fn(value: +Object, type: +Object) -> +NSValue"
		},
		"valueWithCMTimeRange": {
			"!type": "fn(timeRange: +Object) -> +NSValue"
		},
		"valueWithCMTime": {
			"!type": "fn(time: +Object) -> +NSValue"
		},
		"valueWithRange": {
			"!type": "fn(range: +Object) -> +NSValue"
		},
		"valueWithObjCType": {
			"!type": "fn(value: +Object, type: +Object) -> +NSValue"
		},
		"valueWithCMTimeMapping": {
			"!type": "fn(timeMapping: +Object) -> +NSValue"
		},
		"valueWithCATransform3D": {
			"!type": "fn(t: +Object) -> +NSValue"
		},
		"valueWithNonretainedObject": {
			"!type": "fn(anObject: +Object) -> +NSValue"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSValue"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSValue"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSValue"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"CMTimeRangeValue": {
				"!type": "+Object"
			},
			"rangeValue": {
				"!type": "+Object"
			},
			"CMTimeValue": {
				"!type": "+Object"
			},
			"CATransform3DValue": {
				"!type": "+Object"
			},
			"CMTimeMappingValue": {
				"!type": "+Object"
			},
			"nonretainedObjectValue": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"getValueSize": {
				"!type": "fn(value: +Object, size: number) -> void"
			},
			"isEqualToValue": {
				"!type": "fn(value: +NSValue) -> bool"
			},
			"getValue": {
				"!type": "fn(value: +Object) -> void"
			},
			"initWithBytesObjCType": {
				"!type": "fn(value: +Object, type: +Object) -> +NSValue"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSValue"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSValue"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMutableIndexSet": {
		"indexSetWithIndex": {
			"!type": "fn(value: number) -> +NSMutableIndexSet"
		},
		"indexSetWithIndexesInRange": {
			"!type": "fn(range: +Object) -> +NSMutableIndexSet"
		},
		"indexSet": {
			"!type": "fn() -> +NSMutableIndexSet"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMutableIndexSet"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMutableIndexSet"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMutableIndexSet"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"firstIndex": {
				"!type": "number"
			},
			"lastIndex": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"removeIndexes": {
				"!type": "fn(indexSet: +NSIndexSet) -> void"
			},
			"removeIndexesInRange": {
				"!type": "fn(range: +Object) -> void"
			},
			"removeAllIndexes": {
				"!type": "fn() -> void"
			},
			"removeIndex": {
				"!type": "fn(value: number) -> void"
			},
			"addIndexesInRange": {
				"!type": "fn(range: +Object) -> void"
			},
			"addIndexes": {
				"!type": "fn(indexSet: +NSIndexSet) -> void"
			},
			"addIndex": {
				"!type": "fn(value: number) -> void"
			},
			"shiftIndexesStartingAtIndexBy": {
				"!type": "fn(index: number, delta: number) -> void"
			},
			"getIndexesMaxCountInIndexRange": {
				"!type": "fn(indexBuffer: +Object, bufferSize: number, range: +Object) -> number"
			},
			"indexPassingTest": {
				"!type": "fn(predicate: +Function) -> number"
			},
			"intersectsIndexesInRange": {
				"!type": "fn(range: +Object) -> bool"
			},
			"enumerateIndexesWithOptionsUsingBlock": {
				"!type": "fn(opts: number, block: +Function) -> void"
			},
			"enumerateRangesInRangeOptionsUsingBlock": {
				"!type": "fn(range: +Object, opts: number, block: +Function) -> void"
			},
			"containsIndex": {
				"!type": "fn(value: number) -> bool"
			},
			"enumerateIndexesInRangeOptionsUsingBlock": {
				"!type": "fn(range: +Object, opts: number, block: +Function) -> void"
			},
			"indexInRangeOptionsPassingTest": {
				"!type": "fn(range: +Object, opts: number, predicate: +Function) -> number"
			},
			"enumerateIndexesUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"initWithIndexesInRange": {
				"!type": "fn(range: +Object) -> +NSMutableIndexSet"
			},
			"indexesWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> +NSIndexSet"
			},
			"containsIndexes": {
				"!type": "fn(indexSet: +NSIndexSet) -> bool"
			},
			"indexGreaterThanOrEqualToIndex": {
				"!type": "fn(value: number) -> number"
			},
			"initWithIndex": {
				"!type": "fn(value: number) -> +NSMutableIndexSet"
			},
			"enumerateRangesWithOptionsUsingBlock": {
				"!type": "fn(opts: number, block: +Function) -> void"
			},
			"indexGreaterThanIndex": {
				"!type": "fn(value: number) -> number"
			},
			"indexesInRangeOptionsPassingTest": {
				"!type": "fn(range: +Object, opts: number, predicate: +Function) -> +NSIndexSet"
			},
			"isEqualToIndexSet": {
				"!type": "fn(indexSet: +NSIndexSet) -> bool"
			},
			"enumerateRangesUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"indexWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> number"
			},
			"containsIndexesInRange": {
				"!type": "fn(range: +Object) -> bool"
			},
			"countOfIndexesInRange": {
				"!type": "fn(range: +Object) -> number"
			},
			"indexLessThanIndex": {
				"!type": "fn(value: number) -> number"
			},
			"indexesPassingTest": {
				"!type": "fn(predicate: +Function) -> +NSIndexSet"
			},
			"initWithIndexSet": {
				"!type": "fn(indexSet: +NSIndexSet) -> +NSMutableIndexSet"
			},
			"indexLessThanOrEqualToIndex": {
				"!type": "fn(value: number) -> number"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableIndexSet"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVFragmentedAssetMinder": {
		"fragmentedAssetMinderWithAssetMindingInterval": {
			"!type": "fn(asset: +AVAsset, mindingInterval: number) -> +AVFragmentedAssetMinder"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVFragmentedAssetMinder"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVFragmentedAssetMinder"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVFragmentedAssetMinder"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"mindingInterval": {
				"!type": "number"
			},
			"assets": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"removeFragmentedAsset": {
				"!type": "fn(asset: +AVAsset) -> void"
			},
			"initWithAssetMindingInterval": {
				"!type": "fn(asset: +AVAsset, mindingInterval: number) -> +AVFragmentedAssetMinder"
			},
			"addFragmentedAsset": {
				"!type": "fn(asset: +AVAsset) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVFragmentedAssetMinder"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLSessionTaskTransactionMetrics": {
		"jsnew": {
			"!type": "fn() -> +NSURLSessionTaskTransactionMetrics"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLSessionTaskTransactionMetrics"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLSessionTaskTransactionMetrics"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionTaskTransactionMetrics"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"multipath": {
				"!type": "bool"
			},
			"remotePort": {
				"!type": "number"
			},
			"responseStartDate": {
				"!type": "+Date"
			},
			"localPort": {
				"!type": "number"
			},
			"connectStartDate": {
				"!type": "+Date"
			},
			"connectEndDate": {
				"!type": "+Date"
			},
			"responseEndDate": {
				"!type": "+Date"
			},
			"localAddress": {
				"!type": "string"
			},
			"countOfRequestBodyBytesBeforeEncoding": {
				"!type": "number"
			},
			"expensive": {
				"!type": "bool"
			},
			"constrained": {
				"!type": "bool"
			},
			"remoteAddress": {
				"!type": "string"
			},
			"countOfRequestBodyBytesSent": {
				"!type": "number"
			},
			"requestStartDate": {
				"!type": "+Date"
			},
			"domainLookupStartDate": {
				"!type": "+Date"
			},
			"domainResolutionProtocol": {
				"!type": "number"
			},
			"reusedConnection": {
				"!type": "bool"
			},
			"countOfResponseBodyBytesReceived": {
				"!type": "number"
			},
			"countOfRequestHeaderBytesSent": {
				"!type": "number"
			},
			"proxyConnection": {
				"!type": "bool"
			},
			"domainLookupEndDate": {
				"!type": "+Date"
			},
			"resourceFetchType": {
				"!type": "number"
			},
			"negotiatedTLSCipherSuite": {
				"!type": "number"
			},
			"cellular": {
				"!type": "bool"
			},
			"secureConnectionEndDate": {
				"!type": "+Date"
			},
			"countOfResponseBodyBytesAfterDecoding": {
				"!type": "number"
			},
			"requestEndDate": {
				"!type": "+Date"
			},
			"request": {
				"!type": "+NSURLRequest"
			},
			"secureConnectionStartDate": {
				"!type": "+Date"
			},
			"fetchStartDate": {
				"!type": "+Date"
			},
			"negotiatedTLSProtocolVersion": {
				"!type": "number"
			},
			"response": {
				"!type": "+NSURLResponse"
			},
			"networkProtocolName": {
				"!type": "string"
			},
			"countOfResponseHeaderBytesReceived": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionTaskTransactionMetrics"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionTaskTransactionMetrics"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetDownloadStorageManager": {
		"sharedDownloadStorageManager": {
			"!type": "fn() -> +AVAssetDownloadStorageManager"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetDownloadStorageManager"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetDownloadStorageManager"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetDownloadStorageManager"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"storageManagementPolicyForURL": {
				"!type": "fn(downloadStorageURL: +NSURL) -> +AVAssetDownloadStorageManagementPolicy"
			},
			"setStorageManagementPolicyForURL": {
				"!type": "fn(storageManagementPolicy: +AVAssetDownloadStorageManagementPolicy, downloadStorageURL: +NSURL) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetDownloadStorageManager"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSTextCheckingResult": {
		"transitInformationCheckingResultWithRangeComponents": {
			"!type": "fn(range: +Object, components: +Object) -> +NSTextCheckingResult"
		},
		"orthographyCheckingResultWithRangeOrthography": {
			"!type": "fn(range: +Object, orthography: +NSOrthography) -> +NSTextCheckingResult"
		},
		"addressCheckingResultWithRangeComponents": {
			"!type": "fn(range: +Object, components: +Object) -> +NSTextCheckingResult"
		},
		"dashCheckingResultWithRangeReplacementString": {
			"!type": "fn(range: +Object, replacementString: string) -> +NSTextCheckingResult"
		},
		"regularExpressionCheckingResultWithRangesCountRegularExpression": {
			"!type": "fn(ranges: +Object, count: number, regularExpression: +NSRegularExpression) -> +NSTextCheckingResult"
		},
		"correctionCheckingResultWithRangeReplacementString": {
			"!type": "fn(range: +Object, replacementString: string) -> +NSTextCheckingResult"
		},
		"correctionCheckingResultWithRangeReplacementStringAlternativeStrings": {
			"!type": "fn(range: +Object, replacementString: string, alternativeStrings: +Array) -> +NSTextCheckingResult"
		},
		"dateCheckingResultWithRangeDateTimeZoneDuration": {
			"!type": "fn(range: +Object, date: +Date, timeZone: +NSTimeZone, duration: number) -> +NSTextCheckingResult"
		},
		"grammarCheckingResultWithRangeDetails": {
			"!type": "fn(range: +Object, details: +Array) -> +NSTextCheckingResult"
		},
		"phoneNumberCheckingResultWithRangePhoneNumber": {
			"!type": "fn(range: +Object, phoneNumber: string) -> +NSTextCheckingResult"
		},
		"spellCheckingResultWithRange": {
			"!type": "fn(range: +Object) -> +NSTextCheckingResult"
		},
		"linkCheckingResultWithRangeURL": {
			"!type": "fn(range: +Object, url: +NSURL) -> +NSTextCheckingResult"
		},
		"quoteCheckingResultWithRangeReplacementString": {
			"!type": "fn(range: +Object, replacementString: string) -> +NSTextCheckingResult"
		},
		"replacementCheckingResultWithRangeReplacementString": {
			"!type": "fn(range: +Object, replacementString: string) -> +NSTextCheckingResult"
		},
		"dateCheckingResultWithRangeDate": {
			"!type": "fn(range: +Object, date: +Date) -> +NSTextCheckingResult"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSTextCheckingResult"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSTextCheckingResult"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSTextCheckingResult"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"numberOfRanges": {
				"!type": "number"
			},
			"grammarDetails": {
				"!type": "+Array"
			},
			"orthography": {
				"!type": "+NSOrthography"
			},
			"regularExpression": {
				"!type": "+NSRegularExpression"
			},
			"URL": {
				"!type": "+NSURL"
			},
			"replacementString": {
				"!type": "string"
			},
			"addressComponents": {
				"!type": "+Object"
			},
			"resultType": {
				"!type": "number"
			},
			"range": {
				"!type": "+Object"
			},
			"phoneNumber": {
				"!type": "string"
			},
			"components": {
				"!type": "+Object"
			},
			"alternativeStrings": {
				"!type": "+Array"
			},
			"duration": {
				"!type": "number"
			},
			"timeZone": {
				"!type": "+NSTimeZone"
			},
			"date": {
				"!type": "+Date"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"rangeAtIndex": {
				"!type": "fn(idx: number) -> +Object"
			},
			"resultByAdjustingRangesWithOffset": {
				"!type": "fn(offset: number) -> +NSTextCheckingResult"
			},
			"rangeWithName": {
				"!type": "fn(name: string) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSTextCheckingResult"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetWriterInputMetadataAdaptor": {
		"assetWriterInputMetadataAdaptorWithAssetWriterInput": {
			"!type": "fn(input: +AVAssetWriterInput) -> +AVAssetWriterInputMetadataAdaptor"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetWriterInputMetadataAdaptor"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetWriterInputMetadataAdaptor"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetWriterInputMetadataAdaptor"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"assetWriterInput": {
				"!type": "+AVAssetWriterInput"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithAssetWriterInput": {
				"!type": "fn(input: +AVAssetWriterInput) -> +AVAssetWriterInputMetadataAdaptor"
			},
			"appendTimedMetadataGroup": {
				"!type": "fn(timedMetadataGroup: +AVTimedMetadataGroup) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetWriterInputMetadataAdaptor"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLCredentialStorage": {
		"sharedCredentialStorage": {
			"!type": "fn() -> +NSURLCredentialStorage"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLCredentialStorage"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLCredentialStorage"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLCredentialStorage"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"allCredentials": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setCredentialForProtectionSpace": {
				"!type": "fn(credential: +NSURLCredential, space: +NSURLProtectionSpace) -> void"
			},
			"setDefaultCredentialForProtectionSpaceTask": {
				"!type": "fn(credential: +NSURLCredential, protectionSpace: +NSURLProtectionSpace, task: +NSURLSessionTask) -> void"
			},
			"removeCredentialForProtectionSpaceOptions": {
				"!type": "fn(credential: +NSURLCredential, space: +NSURLProtectionSpace, options: +Object) -> void"
			},
			"removeCredentialForProtectionSpace": {
				"!type": "fn(credential: +NSURLCredential, space: +NSURLProtectionSpace) -> void"
			},
			"removeCredentialForProtectionSpaceOptionsTask": {
				"!type": "fn(credential: +NSURLCredential, protectionSpace: +NSURLProtectionSpace, options: +Object, task: +NSURLSessionTask) -> void"
			},
			"defaultCredentialForProtectionSpace": {
				"!type": "fn(space: +NSURLProtectionSpace) -> +NSURLCredential"
			},
			"getDefaultCredentialForProtectionSpaceTaskCompletionHandler": {
				"!type": "fn(space: +NSURLProtectionSpace, task: +NSURLSessionTask, completionHandler: +Function) -> void"
			},
			"setDefaultCredentialForProtectionSpace": {
				"!type": "fn(credential: +NSURLCredential, space: +NSURLProtectionSpace) -> void"
			},
			"getCredentialsForProtectionSpaceTaskCompletionHandler": {
				"!type": "fn(protectionSpace: +NSURLProtectionSpace, task: +NSURLSessionTask, completionHandler: +Function) -> void"
			},
			"credentialsForProtectionSpace": {
				"!type": "fn(space: +NSURLProtectionSpace) -> +Object"
			},
			"setCredentialForProtectionSpaceTask": {
				"!type": "fn(credential: +NSURLCredential, protectionSpace: +NSURLProtectionSpace, task: +NSURLSessionTask) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLCredentialStorage"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureSynchronizedSampleBufferData": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureSynchronizedSampleBufferData"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureSynchronizedSampleBufferData"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureSynchronizedSampleBufferData"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"sampleBuffer": {
				"!type": "+Object"
			},
			"droppedReason": {
				"!type": "number"
			},
			"sampleBufferWasDropped": {
				"!type": "bool"
			},
			"timestamp": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureSynchronizedSampleBufferData"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioConverter": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioConverter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioConverter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioConverter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"availableEncodeSampleRates": {
				"!type": "+Array"
			},
			"outputFormat": {
				"!type": "+AVAudioFormat"
			},
			"channelMap": {
				"!type": "+Array"
			},
			"magicCookie": {
				"!type": "+NSData"
			},
			"maximumOutputPacketSize": {
				"!type": "number"
			},
			"inputFormat": {
				"!type": "+AVAudioFormat"
			},
			"sampleRateConverterAlgorithm": {
				"!type": "string"
			},
			"availableEncodeBitRates": {
				"!type": "+Array"
			},
			"bitRateStrategy": {
				"!type": "string"
			},
			"primeInfo": {
				"!type": "+Object"
			},
			"downmix": {
				"!type": "bool"
			},
			"availableEncodeChannelLayoutTags": {
				"!type": "+Array"
			},
			"applicableEncodeBitRates": {
				"!type": "+Array"
			},
			"primeMethod": {
				"!type": "number"
			},
			"applicableEncodeSampleRates": {
				"!type": "+Array"
			},
			"bitRate": {
				"!type": "number"
			},
			"sampleRateConverterQuality": {
				"!type": "number"
			},
			"dither": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"convertToBufferErrorWithInputFromBlock": {
				"!type": "fn(outputBuffer: +AVAudioBuffer, outError: +Object, inputBlock: +Function) -> number"
			},
			"initFromFormatToFormat": {
				"!type": "fn(fromFormat: +AVAudioFormat, toFormat: +AVAudioFormat) -> +AVAudioConverter"
			},
			"convertToBufferFromBufferError": {
				"!type": "fn(outputBuffer: +AVAudioPCMBuffer, inputBuffer: +AVAudioPCMBuffer, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioConverter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"UTType": {
		"typeWithMIMEType": {
			"!type": "fn(mimeType: string) -> +UTType"
		},
		"typeWithMIMETypeConformingToType": {
			"!type": "fn(mimeType: string, supertype: +UTType) -> +UTType"
		},
		"importedTypeWithIdentifier": {
			"!type": "fn(identifier: string) -> +UTType"
		},
		"exportedTypeWithIdentifierConformingToType": {
			"!type": "fn(identifier: string, parentType: +UTType) -> +UTType"
		},
		"typesWithTagTagClassConformingToType": {
			"!type": "fn(tag: string, tagClass: string, supertype: +UTType) -> +Array"
		},
		"typeWithFilenameExtension": {
			"!type": "fn(filenameExtension: string) -> +UTType"
		},
		"exportedTypeWithIdentifier": {
			"!type": "fn(identifier: string) -> +UTType"
		},
		"importedTypeWithIdentifierConformingToType": {
			"!type": "fn(identifier: string, parentType: +UTType) -> +UTType"
		},
		"typeWithTagTagClassConformingToType": {
			"!type": "fn(tag: string, tagClass: string, supertype: +UTType) -> +UTType"
		},
		"typeWithFilenameExtensionConformingToType": {
			"!type": "fn(filenameExtension: string, supertype: +UTType) -> +UTType"
		},
		"typeWithIdentifier": {
			"!type": "fn(identifier: string) -> +UTType"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +UTType"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +UTType"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +UTType"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"declared": {
				"!type": "bool"
			},
			"preferredMIMEType": {
				"!type": "string"
			},
			"localizedDescription": {
				"!type": "string"
			},
			"supertypes": {
				"!type": "+NSSet"
			},
			"tags": {
				"!type": "+Object"
			},
			"dynamic": {
				"!type": "bool"
			},
			"preferredFilenameExtension": {
				"!type": "string"
			},
			"referenceURL": {
				"!type": "+NSURL"
			},
			"version": {
				"!type": "number"
			},
			"publicType": {
				"!type": "bool"
			},
			"identifier": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"conformsToType": {
				"!type": "fn(type: +UTType) -> bool"
			},
			"isSupertypeOfType": {
				"!type": "fn(type: +UTType) -> bool"
			},
			"isSubtypeOfType": {
				"!type": "fn(type: +UTType) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +UTType"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CAReplicatorLayer": {
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +CAReplicatorLayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CAReplicatorLayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CAReplicatorLayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CAReplicatorLayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"instanceCount": {
				"!type": "number"
			},
			"instanceDelay": {
				"!type": "number"
			},
			"instanceGreenOffset": {
				"!type": "number"
			},
			"instanceBlueOffset": {
				"!type": "number"
			},
			"instanceColor": {
				"!type": "+Object"
			},
			"instanceTransform": {
				"!type": "+Object"
			},
			"preservesDepth": {
				"!type": "bool"
			},
			"instanceRedOffset": {
				"!type": "number"
			},
			"instanceAlphaOffset": {
				"!type": "number"
			},
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAReplicatorLayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +CAReplicatorLayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +CAReplicatorLayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +CAReplicatorLayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAReplicatorLayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVVideoCompositionInstruction": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVVideoCompositionInstruction"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVVideoCompositionInstruction"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVVideoCompositionInstruction"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"passthroughTrackID": {
				"!type": "number"
			},
			"requiredSourceTrackIDs": {
				"!type": "+Array"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"enablePostProcessing": {
				"!type": "bool"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"layerInstructions": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVVideoCompositionInstruction"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUUID": {
		"UUID": {
			"!type": "fn() -> +NSUUID"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUUID"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUUID"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUUID"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"UUIDString": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithUUIDBytes": {
				"!type": "fn(bytes: +Array) -> +NSUUID"
			},
			"jsinit": {
				"!type": "fn() -> +NSUUID"
			},
			"initWithUUIDString": {
				"!type": "fn(string: string) -> +NSUUID"
			},
			"getUUIDBytes": {
				"!type": "fn(uuid: +Array) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUUID"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetResourceLoader": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetResourceLoader"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetResourceLoader"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetResourceLoader"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"preloadsEligibleContentKeys": {
				"!type": "bool"
			},
			"delegate": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setDelegateQueue": {
				"!type": "fn(delegate: +Object, delegateQueue: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetResourceLoader"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMutableVideoCompositionInstruction": {
		"videoCompositionInstruction": {
			"!type": "fn() -> +AVMutableVideoCompositionInstruction"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMutableVideoCompositionInstruction"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMutableVideoCompositionInstruction"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMutableVideoCompositionInstruction"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"enablePostProcessing": {
				"!type": "bool"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"layerInstructions": {
				"!type": "+Array"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"passthroughTrackID": {
				"!type": "number"
			},
			"requiredSourceTrackIDs": {
				"!type": "+Array"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"enablePostProcessing": {
				"!type": "bool"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"layerInstructions": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMutableVideoCompositionInstruction"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUserActivity": {
		"deleteSavedUserActivitiesWithPersistentIdentifiersCompletionHandler": {
			"!type": "fn(persistentIdentifiers: +Array, handler: +Function) -> void"
		},
		"deleteAllSavedUserActivitiesWithCompletionHandler": {
			"!type": "fn(handler: +Function) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUserActivity"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUserActivity"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUserActivity"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"needsSave": {
				"!type": "bool"
			},
			"persistentIdentifier": {
				"!type": "string"
			},
			"supportsContinuationStreams": {
				"!type": "bool"
			},
			"delegate": {
				"!type": "+Object"
			},
			"eligibleForPublicIndexing": {
				"!type": "bool"
			},
			"title": {
				"!type": "string"
			},
			"webpageURL": {
				"!type": "+NSURL"
			},
			"eligibleForHandoff": {
				"!type": "bool"
			},
			"activityType": {
				"!type": "string"
			},
			"eligibleForPrediction": {
				"!type": "bool"
			},
			"targetContentIdentifier": {
				"!type": "string"
			},
			"userInfo": {
				"!type": "+Object"
			},
			"referrerURL": {
				"!type": "+NSURL"
			},
			"keywords": {
				"!type": "+NSSet"
			},
			"requiredUserInfoKeys": {
				"!type": "+NSSet"
			},
			"eligibleForSearch": {
				"!type": "bool"
			},
			"expirationDate": {
				"!type": "+Date"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"invalidate": {
				"!type": "fn() -> void"
			},
			"resignCurrent": {
				"!type": "fn() -> void"
			},
			"getContinuationStreamsWithCompletionHandler": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUserActivity"
			},
			"addUserInfoEntriesFromDictionary": {
				"!type": "fn(otherDictionary: +Object) -> void"
			},
			"initWithActivityType": {
				"!type": "fn(activityType: string) -> +NSUserActivity"
			},
			"becomeCurrent": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUserActivity"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLRequest": {
		"supportsSecureCoding": {
			"!type": "fn() -> bool"
		},
		"requestWithURL": {
			"!type": "fn(URL: +NSURL) -> +NSURLRequest"
		},
		"requestWithURLCachePolicyTimeoutInterval": {
			"!type": "fn(URL: +NSURL, cachePolicy: number, timeoutInterval: number) -> +NSURLRequest"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLRequest"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLRequest"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLRequest"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"timeoutInterval": {
				"!type": "number"
			},
			"allowsConstrainedNetworkAccess": {
				"!type": "bool"
			},
			"networkServiceType": {
				"!type": "number"
			},
			"allHTTPHeaderFields": {
				"!type": "+Object"
			},
			"HTTPMethod": {
				"!type": "string"
			},
			"URL": {
				"!type": "+NSURL"
			},
			"allowsCellularAccess": {
				"!type": "bool"
			},
			"HTTPBody": {
				"!type": "+NSData"
			},
			"mainDocumentURL": {
				"!type": "+NSURL"
			},
			"HTTPBodyStream": {
				"!type": "+NSInputStream"
			},
			"HTTPShouldHandleCookies": {
				"!type": "bool"
			},
			"allowsExpensiveNetworkAccess": {
				"!type": "bool"
			},
			"HTTPShouldUsePipelining": {
				"!type": "bool"
			},
			"cachePolicy": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithURL": {
				"!type": "fn(URL: +NSURL) -> +NSURLRequest"
			},
			"valueForHTTPHeaderField": {
				"!type": "fn(field: string) -> string"
			},
			"initWithURLCachePolicyTimeoutInterval": {
				"!type": "fn(URL: +NSURL, cachePolicy: number, timeoutInterval: number) -> +NSURLRequest"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLRequest"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVFragmentedMovieMinder": {
		"fragmentedMovieMinderWithMovieMindingInterval": {
			"!type": "fn(movie: +AVFragmentedMovie, mindingInterval: number) -> +AVFragmentedMovieMinder"
		},
		"fragmentedAssetMinderWithAssetMindingInterval": {
			"!type": "fn(asset: +AVAsset, mindingInterval: number) -> +AVFragmentedMovieMinder"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVFragmentedMovieMinder"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVFragmentedMovieMinder"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVFragmentedMovieMinder"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"movies": {
				"!type": "+Array"
			},
			"mindingInterval": {
				"!type": "number"
			},
			"mindingInterval": {
				"!type": "number"
			},
			"assets": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithMovieMindingInterval": {
				"!type": "fn(movie: +AVFragmentedMovie, mindingInterval: number) -> +AVFragmentedMovieMinder"
			},
			"addFragmentedMovie": {
				"!type": "fn(movie: +AVFragmentedMovie) -> void"
			},
			"removeFragmentedMovie": {
				"!type": "fn(movie: +AVFragmentedMovie) -> void"
			},
			"removeFragmentedAsset": {
				"!type": "fn(asset: +AVAsset) -> void"
			},
			"initWithAssetMindingInterval": {
				"!type": "fn(asset: +AVAsset, mindingInterval: number) -> +AVFragmentedMovieMinder"
			},
			"addFragmentedAsset": {
				"!type": "fn(asset: +AVAsset) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVFragmentedMovieMinder"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLSessionWebSocketTask": {
		"jsnew": {
			"!type": "fn() -> +NSURLSessionWebSocketTask"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLSessionWebSocketTask"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLSessionWebSocketTask"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionWebSocketTask"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"closeCode": {
				"!type": "number"
			},
			"closeReason": {
				"!type": "+NSData"
			},
			"maximumMessageSize": {
				"!type": "number"
			},
			"countOfBytesSent": {
				"!type": "number"
			},
			"earliestBeginDate": {
				"!type": "+Date"
			},
			"countOfBytesExpectedToReceive": {
				"!type": "number"
			},
			"taskDescription": {
				"!type": "string"
			},
			"countOfBytesExpectedToSend": {
				"!type": "number"
			},
			"state": {
				"!type": "number"
			},
			"priority": {
				"!type": "number"
			},
			"countOfBytesClientExpectsToSend": {
				"!type": "number"
			},
			"taskIdentifier": {
				"!type": "number"
			},
			"countOfBytesReceived": {
				"!type": "number"
			},
			"error": {
				"!type": "+NSError"
			},
			"currentRequest": {
				"!type": "+NSURLRequest"
			},
			"progress": {
				"!type": "+NSProgress"
			},
			"countOfBytesClientExpectsToReceive": {
				"!type": "number"
			},
			"response": {
				"!type": "+NSURLResponse"
			},
			"originalRequest": {
				"!type": "+NSURLRequest"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"sendPingWithPongReceiveHandler": {
				"!type": "fn(pongReceiveHandler: +Function) -> void"
			},
			"cancelWithCloseCodeReason": {
				"!type": "fn(closeCode: number, reason: +NSData) -> void"
			},
			"receiveMessageWithCompletionHandler": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"sendMessageCompletionHandler": {
				"!type": "fn(message: +NSURLSessionWebSocketMessage, completionHandler: +Function) -> void"
			},
			"suspend": {
				"!type": "fn() -> void"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"resume": {
				"!type": "fn() -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionWebSocketTask"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionWebSocketTask"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CATransformLayer": {
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +CATransformLayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CATransformLayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CATransformLayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CATransformLayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CATransformLayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +CATransformLayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +CATransformLayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +CATransformLayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CATransformLayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureDeviceDiscoverySession": {
		"discoverySessionWithDeviceTypesMediaTypePosition": {
			"!type": "fn(deviceTypes: +Array, mediaType: string, position: number) -> +AVCaptureDeviceDiscoverySession"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureDeviceDiscoverySession"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureDeviceDiscoverySession"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureDeviceDiscoverySession"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"supportedMultiCamDeviceSets": {
				"!type": "+Array"
			},
			"devices": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureDeviceDiscoverySession"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CAValueFunction": {
		"functionWithName": {
			"!type": "fn(name: string) -> +CAValueFunction"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CAValueFunction"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CAValueFunction"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CAValueFunction"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"name": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAValueFunction"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSNotification": {
		"notificationWithNameObjectUserInfo": {
			"!type": "fn(aName: string, anObject: +Object, aUserInfo: +Object) -> +NSNotification"
		},
		"notificationWithNameObject": {
			"!type": "fn(aName: string, anObject: +Object) -> +NSNotification"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSNotification"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSNotification"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSNotification"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"object": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"userInfo": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithNameObjectUserInfo": {
				"!type": "fn(name: string, object: +Object, userInfo: +Object) -> +NSNotification"
			},
			"jsinit": {
				"!type": "fn() -> +NSNotification"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSNotification"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSNotification"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetDownloadTask": {
		"jsnew": {
			"!type": "fn() -> +AVAssetDownloadTask"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetDownloadTask"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetDownloadTask"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetDownloadTask"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"loadedTimeRanges": {
				"!type": "+Array"
			},
			"options": {
				"!type": "+Object"
			},
			"URLAsset": {
				"!type": "+AVURLAsset"
			},
			"destinationURL": {
				"!type": "+NSURL"
			},
			"countOfBytesSent": {
				"!type": "number"
			},
			"earliestBeginDate": {
				"!type": "+Date"
			},
			"countOfBytesExpectedToReceive": {
				"!type": "number"
			},
			"taskDescription": {
				"!type": "string"
			},
			"countOfBytesExpectedToSend": {
				"!type": "number"
			},
			"state": {
				"!type": "number"
			},
			"priority": {
				"!type": "number"
			},
			"countOfBytesClientExpectsToSend": {
				"!type": "number"
			},
			"taskIdentifier": {
				"!type": "number"
			},
			"countOfBytesReceived": {
				"!type": "number"
			},
			"error": {
				"!type": "+NSError"
			},
			"currentRequest": {
				"!type": "+NSURLRequest"
			},
			"progress": {
				"!type": "+NSProgress"
			},
			"countOfBytesClientExpectsToReceive": {
				"!type": "number"
			},
			"response": {
				"!type": "+NSURLResponse"
			},
			"originalRequest": {
				"!type": "+NSURLRequest"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"suspend": {
				"!type": "fn() -> void"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"resume": {
				"!type": "fn() -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetDownloadTask"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetDownloadTask"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureDeviceFormat": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureDeviceFormat"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureDeviceFormat"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureDeviceFormat"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"autoFocusSystem": {
				"!type": "number"
			},
			"highResolutionStillImageDimensions": {
				"!type": "+Object"
			},
			"videoFieldOfView": {
				"!type": "number"
			},
			"supportedDepthDataFormats": {
				"!type": "+Array"
			},
			"formatDescription": {
				"!type": "+Object"
			},
			"videoMinZoomFactorForDepthDataDelivery": {
				"!type": "number"
			},
			"maxExposureDuration": {
				"!type": "+Object"
			},
			"mediaType": {
				"!type": "string"
			},
			"unsupportedCaptureOutputClasses": {
				"!type": "+Array"
			},
			"videoZoomFactorUpscaleThreshold": {
				"!type": "number"
			},
			"minISO": {
				"!type": "number"
			},
			"maxISO": {
				"!type": "number"
			},
			"supportedColorSpaces": {
				"!type": "+Array"
			},
			"videoHDRSupported": {
				"!type": "bool"
			},
			"portraitEffectsMatteStillImageDeliverySupported": {
				"!type": "bool"
			},
			"multiCamSupported": {
				"!type": "bool"
			},
			"globalToneMappingSupported": {
				"!type": "bool"
			},
			"videoSupportedFrameRateRanges": {
				"!type": "+Array"
			},
			"geometricDistortionCorrectedVideoFieldOfView": {
				"!type": "number"
			},
			"videoBinned": {
				"!type": "bool"
			},
			"videoStabilizationSupported": {
				"!type": "bool"
			},
			"videoMaxZoomFactor": {
				"!type": "number"
			},
			"minExposureDuration": {
				"!type": "+Object"
			},
			"highestPhotoQualitySupported": {
				"!type": "bool"
			},
			"videoMaxZoomFactorForDepthDataDelivery": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"isVideoStabilizationModeSupported": {
				"!type": "fn(videoStabilizationMode: number) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureDeviceFormat"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetSegmentReport": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetSegmentReport"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetSegmentReport"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetSegmentReport"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"segmentType": {
				"!type": "number"
			},
			"trackReports": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetSegmentReport"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerItemErrorLog": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerItemErrorLog"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerItemErrorLog"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerItemErrorLog"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"extendedLogDataStringEncoding": {
				"!type": "number"
			},
			"events": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"extendedLogData": {
				"!type": "fn() -> +NSData"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerItemErrorLog"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSDimension": {
		"baseUnit": {
			"!type": "fn() -> +NSDimension"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSDimension"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSDimension"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSDimension"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSDimension"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSDimension"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSDimension"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMapTable": {
		"mapTableWithKeyOptionsValueOptions": {
			"!type": "fn(keyOptions: number, valueOptions: number) -> +NSMapTable"
		},
		"weakToStrongObjectsMapTable": {
			"!type": "fn() -> +NSMapTable"
		},
		"strongToStrongObjectsMapTable": {
			"!type": "fn() -> +NSMapTable"
		},
		"weakToWeakObjectsMapTable": {
			"!type": "fn() -> +NSMapTable"
		},
		"strongToWeakObjectsMapTable": {
			"!type": "fn() -> +NSMapTable"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMapTable"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMapTable"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMapTable"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"valuePointerFunctions": {
				"!type": "+NSPointerFunctions"
			},
			"keyPointerFunctions": {
				"!type": "+NSPointerFunctions"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"objectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"keyEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"dictionaryRepresentation": {
				"!type": "fn() -> +Object"
			},
			"setObjectForKey": {
				"!type": "fn(anObject: +Object, aKey: +Object) -> void"
			},
			"removeAllObjects": {
				"!type": "fn() -> void"
			},
			"removeObjectForKey": {
				"!type": "fn(aKey: +Object) -> void"
			},
			"initWithKeyPointerFunctionsValuePointerFunctionsCapacity": {
				"!type": "fn(keyFunctions: +NSPointerFunctions, valueFunctions: +NSPointerFunctions, initialCapacity: number) -> +NSMapTable"
			},
			"initWithKeyOptionsValueOptionsCapacity": {
				"!type": "fn(keyOptions: number, valueOptions: number, initialCapacity: number) -> +NSMapTable"
			},
			"objectForKey": {
				"!type": "fn(aKey: +Object) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMapTable"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSSet": {
		"setWithObjects": {
			"!type": "fn(firstObj: +Object, args: Array.prototype) -> +NSSet"
		},
		"setWithArray": {
			"!type": "fn(array: +Array) -> +NSSet"
		},
		"set": {
			"!type": "fn() -> +NSSet"
		},
		"setWithSet": {
			"!type": "fn(set: +NSSet) -> +NSSet"
		},
		"setWithObject": {
			"!type": "fn(object: +Object) -> +NSSet"
		},
		"setWithObjectsCount": {
			"!type": "fn(objects: +Object, cnt: number) -> +NSSet"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSSet"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSSet"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSSet"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"allObjects": {
				"!type": "+Array"
			},
			"description": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSet": {
				"!type": "fn(set: +NSSet) -> +NSSet"
			},
			"anyObject": {
				"!type": "fn() -> +Object"
			},
			"initWithObjectsCount": {
				"!type": "fn(objects: +Object, cnt: number) -> +NSSet"
			},
			"containsObject": {
				"!type": "fn(anObject: +Object) -> bool"
			},
			"enumerateObjectsWithOptionsUsingBlock": {
				"!type": "fn(opts: number, block: +Function) -> void"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSSet"
			},
			"isEqualToSet": {
				"!type": "fn(otherSet: +NSSet) -> bool"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"sortedArrayUsingDescriptors": {
				"!type": "fn(sortDescriptors: +Array) -> +Array"
			},
			"makeObjectsPerformSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"initWithObjects": {
				"!type": "fn(firstObj: +Object, args: Array.prototype) -> +NSSet"
			},
			"initWithArray": {
				"!type": "fn(array: +Array) -> +NSSet"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"setByAddingObject": {
				"!type": "fn(anObject: +Object) -> +NSSet"
			},
			"descriptionWithLocale": {
				"!type": "fn(locale: +Object) -> string"
			},
			"isSubsetOfSet": {
				"!type": "fn(otherSet: +NSSet) -> bool"
			},
			"member": {
				"!type": "fn(object: +Object) -> +Object"
			},
			"filteredSetUsingPredicate": {
				"!type": "fn(predicate: +NSPredicate) -> +NSSet"
			},
			"objectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"objectsWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> +NSSet"
			},
			"enumerateObjectsUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"intersectsSet": {
				"!type": "fn(otherSet: +NSSet) -> bool"
			},
			"initWithSetCopyItems": {
				"!type": "fn(set: +NSSet, flag: bool) -> +NSSet"
			},
			"setByAddingObjectsFromSet": {
				"!type": "fn(other: +NSSet) -> +NSSet"
			},
			"jsinit": {
				"!type": "fn() -> +NSSet"
			},
			"setByAddingObjectsFromArray": {
				"!type": "fn(other: +Array) -> +NSSet"
			},
			"objectsPassingTest": {
				"!type": "fn(predicate: +Function) -> +NSSet"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"makeObjectsPerformSelectorWithObject": {
				"!type": "fn(aSelector: string, argument: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSSet"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMetadataCatBodyObject": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMetadataCatBodyObject"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMetadataCatBodyObject"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMetadataCatBodyObject"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"bodyID": {
				"!type": "number"
			},
			"duration": {
				"!type": "+Object"
			},
			"type": {
				"!type": "string"
			},
			"bounds": {
				"!type": "+Object"
			},
			"time": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMetadataCatBodyObject"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnitReverb": {
		"instantiateWithComponentDescriptionOptionsCompletionHandler": {
			"!type": "fn(audioComponentDescription: +Object, options: number, completionHandler: +Function) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnitReverb"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnitReverb"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnitReverb"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"wetDryMix": {
				"!type": "number"
			},
			"bypass": {
				"!type": "bool"
			},
			"name": {
				"!type": "string"
			},
			"audioComponentDescription": {
				"!type": "+Object"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"version": {
				"!type": "number"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"loadFactoryPreset": {
				"!type": "fn(preset: number) -> void"
			},
			"initWithAudioComponentDescription": {
				"!type": "fn(audioComponentDescription: +Object) -> +AVAudioUnitReverb"
			},
			"loadAudioUnitPresetAtURLError": {
				"!type": "fn(url: +NSURL, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnitReverb"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMutableComposition": {
		"compositionWithURLAssetInitializationOptions": {
			"!type": "fn(URLAssetInitializationOptions: +Object) -> +AVMutableComposition"
		},
		"composition": {
			"!type": "fn() -> +AVMutableComposition"
		},
		"assetWithURL": {
			"!type": "fn(URL: +NSURL) -> +AVMutableComposition"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMutableComposition"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMutableComposition"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMutableComposition"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"tracks": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"URLAssetInitializationOptions": {
				"!type": "+Object"
			},
			"tracks": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"creationDate": {
				"!type": "+AVMetadataItem"
			},
			"referenceRestrictions": {
				"!type": "number"
			},
			"canContainFragments": {
				"!type": "bool"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"preferredRate": {
				"!type": "number"
			},
			"composable": {
				"!type": "bool"
			},
			"tracks": {
				"!type": "+Array"
			},
			"containsFragments": {
				"!type": "bool"
			},
			"availableMediaCharacteristicsWithMediaSelectionOptions": {
				"!type": "+Array"
			},
			"preferredMediaSelection": {
				"!type": "+AVMediaSelection"
			},
			"duration": {
				"!type": "+Object"
			},
			"providesPreciseDurationAndTiming": {
				"!type": "bool"
			},
			"compatibleWithAirPlayVideo": {
				"!type": "bool"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"exportable": {
				"!type": "bool"
			},
			"lyrics": {
				"!type": "string"
			},
			"trackGroups": {
				"!type": "+Array"
			},
			"compatibleWithSavedPhotosAlbum": {
				"!type": "bool"
			},
			"readable": {
				"!type": "bool"
			},
			"hasProtectedContent": {
				"!type": "bool"
			},
			"overallDurationHint": {
				"!type": "+Object"
			},
			"availableChapterLocales": {
				"!type": "+Array"
			},
			"minimumTimeOffsetFromLive": {
				"!type": "+Object"
			},
			"allMediaSelections": {
				"!type": "+Array"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"insertEmptyTimeRange": {
				"!type": "fn(timeRange: +Object) -> void"
			},
			"removeTimeRange": {
				"!type": "fn(timeRange: +Object) -> void"
			},
			"insertTimeRangeOfAssetAtTimeError": {
				"!type": "fn(timeRange: +Object, asset: +AVAsset, startTime: +Object, outError: +Object) -> bool"
			},
			"removeTrack": {
				"!type": "fn(track: +AVCompositionTrack) -> void"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVMutableCompositionTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"mutableTrackCompatibleWithTrack": {
				"!type": "fn(track: +AVAssetTrack) -> +AVMutableCompositionTrack"
			},
			"addMutableTrackWithMediaTypePreferredTrackID": {
				"!type": "fn(mediaType: string, preferredTrackID: number) -> +AVMutableCompositionTrack"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"scaleTimeRangeToDuration": {
				"!type": "fn(timeRange: +Object, duration: +Object) -> void"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVCompositionTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"unusedTrackID": {
				"!type": "fn() -> number"
			},
			"chapterMetadataGroupsWithTitleLocaleContainingItemsWithCommonKeys": {
				"!type": "fn(locale: +NSLocale, commonKeys: +Array) -> +Array"
			},
			"cancelLoading": {
				"!type": "fn() -> void"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVAssetTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"mediaSelectionGroupForMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +AVMediaSelectionGroup"
			},
			"chapterMetadataGroupsBestMatchingPreferredLanguages": {
				"!type": "fn(preferredLanguages: +Array) -> +Array"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMutableComposition"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSOrderedSet": {
		"orderedSetWithOrderedSet": {
			"!type": "fn(set: +NSOrderedSet) -> +NSOrderedSet"
		},
		"orderedSetWithOrderedSetRangeCopyItems": {
			"!type": "fn(set: +NSOrderedSet, range: +Object, flag: bool) -> +NSOrderedSet"
		},
		"orderedSetWithObjects": {
			"!type": "fn(firstObj: +Object, args: Array.prototype) -> +NSOrderedSet"
		},
		"orderedSetWithObjectsCount": {
			"!type": "fn(objects: +Object, cnt: number) -> +NSOrderedSet"
		},
		"orderedSetWithObject": {
			"!type": "fn(object: +Object) -> +NSOrderedSet"
		},
		"orderedSetWithSetCopyItems": {
			"!type": "fn(set: +NSSet, flag: bool) -> +NSOrderedSet"
		},
		"orderedSet": {
			"!type": "fn() -> +NSOrderedSet"
		},
		"orderedSetWithArrayRangeCopyItems": {
			"!type": "fn(array: +Array, range: +Object, flag: bool) -> +NSOrderedSet"
		},
		"orderedSetWithArray": {
			"!type": "fn(array: +Array) -> +NSOrderedSet"
		},
		"orderedSetWithSet": {
			"!type": "fn(set: +NSSet) -> +NSOrderedSet"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSOrderedSet"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSOrderedSet"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSOrderedSet"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"set": {
				"!type": "+NSSet"
			},
			"firstObject": {
				"!type": "+Object"
			},
			"description": {
				"!type": "string"
			},
			"lastObject": {
				"!type": "+Object"
			},
			"array": {
				"!type": "+Array"
			},
			"reversedOrderedSet": {
				"!type": "+NSOrderedSet"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSet": {
				"!type": "fn(set: +NSSet) -> +NSOrderedSet"
			},
			"initWithObjectsCount": {
				"!type": "fn(objects: +Object, cnt: number) -> +NSOrderedSet"
			},
			"initWithArrayRangeCopyItems": {
				"!type": "fn(set: +Array, range: +Object, flag: bool) -> +NSOrderedSet"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"sortedArrayUsingComparator": {
				"!type": "fn(cmptr: +Function) -> +Array"
			},
			"indexesOfObjectsWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> +NSIndexSet"
			},
			"containsObject": {
				"!type": "fn(object: +Object) -> bool"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"objectAtIndexedSubscript": {
				"!type": "fn(idx: number) -> +Object"
			},
			"isSubsetOfSet": {
				"!type": "fn(set: +NSSet) -> bool"
			},
			"indexesOfObjectsPassingTest": {
				"!type": "fn(predicate: +Function) -> +NSIndexSet"
			},
			"reverseObjectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"objectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"isEqualToOrderedSet": {
				"!type": "fn(other: +NSOrderedSet) -> bool"
			},
			"differenceFromOrderedSetWithOptionsUsingEquivalenceTest": {
				"!type": "fn(other: +NSOrderedSet, options: number, block: +Function) -> +NSOrderedCollectionDifference"
			},
			"descriptionWithLocaleIndent": {
				"!type": "fn(locale: +Object, level: number) -> string"
			},
			"sortedArrayWithOptionsUsingComparator": {
				"!type": "fn(opts: number, cmptr: +Function) -> +Array"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"filteredOrderedSetUsingPredicate": {
				"!type": "fn(p: +NSPredicate) -> +NSOrderedSet"
			},
			"initWithSetCopyItems": {
				"!type": "fn(set: +NSSet, flag: bool) -> +NSOrderedSet"
			},
			"initWithArrayCopyItems": {
				"!type": "fn(set: +Array, flag: bool) -> +NSOrderedSet"
			},
			"jsinit": {
				"!type": "fn() -> +NSOrderedSet"
			},
			"differenceFromOrderedSetWithOptions": {
				"!type": "fn(other: +NSOrderedSet, options: number) -> +NSOrderedCollectionDifference"
			},
			"initWithOrderedSetRangeCopyItems": {
				"!type": "fn(set: +NSOrderedSet, range: +Object, flag: bool) -> +NSOrderedSet"
			},
			"enumerateObjectsWithOptionsUsingBlock": {
				"!type": "fn(opts: number, block: +Function) -> void"
			},
			"initWithObject": {
				"!type": "fn(object: +Object) -> +NSOrderedSet"
			},
			"indexOfObjectInSortedRangeOptionsUsingComparator": {
				"!type": "fn(object: +Object, range: +Object, opts: number, cmp: +Function) -> number"
			},
			"differenceFromOrderedSet": {
				"!type": "fn(other: +NSOrderedSet) -> +NSOrderedCollectionDifference"
			},
			"objectsAtIndexes": {
				"!type": "fn(indexes: +NSIndexSet) -> +Array"
			},
			"indexOfObjectWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> number"
			},
			"initWithOrderedSetCopyItems": {
				"!type": "fn(set: +NSOrderedSet, flag: bool) -> +NSOrderedSet"
			},
			"sortedArrayUsingDescriptors": {
				"!type": "fn(sortDescriptors: +Array) -> +Array"
			},
			"descriptionWithLocale": {
				"!type": "fn(locale: +Object) -> string"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSOrderedSet"
			},
			"orderedSetByApplyingDifference": {
				"!type": "fn(difference: +NSOrderedCollectionDifference) -> +NSOrderedSet"
			},
			"indexesOfObjectsAtIndexesOptionsPassingTest": {
				"!type": "fn(s: +NSIndexSet, opts: number, predicate: +Function) -> +NSIndexSet"
			},
			"intersectsOrderedSet": {
				"!type": "fn(other: +NSOrderedSet) -> bool"
			},
			"initWithObjects": {
				"!type": "fn(firstObj: +Object, args: Array.prototype) -> +NSOrderedSet"
			},
			"initWithArray": {
				"!type": "fn(array: +Array) -> +NSOrderedSet"
			},
			"initWithOrderedSet": {
				"!type": "fn(set: +NSOrderedSet) -> +NSOrderedSet"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"objectAtIndex": {
				"!type": "fn(idx: number) -> +Object"
			},
			"enumerateObjectsUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"indexOfObject": {
				"!type": "fn(object: +Object) -> number"
			},
			"indexOfObjectAtIndexesOptionsPassingTest": {
				"!type": "fn(s: +NSIndexSet, opts: number, predicate: +Function) -> number"
			},
			"indexOfObjectPassingTest": {
				"!type": "fn(predicate: +Function) -> number"
			},
			"intersectsSet": {
				"!type": "fn(set: +NSSet) -> bool"
			},
			"isSubsetOfOrderedSet": {
				"!type": "fn(other: +NSOrderedSet) -> bool"
			},
			"getObjectsRange": {
				"!type": "fn(objects: +Object, range: +Object) -> void"
			},
			"enumerateObjectsAtIndexesOptionsUsingBlock": {
				"!type": "fn(s: +NSIndexSet, opts: number, block: +Function) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSOrderedSet"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVFragmentedMovieTrack": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVFragmentedMovieTrack"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVFragmentedMovieTrack"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVFragmentedMovieTrack"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"mediaDecodeTimeRange": {
				"!type": "+Object"
			},
			"alternateGroupID": {
				"!type": "number"
			},
			"mediaPresentationTimeRange": {
				"!type": "+Object"
			},
			"mediaDataStorage": {
				"!type": "+AVMediaDataStorage"
			},
			"languageCode": {
				"!type": "string"
			},
			"minFrameDuration": {
				"!type": "+Object"
			},
			"formatDescriptions": {
				"!type": "+Array"
			},
			"availableTrackAssociationTypes": {
				"!type": "+Array"
			},
			"nominalFrameRate": {
				"!type": "number"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"estimatedDataRate": {
				"!type": "number"
			},
			"naturalTimeScale": {
				"!type": "number"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"requiresFrameReordering": {
				"!type": "bool"
			},
			"hasAudioSampleDependencies": {
				"!type": "bool"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"selfContained": {
				"!type": "bool"
			},
			"segments": {
				"!type": "+Array"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"extendedLanguageTag": {
				"!type": "string"
			},
			"mediaType": {
				"!type": "string"
			},
			"asset": {
				"!type": "+AVAsset"
			},
			"trackID": {
				"!type": "number"
			},
			"totalSampleDataLength": {
				"!type": "number"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"decodable": {
				"!type": "bool"
			},
			"enabled": {
				"!type": "bool"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hasMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> bool"
			},
			"samplePresentationTimeForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +Object"
			},
			"associatedTracksOfType": {
				"!type": "fn(trackAssociationType: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"segmentForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +AVAssetTrackSegment"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVFragmentedMovieTrack"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioEngine": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioEngine"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioEngine"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioEngine"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"manualRenderingMode": {
				"!type": "number"
			},
			"manualRenderingSampleTime": {
				"!type": "number"
			},
			"musicSequence": {
				"!type": "+Object"
			},
			"jsmanualRenderingBlock": {
				"!type": "+Function"
			},
			"autoShutdownEnabled": {
				"!type": "bool"
			},
			"running": {
				"!type": "bool"
			},
			"attachedNodes": {
				"!type": "+NSSet"
			},
			"mainMixerNode": {
				"!type": "+AVAudioMixerNode"
			},
			"inputNode": {
				"!type": "+AVAudioInputNode"
			},
			"manualRenderingFormat": {
				"!type": "+AVAudioFormat"
			},
			"manualRenderingMaximumFrameCount": {
				"!type": "number"
			},
			"outputNode": {
				"!type": "+AVAudioOutputNode"
			},
			"isInManualRenderingMode": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"outputConnectionPointsForNodeOutputBus": {
				"!type": "fn(node: +AVAudioNode, bus: number) -> +Array"
			},
			"connectToFormat": {
				"!type": "fn(node1: +AVAudioNode, node2: +AVAudioNode, format: +AVAudioFormat) -> void"
			},
			"disconnectMIDIInput": {
				"!type": "fn(node: +AVAudioNode) -> void"
			},
			"disableManualRenderingMode": {
				"!type": "fn() -> void"
			},
			"connectToFromBusToBusFormat": {
				"!type": "fn(node1: +AVAudioNode, node2: +AVAudioNode, bus1: number, bus2: number, format: +AVAudioFormat) -> void"
			},
			"connectMIDIToNodesFormatBlock": {
				"!type": "fn(sourceNode: +AVAudioNode, destinationNodes: +Array, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"pause": {
				"!type": "fn() -> void"
			},
			"disconnectNodeInput": {
				"!type": "fn(node: +AVAudioNode) -> void"
			},
			"prepare": {
				"!type": "fn() -> void"
			},
			"disconnectMIDIOutput": {
				"!type": "fn(node: +AVAudioNode) -> void"
			},
			"connectMIDIToFormatBlock": {
				"!type": "fn(sourceNode: +AVAudioNode, destinationNode: +AVAudioNode, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"disconnectNodeInputBus": {
				"!type": "fn(node: +AVAudioNode, bus: number) -> void"
			},
			"enableManualRenderingModeFormatMaximumFrameCountError": {
				"!type": "fn(mode: number, pcmFormat: +AVAudioFormat, maximumFrameCount: number, outError: +Object) -> bool"
			},
			"disconnectNodeOutput": {
				"!type": "fn(node: +AVAudioNode) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioEngine"
			},
			"detachNode": {
				"!type": "fn(node: +AVAudioNode) -> void"
			},
			"stop": {
				"!type": "fn() -> void"
			},
			"inputConnectionPointForNodeInputBus": {
				"!type": "fn(node: +AVAudioNode, bus: number) -> +AVAudioConnectionPoint"
			},
			"connectToConnectionPointsFromBusFormat": {
				"!type": "fn(sourceNode: +AVAudioNode, destNodes: +Array, sourceBus: number, format: +AVAudioFormat) -> void"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"renderOfflineToBufferError": {
				"!type": "fn(numberOfFrames: number, buffer: +AVAudioPCMBuffer, outError: +Object) -> number"
			},
			"disconnectMIDIFromNodes": {
				"!type": "fn(sourceNode: +AVAudioNode, destinationNodes: +Array) -> void"
			},
			"startAndReturnError": {
				"!type": "fn(outError: +Object) -> bool"
			},
			"disconnectNodeOutputBus": {
				"!type": "fn(node: +AVAudioNode, bus: number) -> void"
			},
			"disconnectMIDIFrom": {
				"!type": "fn(sourceNode: +AVAudioNode, destinationNode: +AVAudioNode) -> void"
			},
			"attachNode": {
				"!type": "fn(node: +AVAudioNode) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioEngine"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnitDistortion": {
		"instantiateWithComponentDescriptionOptionsCompletionHandler": {
			"!type": "fn(audioComponentDescription: +Object, options: number, completionHandler: +Function) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnitDistortion"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnitDistortion"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnitDistortion"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"preGain": {
				"!type": "number"
			},
			"wetDryMix": {
				"!type": "number"
			},
			"bypass": {
				"!type": "bool"
			},
			"name": {
				"!type": "string"
			},
			"audioComponentDescription": {
				"!type": "+Object"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"version": {
				"!type": "number"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"loadFactoryPreset": {
				"!type": "fn(preset: number) -> void"
			},
			"initWithAudioComponentDescription": {
				"!type": "fn(audioComponentDescription: +Object) -> +AVAudioUnitDistortion"
			},
			"loadAudioUnitPresetAtURLError": {
				"!type": "fn(url: +NSURL, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnitDistortion"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLSessionTaskMetrics": {
		"jsnew": {
			"!type": "fn() -> +NSURLSessionTaskMetrics"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLSessionTaskMetrics"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLSessionTaskMetrics"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionTaskMetrics"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"redirectCount": {
				"!type": "number"
			},
			"taskInterval": {
				"!type": "+NSDateInterval"
			},
			"transactionMetrics": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionTaskMetrics"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionTaskMetrics"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitSpeed": {
		"metersPerSecond": {
			"!type": "fn() -> +NSUnitSpeed"
		},
		"knots": {
			"!type": "fn() -> +NSUnitSpeed"
		},
		"kilometersPerHour": {
			"!type": "fn() -> +NSUnitSpeed"
		},
		"milesPerHour": {
			"!type": "fn() -> +NSUnitSpeed"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitSpeed"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitSpeed"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitSpeed"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitSpeed"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitSpeed"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitSpeed"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitSpeed"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSOperation": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSOperation"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSOperation"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSOperation"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"ready": {
				"!type": "bool"
			},
			"name": {
				"!type": "string"
			},
			"jscompletionBlock": {
				"!type": "+Function"
			},
			"concurrent": {
				"!type": "bool"
			},
			"qualityOfService": {
				"!type": "number"
			},
			"queuePriority": {
				"!type": "number"
			},
			"executing": {
				"!type": "bool"
			},
			"finished": {
				"!type": "bool"
			},
			"dependencies": {
				"!type": "+Array"
			},
			"asynchronous": {
				"!type": "bool"
			},
			"threadPriority": {
				"!type": "number"
			},
			"cancelled": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"waitUntilFinished": {
				"!type": "fn() -> void"
			},
			"start": {
				"!type": "fn() -> void"
			},
			"main": {
				"!type": "fn() -> void"
			},
			"addDependency": {
				"!type": "fn(op: +NSOperation) -> void"
			},
			"removeDependency": {
				"!type": "fn(op: +NSOperation) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSOperation"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetDownloadStorageManagementPolicy": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetDownloadStorageManagementPolicy"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetDownloadStorageManagementPolicy"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetDownloadStorageManagementPolicy"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"priority": {
				"!type": "string"
			},
			"expirationDate": {
				"!type": "+Date"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetDownloadStorageManagementPolicy"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCapturePhoto": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCapturePhoto"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCapturePhoto"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCapturePhoto"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"rawPhoto": {
				"!type": "bool"
			},
			"photoCount": {
				"!type": "number"
			},
			"portraitEffectsMatte": {
				"!type": "+AVPortraitEffectsMatte"
			},
			"resolvedSettings": {
				"!type": "+AVCaptureResolvedPhotoSettings"
			},
			"previewPixelBuffer": {
				"!type": "+Object"
			},
			"timestamp": {
				"!type": "+Object"
			},
			"pixelBuffer": {
				"!type": "+Object"
			},
			"embeddedThumbnailPhotoFormat": {
				"!type": "+Object"
			},
			"cameraCalibrationData": {
				"!type": "+AVCameraCalibrationData"
			},
			"sequenceCount": {
				"!type": "number"
			},
			"bracketSettings": {
				"!type": "+AVCaptureBracketedStillImageSettings"
			},
			"sourceDeviceType": {
				"!type": "string"
			},
			"lensStabilizationStatus": {
				"!type": "number"
			},
			"depthData": {
				"!type": "+AVDepthData"
			},
			"metadata": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"CGImageRepresentation": {
				"!type": "fn() -> +Object"
			},
			"previewCGImageRepresentation": {
				"!type": "fn() -> +Object"
			},
			"fileDataRepresentationWithReplacementMetadataReplacementEmbeddedThumbnailPhotoFormatReplacementEmbeddedThumbnailPixelBufferReplacementDepthData": {
				"!type": "fn(replacementMetadata: +Object, replacementEmbeddedThumbnailPhotoFormat: +Object, replacementEmbeddedThumbnailPixelBuffer: +Object, replacementDepthData: +AVDepthData) -> +NSData"
			},
			"semanticSegmentationMatteForType": {
				"!type": "fn(semanticSegmentationMatteType: string) -> +AVSemanticSegmentationMatte"
			},
			"fileDataRepresentation": {
				"!type": "fn() -> +NSData"
			},
			"fileDataRepresentationWithCustomizer": {
				"!type": "fn(customizer: +Object) -> +NSData"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCapturePhoto"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMutableArray": {
		"arrayWithContentsOfFile": {
			"!type": "fn(path: string) -> +NSMutableArray"
		},
		"arrayWithCapacity": {
			"!type": "fn(numItems: number) -> +NSMutableArray"
		},
		"arrayWithContentsOfURL": {
			"!type": "fn(url: +NSURL) -> +NSMutableArray"
		},
		"arrayWithContentsOfFile": {
			"!type": "fn(path: string) -> +Array"
		},
		"arrayWithObjects": {
			"!type": "fn(firstObj: +Object, args: Array.prototype) -> +NSMutableArray"
		},
		"arrayWithContentsOfURLError": {
			"!type": "fn(url: +NSURL, error: +Object) -> +Array"
		},
		"arrayWithObjectsCount": {
			"!type": "fn(objects: +Object, cnt: number) -> +NSMutableArray"
		},
		"arrayWithObject": {
			"!type": "fn(anObject: +Object) -> +NSMutableArray"
		},
		"arrayWithContentsOfURL": {
			"!type": "fn(url: +NSURL) -> +Array"
		},
		"array": {
			"!type": "fn() -> +NSMutableArray"
		},
		"arrayWithArray": {
			"!type": "fn(array: +Array) -> +NSMutableArray"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMutableArray"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMutableArray"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMutableArray"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"firstObject": {
				"!type": "+Object"
			},
			"description": {
				"!type": "string"
			},
			"sortedArrayHint": {
				"!type": "+NSData"
			},
			"lastObject": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"removeObjectAtIndex": {
				"!type": "fn(index: number) -> void"
			},
			"exchangeObjectAtIndexWithObjectAtIndex": {
				"!type": "fn(idx1: number, idx2: number) -> void"
			},
			"insertObjectAtIndex": {
				"!type": "fn(anObject: +Object, index: number) -> void"
			},
			"applyDifference": {
				"!type": "fn(difference: +NSOrderedCollectionDifference) -> void"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSMutableArray"
			},
			"initWithCapacity": {
				"!type": "fn(numItems: number) -> +NSMutableArray"
			},
			"replaceObjectsAtIndexesWithObjects": {
				"!type": "fn(indexes: +NSIndexSet, objects: +Array) -> void"
			},
			"initWithContentsOfURL": {
				"!type": "fn(url: +NSURL) -> +NSMutableArray"
			},
			"setArray": {
				"!type": "fn(otherArray: +Array) -> void"
			},
			"removeObjectsInArray": {
				"!type": "fn(otherArray: +Array) -> void"
			},
			"sortUsingFunctionContext": {
				"!type": "fn(compare: +Object, context: +Object) -> void"
			},
			"sortWithOptionsUsingComparator": {
				"!type": "fn(opts: number, cmptr: +Function) -> void"
			},
			"removeAllObjects": {
				"!type": "fn() -> void"
			},
			"insertObjectsAtIndexes": {
				"!type": "fn(objects: +Array, indexes: +NSIndexSet) -> void"
			},
			"replaceObjectAtIndexWithObject": {
				"!type": "fn(index: number, anObject: +Object) -> void"
			},
			"replaceObjectsInRangeWithObjectsFromArrayRange": {
				"!type": "fn(range: +Object, otherArray: +Array, otherRange: +Object) -> void"
			},
			"filterUsingPredicate": {
				"!type": "fn(predicate: +NSPredicate) -> void"
			},
			"initWithContentsOfFile": {
				"!type": "fn(path: string) -> +NSMutableArray"
			},
			"removeObjectsInRange": {
				"!type": "fn(range: +Object) -> void"
			},
			"replaceObjectsInRangeWithObjectsFromArray": {
				"!type": "fn(range: +Object, otherArray: +Array) -> void"
			},
			"setObjectAtIndexedSubscript": {
				"!type": "fn(obj: +Object, idx: number) -> void"
			},
			"removeObjectInRange": {
				"!type": "fn(anObject: +Object, range: +Object) -> void"
			},
			"removeObjectIdenticalTo": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"addObject": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"sortUsingDescriptors": {
				"!type": "fn(sortDescriptors: +Array) -> void"
			},
			"removeObjectsFromIndicesNumIndices": {
				"!type": "fn(indices: +Object, cnt: number) -> void"
			},
			"addObjectsFromArray": {
				"!type": "fn(otherArray: +Array) -> void"
			},
			"removeObjectsAtIndexes": {
				"!type": "fn(indexes: +NSIndexSet) -> void"
			},
			"sortUsingSelector": {
				"!type": "fn(comparator: string) -> void"
			},
			"removeObject": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableArray"
			},
			"removeLastObject": {
				"!type": "fn() -> void"
			},
			"removeObjectIdenticalToInRange": {
				"!type": "fn(anObject: +Object, range: +Object) -> void"
			},
			"sortUsingComparator": {
				"!type": "fn(cmptr: +Function) -> void"
			},
			"filteredArrayUsingPredicate": {
				"!type": "fn(predicate: +NSPredicate) -> +Array"
			},
			"initWithObjectsCount": {
				"!type": "fn(objects: +Object, cnt: number) -> +NSMutableArray"
			},
			"sortedArrayUsingFunctionContext": {
				"!type": "fn(comparator: +Object, context: +Object) -> +Array"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"sortedArrayUsingComparator": {
				"!type": "fn(cmptr: +Function) -> +Array"
			},
			"sortedArrayUsingDescriptors": {
				"!type": "fn(sortDescriptors: +Array) -> +Array"
			},
			"removeObserverFromObjectsAtIndexesForKeyPathContext": {
				"!type": "fn(observer: +NSObject, indexes: +NSIndexSet, keyPath: string, context: +Object) -> void"
			},
			"indexesOfObjectsWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> +NSIndexSet"
			},
			"containsObject": {
				"!type": "fn(anObject: +Object) -> bool"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"componentsJoinedByString": {
				"!type": "fn(separator: string) -> string"
			},
			"arrayByAddingObjectsFromArray": {
				"!type": "fn(otherArray: +Array) -> +Array"
			},
			"arrayByApplyingDifference": {
				"!type": "fn(difference: +NSOrderedCollectionDifference) -> +Array"
			},
			"initWithContentsOfURLError": {
				"!type": "fn(url: +NSURL, error: +Object) -> +Array"
			},
			"initWithContentsOfFile": {
				"!type": "fn(path: string) -> +Array"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"arrayByAddingObject": {
				"!type": "fn(anObject: +Object) -> +Array"
			},
			"initWithArrayCopyItems": {
				"!type": "fn(array: +Array, flag: bool) -> +NSMutableArray"
			},
			"reverseObjectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"indexOfObjectIdenticalTo": {
				"!type": "fn(anObject: +Object) -> number"
			},
			"enumerateObjectsUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"sortedArrayWithOptionsUsingComparator": {
				"!type": "fn(opts: number, cmptr: +Function) -> +Array"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"sortedArrayUsingFunctionContextHint": {
				"!type": "fn(comparator: +Object, context: +Object, hint: +NSData) -> +Array"
			},
			"objectAtIndexedSubscript": {
				"!type": "fn(idx: number) -> +Object"
			},
			"writeToURLAtomically": {
				"!type": "fn(url: +NSURL, atomically: bool) -> bool"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableArray"
			},
			"addObserverToObjectsAtIndexesForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, indexes: +NSIndexSet, keyPath: string, options: number, context: +Object) -> void"
			},
			"enumerateObjectsWithOptionsUsingBlock": {
				"!type": "fn(opts: number, block: +Function) -> void"
			},
			"isEqualToArray": {
				"!type": "fn(otherArray: +Array) -> bool"
			},
			"firstObjectCommonWithArray": {
				"!type": "fn(otherArray: +Array) -> +Object"
			},
			"indexOfObjectInSortedRangeOptionsUsingComparator": {
				"!type": "fn(obj: +Object, r: +Object, opts: number, cmp: +Function) -> number"
			},
			"objectsAtIndexes": {
				"!type": "fn(indexes: +NSIndexSet) -> +Array"
			},
			"initWithArray": {
				"!type": "fn(array: +Array) -> +NSMutableArray"
			},
			"indexOfObjectWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> number"
			},
			"enumerateObjectsAtIndexesOptionsUsingBlock": {
				"!type": "fn(s: +NSIndexSet, opts: number, block: +Function) -> void"
			},
			"indexesOfObjectsPassingTest": {
				"!type": "fn(predicate: +Function) -> +NSIndexSet"
			},
			"differenceFromArray": {
				"!type": "fn(other: +Array) -> +NSOrderedCollectionDifference"
			},
			"descriptionWithLocale": {
				"!type": "fn(locale: +Object) -> string"
			},
			"indexOfObjectPassingTest": {
				"!type": "fn(predicate: +Function) -> number"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSMutableArray"
			},
			"indexesOfObjectsAtIndexesOptionsPassingTest": {
				"!type": "fn(s: +NSIndexSet, opts: number, predicate: +Function) -> +NSIndexSet"
			},
			"initWithContentsOfURL": {
				"!type": "fn(url: +NSURL) -> +Array"
			},
			"makeObjectsPerformSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"initWithObjects": {
				"!type": "fn(firstObj: +Object, args: Array.prototype) -> +NSMutableArray"
			},
			"writeToURLError": {
				"!type": "fn(url: +NSURL, error: +Object) -> bool"
			},
			"objectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"getObjects": {
				"!type": "fn(objects: +Object) -> void"
			},
			"differenceFromArrayWithOptions": {
				"!type": "fn(other: +Array, options: number) -> +NSOrderedCollectionDifference"
			},
			"indexOfObjectInRange": {
				"!type": "fn(anObject: +Object, range: +Object) -> number"
			},
			"objectAtIndex": {
				"!type": "fn(index: number) -> +Object"
			},
			"indexOfObject": {
				"!type": "fn(anObject: +Object) -> number"
			},
			"subarrayWithRange": {
				"!type": "fn(range: +Object) -> +Array"
			},
			"indexOfObjectAtIndexesOptionsPassingTest": {
				"!type": "fn(s: +NSIndexSet, opts: number, predicate: +Function) -> number"
			},
			"sortedArrayUsingSelector": {
				"!type": "fn(comparator: string) -> +Array"
			},
			"indexOfObjectIdenticalToInRange": {
				"!type": "fn(anObject: +Object, range: +Object) -> number"
			},
			"pathsMatchingExtensions": {
				"!type": "fn(filterTypes: +Array) -> +Array"
			},
			"writeToFileAtomically": {
				"!type": "fn(path: string, useAuxiliaryFile: bool) -> bool"
			},
			"descriptionWithLocaleIndent": {
				"!type": "fn(locale: +Object, level: number) -> string"
			},
			"differenceFromArrayWithOptionsUsingEquivalenceTest": {
				"!type": "fn(other: +Array, options: number, block: +Function) -> +NSOrderedCollectionDifference"
			},
			"getObjectsRange": {
				"!type": "fn(objects: +Object, range: +Object) -> void"
			},
			"removeObserverFromObjectsAtIndexesForKeyPath": {
				"!type": "fn(observer: +NSObject, indexes: +NSIndexSet, keyPath: string) -> void"
			},
			"makeObjectsPerformSelectorWithObject": {
				"!type": "fn(aSelector: string, argument: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableArray"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVDateRangeMetadataGroup": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVDateRangeMetadataGroup"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVDateRangeMetadataGroup"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVDateRangeMetadataGroup"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"startDate": {
				"!type": "+Date"
			},
			"endDate": {
				"!type": "+Date"
			},
			"items": {
				"!type": "+Array"
			},
			"items": {
				"!type": "+Array"
			},
			"classifyingLabel": {
				"!type": "string"
			},
			"uniqueID": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithItemsStartDateEndDate": {
				"!type": "fn(items: +Array, startDate: +Date, endDate: +Date) -> +AVDateRangeMetadataGroup"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVDateRangeMetadataGroup"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerItemMetadataCollector": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerItemMetadataCollector"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerItemMetadataCollector"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerItemMetadataCollector"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"delegate": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithIdentifiersClassifyingLabels": {
				"!type": "fn(identifiers: +Array, classifyingLabels: +Array) -> +AVPlayerItemMetadataCollector"
			},
			"setDelegateQueue": {
				"!type": "fn(delegate: +Object, delegateQueue: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerItemMetadataCollector"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMassFormatter": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMassFormatter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMassFormatter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMassFormatter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"unitStyle": {
				"!type": "number"
			},
			"numberFormatter": {
				"!type": "+NSNumberFormatter"
			},
			"forPersonMassUse": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"unitStringFromKilogramsUsedUnit": {
				"!type": "fn(numberInKilograms: number, unitp: +Object) -> string"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringFromKilograms": {
				"!type": "fn(numberInKilograms: number) -> string"
			},
			"unitStringFromValueUnit": {
				"!type": "fn(value: number, unit: number) -> string"
			},
			"stringFromValueUnit": {
				"!type": "fn(value: number, unit: number) -> string"
			},
			"editingStringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription": {
				"!type": "fn(partialStringPtr: +Object, proposedSelRangePtr: +Object, origString: string, origSelRange: +Object, error: +Object) -> bool"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"attributedStringForObjectValueWithDefaultAttributes": {
				"!type": "fn(obj: +Object, attrs: +Object) -> +NSAttributedString"
			},
			"isPartialStringValidNewEditingStringErrorDescription": {
				"!type": "fn(partialString: string, newString: +Object, error: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMassFormatter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSOperationQueue": {
		"mainQueue": {
			"!type": "fn() -> +NSOperationQueue"
		},
		"currentQueue": {
			"!type": "fn() -> +NSOperationQueue"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSOperationQueue"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSOperationQueue"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSOperationQueue"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"operations": {
				"!type": "+Array"
			},
			"name": {
				"!type": "string"
			},
			"qualityOfService": {
				"!type": "number"
			},
			"operationCount": {
				"!type": "number"
			},
			"suspended": {
				"!type": "bool"
			},
			"progress": {
				"!type": "+NSProgress"
			},
			"maxConcurrentOperationCount": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"cancelAllOperations": {
				"!type": "fn() -> void"
			},
			"waitUntilAllOperationsAreFinished": {
				"!type": "fn() -> void"
			},
			"addOperationWithBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"addOperation": {
				"!type": "fn(op: +NSOperation) -> void"
			},
			"addOperationsWaitUntilFinished": {
				"!type": "fn(ops: +Array, wait: bool) -> void"
			},
			"addBarrierBlock": {
				"!type": "fn(barrier: +Function) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSOperationQueue"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureResolvedPhotoSettings": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureResolvedPhotoSettings"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureResolvedPhotoSettings"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureResolvedPhotoSettings"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"portraitEffectsMatteDimensions": {
				"!type": "+Object"
			},
			"flashEnabled": {
				"!type": "bool"
			},
			"photoDimensions": {
				"!type": "+Object"
			},
			"dualCameraFusionEnabled": {
				"!type": "bool"
			},
			"livePhotoMovieDimensions": {
				"!type": "+Object"
			},
			"photoProcessingTimeRange": {
				"!type": "+Object"
			},
			"previewDimensions": {
				"!type": "+Object"
			},
			"expectedPhotoCount": {
				"!type": "number"
			},
			"virtualDeviceFusionEnabled": {
				"!type": "bool"
			},
			"rawPhotoDimensions": {
				"!type": "+Object"
			},
			"redEyeReductionEnabled": {
				"!type": "bool"
			},
			"rawEmbeddedThumbnailDimensions": {
				"!type": "+Object"
			},
			"embeddedThumbnailDimensions": {
				"!type": "+Object"
			},
			"uniqueID": {
				"!type": "number"
			},
			"stillImageStabilizationEnabled": {
				"!type": "bool"
			},
			"contentAwareDistortionCorrectionEnabled": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"dimensionsForSemanticSegmentationMatteOfType": {
				"!type": "fn(semanticSegmentationMatteType: string) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureResolvedPhotoSettings"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSValueTransformer": {
		"allowsReverseTransformation": {
			"!type": "fn() -> bool"
		},
		"valueTransformerNames": {
			"!type": "fn() -> +Array"
		},
		"valueTransformerForName": {
			"!type": "fn(name: string) -> +NSValueTransformer"
		},
		"transformedValueClass": {
			"!type": "fn() -> +Object"
		},
		"setValueTransformerForName": {
			"!type": "fn(transformer: +NSValueTransformer, name: string) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSValueTransformer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSValueTransformer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSValueTransformer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"transformedValue": {
				"!type": "fn(value: +Object) -> +Object"
			},
			"reverseTransformedValue": {
				"!type": "fn(value: +Object) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSValueTransformer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitIlluminance": {
		"lux": {
			"!type": "fn() -> +NSUnitIlluminance"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitIlluminance"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitIlluminance"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitIlluminance"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitIlluminance"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitIlluminance"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitIlluminance"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitIlluminance"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSRecursiveLock": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSRecursiveLock"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSRecursiveLock"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSRecursiveLock"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"name": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"lockBeforeDate": {
				"!type": "fn(limit: +Date) -> bool"
			},
			"tryLock": {
				"!type": "fn() -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSRecursiveLock"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAsset": {
		"assetWithURL": {
			"!type": "fn(URL: +NSURL) -> +AVAsset"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAsset"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAsset"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAsset"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"creationDate": {
				"!type": "+AVMetadataItem"
			},
			"referenceRestrictions": {
				"!type": "number"
			},
			"canContainFragments": {
				"!type": "bool"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"preferredRate": {
				"!type": "number"
			},
			"composable": {
				"!type": "bool"
			},
			"tracks": {
				"!type": "+Array"
			},
			"containsFragments": {
				"!type": "bool"
			},
			"availableMediaCharacteristicsWithMediaSelectionOptions": {
				"!type": "+Array"
			},
			"preferredMediaSelection": {
				"!type": "+AVMediaSelection"
			},
			"duration": {
				"!type": "+Object"
			},
			"providesPreciseDurationAndTiming": {
				"!type": "bool"
			},
			"compatibleWithAirPlayVideo": {
				"!type": "bool"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"exportable": {
				"!type": "bool"
			},
			"lyrics": {
				"!type": "string"
			},
			"trackGroups": {
				"!type": "+Array"
			},
			"compatibleWithSavedPhotosAlbum": {
				"!type": "bool"
			},
			"readable": {
				"!type": "bool"
			},
			"hasProtectedContent": {
				"!type": "bool"
			},
			"overallDurationHint": {
				"!type": "+Object"
			},
			"availableChapterLocales": {
				"!type": "+Array"
			},
			"minimumTimeOffsetFromLive": {
				"!type": "+Object"
			},
			"allMediaSelections": {
				"!type": "+Array"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"unusedTrackID": {
				"!type": "fn() -> number"
			},
			"chapterMetadataGroupsWithTitleLocaleContainingItemsWithCommonKeys": {
				"!type": "fn(locale: +NSLocale, commonKeys: +Array) -> +Array"
			},
			"cancelLoading": {
				"!type": "fn() -> void"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVAssetTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"mediaSelectionGroupForMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +AVMediaSelectionGroup"
			},
			"chapterMetadataGroupsBestMatchingPreferredLanguages": {
				"!type": "fn(preferredLanguages: +Array) -> +Array"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAsset"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUndoManager": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUndoManager"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUndoManager"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUndoManager"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"undoing": {
				"!type": "bool"
			},
			"groupingLevel": {
				"!type": "number"
			},
			"undoActionName": {
				"!type": "string"
			},
			"undoMenuItemTitle": {
				"!type": "string"
			},
			"canUndo": {
				"!type": "bool"
			},
			"runLoopModes": {
				"!type": "+Array"
			},
			"levelsOfUndo": {
				"!type": "number"
			},
			"redoing": {
				"!type": "bool"
			},
			"groupsByEvent": {
				"!type": "bool"
			},
			"undoActionIsDiscardable": {
				"!type": "bool"
			},
			"undoRegistrationEnabled": {
				"!type": "bool"
			},
			"redoMenuItemTitle": {
				"!type": "string"
			},
			"canRedo": {
				"!type": "bool"
			},
			"redoActionName": {
				"!type": "string"
			},
			"redoActionIsDiscardable": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"undoMenuTitleForUndoActionName": {
				"!type": "fn(actionName: string) -> string"
			},
			"beginUndoGrouping": {
				"!type": "fn() -> void"
			},
			"undoNestedGroup": {
				"!type": "fn() -> void"
			},
			"redo": {
				"!type": "fn() -> void"
			},
			"setActionIsDiscardable": {
				"!type": "fn(discardable: bool) -> void"
			},
			"redoMenuTitleForUndoActionName": {
				"!type": "fn(actionName: string) -> string"
			},
			"registerUndoWithTargetHandler": {
				"!type": "fn(target: +Object, undoHandler: +Function) -> void"
			},
			"removeAllActions": {
				"!type": "fn() -> void"
			},
			"undo": {
				"!type": "fn() -> void"
			},
			"prepareWithInvocationTarget": {
				"!type": "fn(target: +Object) -> +Object"
			},
			"setActionName": {
				"!type": "fn(actionName: string) -> void"
			},
			"disableUndoRegistration": {
				"!type": "fn() -> void"
			},
			"endUndoGrouping": {
				"!type": "fn() -> void"
			},
			"registerUndoWithTargetSelectorObject": {
				"!type": "fn(target: +Object, selector: string, anObject: +Object) -> void"
			},
			"enableUndoRegistration": {
				"!type": "fn() -> void"
			},
			"removeAllActionsWithTarget": {
				"!type": "fn(target: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUndoManager"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnitSampler": {
		"instantiateWithComponentDescriptionOptionsCompletionHandler": {
			"!type": "fn(audioComponentDescription: +Object, options: number, completionHandler: +Function) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnitSampler"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnitSampler"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnitSampler"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"stereoPan": {
				"!type": "number"
			},
			"masterGain": {
				"!type": "number"
			},
			"globalTuning": {
				"!type": "number"
			},
			"name": {
				"!type": "string"
			},
			"audioComponentDescription": {
				"!type": "+Object"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"version": {
				"!type": "number"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"loadSoundBankInstrumentAtURLProgramBankMSBBankLSBError": {
				"!type": "fn(bankURL: +NSURL, program: number, bankMSB: number, bankLSB: number, outError: +Object) -> bool"
			},
			"loadAudioFilesAtURLsError": {
				"!type": "fn(audioFiles: +Array, outError: +Object) -> bool"
			},
			"loadInstrumentAtURLError": {
				"!type": "fn(instrumentURL: +NSURL, outError: +Object) -> bool"
			},
			"sendMIDIEventData1": {
				"!type": "fn(midiStatus: number, data1: number) -> void"
			},
			"sendPitchBendOnChannel": {
				"!type": "fn(pitchbend: number, channel: number) -> void"
			},
			"sendProgramChangeBankMSBBankLSBOnChannel": {
				"!type": "fn(program: number, bankMSB: number, bankLSB: number, channel: number) -> void"
			},
			"sendPressureForKeyWithValueOnChannel": {
				"!type": "fn(key: number, value: number, channel: number) -> void"
			},
			"startNoteWithVelocityOnChannel": {
				"!type": "fn(note: number, velocity: number, channel: number) -> void"
			},
			"sendControllerWithValueOnChannel": {
				"!type": "fn(controller: number, value: number, channel: number) -> void"
			},
			"sendMIDIEventData1Data2": {
				"!type": "fn(midiStatus: number, data1: number, data2: number) -> void"
			},
			"sendPressureOnChannel": {
				"!type": "fn(pressure: number, channel: number) -> void"
			},
			"stopNoteOnChannel": {
				"!type": "fn(note: number, channel: number) -> void"
			},
			"sendProgramChangeOnChannel": {
				"!type": "fn(program: number, channel: number) -> void"
			},
			"initWithAudioComponentDescription": {
				"!type": "fn(description: +Object) -> +AVAudioUnitSampler"
			},
			"sendMIDISysExEvent": {
				"!type": "fn(midiData: +NSData) -> void"
			},
			"loadAudioUnitPresetAtURLError": {
				"!type": "fn(url: +NSURL, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnitSampler"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSItemProvider": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSItemProvider"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSItemProvider"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSItemProvider"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"registeredTypeIdentifiers": {
				"!type": "+Array"
			},
			"suggestedName": {
				"!type": "string"
			},
			"jspreviewImageHandler": {
				"!type": "+Function"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithItemTypeIdentifier": {
				"!type": "fn(item: +Object, typeIdentifier: string) -> +NSItemProvider"
			},
			"hasItemConformingToTypeIdentifier": {
				"!type": "fn(typeIdentifier: string) -> bool"
			},
			"registerObjectVisibility": {
				"!type": "fn(object: +Object, visibility: number) -> void"
			},
			"canLoadObjectOfClass": {
				"!type": "fn(aClass: +Object) -> bool"
			},
			"registerFileRepresentationForTypeIdentifierFileOptionsVisibilityLoadHandler": {
				"!type": "fn(typeIdentifier: string, fileOptions: number, visibility: number, loadHandler: +Function) -> void"
			},
			"registerItemForTypeIdentifierLoadHandler": {
				"!type": "fn(typeIdentifier: string, loadHandler: +Function) -> void"
			},
			"registerObjectOfClassVisibilityLoadHandler": {
				"!type": "fn(aClass: +Object, visibility: number, loadHandler: +Function) -> void"
			},
			"registerDataRepresentationForTypeIdentifierVisibilityLoadHandler": {
				"!type": "fn(typeIdentifier: string, visibility: number, loadHandler: +Function) -> void"
			},
			"initWithContentsOfURL": {
				"!type": "fn(fileURL: +NSURL) -> +NSItemProvider"
			},
			"loadPreviewImageWithOptionsCompletionHandler": {
				"!type": "fn(options: +Object, completionHandler: +Function) -> void"
			},
			"loadItemForTypeIdentifierOptionsCompletionHandler": {
				"!type": "fn(typeIdentifier: string, options: +Object, completionHandler: +Function) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSItemProvider"
			},
			"loadObjectOfClassCompletionHandler": {
				"!type": "fn(aClass: +Object, completionHandler: +Function) -> +NSProgress"
			},
			"loadFileRepresentationForTypeIdentifierCompletionHandler": {
				"!type": "fn(typeIdentifier: string, completionHandler: +Function) -> +NSProgress"
			},
			"initWithObject": {
				"!type": "fn(object: +Object) -> +NSItemProvider"
			},
			"hasRepresentationConformingToTypeIdentifierFileOptions": {
				"!type": "fn(typeIdentifier: string, fileOptions: number) -> bool"
			},
			"registeredTypeIdentifiersWithFileOptions": {
				"!type": "fn(fileOptions: number) -> +Array"
			},
			"loadInPlaceFileRepresentationForTypeIdentifierCompletionHandler": {
				"!type": "fn(typeIdentifier: string, completionHandler: +Function) -> +NSProgress"
			},
			"loadDataRepresentationForTypeIdentifierCompletionHandler": {
				"!type": "fn(typeIdentifier: string, completionHandler: +Function) -> +NSProgress"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSItemProvider"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureBracketedStillImageSettings": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureBracketedStillImageSettings"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureBracketedStillImageSettings"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureBracketedStillImageSettings"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureBracketedStillImageSettings"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVFragmentedMovie": {
		"movieWithDataOptions": {
			"!type": "fn(data: +NSData, options: +Object) -> +AVFragmentedMovie"
		},
		"movieWithURLOptions": {
			"!type": "fn(URL: +NSURL, options: +Object) -> +AVFragmentedMovie"
		},
		"movieTypes": {
			"!type": "fn() -> +Array"
		},
		"assetWithURL": {
			"!type": "fn(URL: +NSURL) -> +AVFragmentedMovie"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVFragmentedMovie"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVFragmentedMovie"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVFragmentedMovie"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"tracks": {
				"!type": "+Array"
			},
			"defaultMediaDataStorage": {
				"!type": "+AVMediaDataStorage"
			},
			"URL": {
				"!type": "+NSURL"
			},
			"containsMovieFragments": {
				"!type": "bool"
			},
			"tracks": {
				"!type": "+Array"
			},
			"data": {
				"!type": "+NSData"
			},
			"canContainMovieFragments": {
				"!type": "bool"
			},
			"creationDate": {
				"!type": "+AVMetadataItem"
			},
			"referenceRestrictions": {
				"!type": "number"
			},
			"canContainFragments": {
				"!type": "bool"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"preferredRate": {
				"!type": "number"
			},
			"composable": {
				"!type": "bool"
			},
			"tracks": {
				"!type": "+Array"
			},
			"containsFragments": {
				"!type": "bool"
			},
			"availableMediaCharacteristicsWithMediaSelectionOptions": {
				"!type": "+Array"
			},
			"preferredMediaSelection": {
				"!type": "+AVMediaSelection"
			},
			"duration": {
				"!type": "+Object"
			},
			"providesPreciseDurationAndTiming": {
				"!type": "bool"
			},
			"compatibleWithAirPlayVideo": {
				"!type": "bool"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"exportable": {
				"!type": "bool"
			},
			"lyrics": {
				"!type": "string"
			},
			"trackGroups": {
				"!type": "+Array"
			},
			"compatibleWithSavedPhotosAlbum": {
				"!type": "bool"
			},
			"readable": {
				"!type": "bool"
			},
			"hasProtectedContent": {
				"!type": "bool"
			},
			"overallDurationHint": {
				"!type": "+Object"
			},
			"availableChapterLocales": {
				"!type": "+Array"
			},
			"minimumTimeOffsetFromLive": {
				"!type": "+Object"
			},
			"allMediaSelections": {
				"!type": "+Array"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVFragmentedMovieTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"initWithURLOptions": {
				"!type": "fn(URL: +NSURL, options: +Object) -> +AVFragmentedMovie"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVMovieTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"initWithDataOptions": {
				"!type": "fn(data: +NSData, options: +Object) -> +AVFragmentedMovie"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"writeMovieHeaderToURLFileTypeOptionsError": {
				"!type": "fn(URL: +NSURL, fileType: string, options: number, outError: +Object) -> bool"
			},
			"movieHeaderWithFileTypeError": {
				"!type": "fn(fileType: string, outError: +Object) -> +NSData"
			},
			"isCompatibleWithFileType": {
				"!type": "fn(fileType: string) -> bool"
			},
			"unusedTrackID": {
				"!type": "fn() -> number"
			},
			"chapterMetadataGroupsWithTitleLocaleContainingItemsWithCommonKeys": {
				"!type": "fn(locale: +NSLocale, commonKeys: +Array) -> +Array"
			},
			"cancelLoading": {
				"!type": "fn() -> void"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVAssetTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"mediaSelectionGroupForMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +AVMediaSelectionGroup"
			},
			"chapterMetadataGroupsBestMatchingPreferredLanguages": {
				"!type": "fn(preferredLanguages: +Array) -> +Array"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVFragmentedMovie"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSFileCoordinator": {
		"addFilePresenter": {
			"!type": "fn(filePresenter: +Object) -> void"
		},
		"removeFilePresenter": {
			"!type": "fn(filePresenter: +Object) -> void"
		},
		"filePresenters": {
			"!type": "fn() -> +Array"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSFileCoordinator"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSFileCoordinator"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSFileCoordinator"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"purposeIdentifier": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"coordinateReadingItemAtURLOptionsErrorByAccessor": {
				"!type": "fn(url: +NSURL, options: number, outError: +Object, reader: +Function) -> void"
			},
			"coordinateAccessWithIntentsQueueByAccessor": {
				"!type": "fn(intents: +Array, queue: +NSOperationQueue, accessor: +Function) -> void"
			},
			"initWithFilePresenter": {
				"!type": "fn(filePresenterOrNil: +Object) -> +NSFileCoordinator"
			},
			"coordinateReadingItemAtURLOptionsWritingItemAtURLOptionsErrorByAccessor": {
				"!type": "fn(readingURL: +NSURL, readingOptions: number, writingURL: +NSURL, writingOptions: number, outError: +Object, readerWriter: +Function) -> void"
			},
			"itemAtURLDidChangeUbiquityAttributes": {
				"!type": "fn(url: +NSURL, attributes: +NSSet) -> void"
			},
			"itemAtURLDidMoveToURL": {
				"!type": "fn(oldURL: +NSURL, newURL: +NSURL) -> void"
			},
			"itemAtURLWillMoveToURL": {
				"!type": "fn(oldURL: +NSURL, newURL: +NSURL) -> void"
			},
			"coordinateWritingItemAtURLOptionsErrorByAccessor": {
				"!type": "fn(url: +NSURL, options: number, outError: +Object, writer: +Function) -> void"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"coordinateWritingItemAtURLOptionsWritingItemAtURLOptionsErrorByAccessor": {
				"!type": "fn(url1: +NSURL, options1: number, url2: +NSURL, options2: number, outError: +Object, writer: +Function) -> void"
			},
			"prepareForReadingItemsAtURLsOptionsWritingItemsAtURLsOptionsErrorByAccessor": {
				"!type": "fn(readingURLs: +Array, readingOptions: number, writingURLs: +Array, writingOptions: number, outError: +Object, batchAccessor: +Function) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSFileCoordinator"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSFileHandle": {
		"fileHandleForReadingFromURLError": {
			"!type": "fn(url: +NSURL, error: +Object) -> +NSFileHandle"
		},
		"fileHandleForUpdatingAtPath": {
			"!type": "fn(path: string) -> +NSFileHandle"
		},
		"fileHandleWithStandardOutput": {
			"!type": "fn() -> +NSFileHandle"
		},
		"fileHandleForWritingToURLError": {
			"!type": "fn(url: +NSURL, error: +Object) -> +NSFileHandle"
		},
		"fileHandleForUpdatingURLError": {
			"!type": "fn(url: +NSURL, error: +Object) -> +NSFileHandle"
		},
		"fileHandleForWritingAtPath": {
			"!type": "fn(path: string) -> +NSFileHandle"
		},
		"fileHandleWithStandardError": {
			"!type": "fn() -> +NSFileHandle"
		},
		"fileHandleWithNullDevice": {
			"!type": "fn() -> +NSFileHandle"
		},
		"fileHandleWithStandardInput": {
			"!type": "fn() -> +NSFileHandle"
		},
		"fileHandleForReadingAtPath": {
			"!type": "fn(path: string) -> +NSFileHandle"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSFileHandle"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSFileHandle"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSFileHandle"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jswriteabilityHandler": {
				"!type": "+Function"
			},
			"jsreadabilityHandler": {
				"!type": "+Function"
			},
			"availableData": {
				"!type": "+NSData"
			},
			"offsetInFile": {
				"!type": "number"
			},
			"fileDescriptor": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"synchronizeAndReturnError": {
				"!type": "fn(error: +Object) -> bool"
			},
			"readToEndOfFileInBackgroundAndNotify": {
				"!type": "fn() -> void"
			},
			"seekToOffsetError": {
				"!type": "fn(offset: number, error: +Object) -> bool"
			},
			"initWithFileDescriptor": {
				"!type": "fn(fd: number) -> +NSFileHandle"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSFileHandle"
			},
			"initWithFileDescriptorCloseOnDealloc": {
				"!type": "fn(fd: number, closeopt: bool) -> +NSFileHandle"
			},
			"seekToFileOffset": {
				"!type": "fn(offset: number) -> void"
			},
			"closeAndReturnError": {
				"!type": "fn(error: +Object) -> bool"
			},
			"getOffsetError": {
				"!type": "fn(offsetInFile: +Object, error: +Object) -> bool"
			},
			"waitForDataInBackgroundAndNotifyForModes": {
				"!type": "fn(modes: +Array) -> void"
			},
			"writeData": {
				"!type": "fn(data: +NSData) -> void"
			},
			"truncateFileAtOffset": {
				"!type": "fn(offset: number) -> void"
			},
			"acceptConnectionInBackgroundAndNotify": {
				"!type": "fn() -> void"
			},
			"seekToEndOfFile": {
				"!type": "fn() -> number"
			},
			"readDataToEndOfFileAndReturnError": {
				"!type": "fn(error: +Object) -> +NSData"
			},
			"readDataToEndOfFile": {
				"!type": "fn() -> +NSData"
			},
			"readDataOfLength": {
				"!type": "fn(length: number) -> +NSData"
			},
			"readDataUpToLengthError": {
				"!type": "fn(length: number, error: +Object) -> +NSData"
			},
			"acceptConnectionInBackgroundAndNotifyForModes": {
				"!type": "fn(modes: +Array) -> void"
			},
			"readInBackgroundAndNotifyForModes": {
				"!type": "fn(modes: +Array) -> void"
			},
			"writeDataError": {
				"!type": "fn(data: +NSData, error: +Object) -> bool"
			},
			"readToEndOfFileInBackgroundAndNotifyForModes": {
				"!type": "fn(modes: +Array) -> void"
			},
			"truncateAtOffsetError": {
				"!type": "fn(offset: number, error: +Object) -> bool"
			},
			"synchronizeFile": {
				"!type": "fn() -> void"
			},
			"waitForDataInBackgroundAndNotify": {
				"!type": "fn() -> void"
			},
			"readInBackgroundAndNotify": {
				"!type": "fn() -> void"
			},
			"seekToEndReturningOffsetError": {
				"!type": "fn(offsetInFile: +Object, error: +Object) -> bool"
			},
			"closeFile": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSFileHandle"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSConditionLock": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSConditionLock"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSConditionLock"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSConditionLock"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"name": {
				"!type": "string"
			},
			"condition": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"lockWhenCondition": {
				"!type": "fn(condition: number) -> void"
			},
			"lockWhenConditionBeforeDate": {
				"!type": "fn(condition: number, limit: +Date) -> bool"
			},
			"lockBeforeDate": {
				"!type": "fn(limit: +Date) -> bool"
			},
			"initWithCondition": {
				"!type": "fn(condition: number) -> +NSConditionLock"
			},
			"tryLock": {
				"!type": "fn() -> bool"
			},
			"tryLockWhenCondition": {
				"!type": "fn(condition: number) -> bool"
			},
			"unlockWithCondition": {
				"!type": "fn(condition: number) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSConditionLock"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSPersonNameComponents": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSPersonNameComponents"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSPersonNameComponents"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSPersonNameComponents"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"phoneticRepresentation": {
				"!type": "+NSPersonNameComponents"
			},
			"middleName": {
				"!type": "string"
			},
			"familyName": {
				"!type": "string"
			},
			"nameSuffix": {
				"!type": "string"
			},
			"namePrefix": {
				"!type": "string"
			},
			"givenName": {
				"!type": "string"
			},
			"nickname": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSPersonNameComponents"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAggregateAssetDownloadTask": {
		"jsnew": {
			"!type": "fn() -> +AVAggregateAssetDownloadTask"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAggregateAssetDownloadTask"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAggregateAssetDownloadTask"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAggregateAssetDownloadTask"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"URLAsset": {
				"!type": "+AVURLAsset"
			},
			"countOfBytesSent": {
				"!type": "number"
			},
			"earliestBeginDate": {
				"!type": "+Date"
			},
			"countOfBytesExpectedToReceive": {
				"!type": "number"
			},
			"taskDescription": {
				"!type": "string"
			},
			"countOfBytesExpectedToSend": {
				"!type": "number"
			},
			"state": {
				"!type": "number"
			},
			"priority": {
				"!type": "number"
			},
			"countOfBytesClientExpectsToSend": {
				"!type": "number"
			},
			"taskIdentifier": {
				"!type": "number"
			},
			"countOfBytesReceived": {
				"!type": "number"
			},
			"error": {
				"!type": "+NSError"
			},
			"currentRequest": {
				"!type": "+NSURLRequest"
			},
			"progress": {
				"!type": "+NSProgress"
			},
			"countOfBytesClientExpectsToReceive": {
				"!type": "number"
			},
			"response": {
				"!type": "+NSURLResponse"
			},
			"originalRequest": {
				"!type": "+NSURLRequest"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"suspend": {
				"!type": "fn() -> void"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"resume": {
				"!type": "fn() -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAggregateAssetDownloadTask"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAggregateAssetDownloadTask"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioPlayerNode": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioPlayerNode"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioPlayerNode"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioPlayerNode"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"playing": {
				"!type": "bool"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"nodeTimeForPlayerTime": {
				"!type": "fn(playerTime: +AVAudioTime) -> +AVAudioTime"
			},
			"play": {
				"!type": "fn() -> void"
			},
			"pause": {
				"!type": "fn() -> void"
			},
			"scheduleSegmentStartingFrameFrameCountAtTimeCompletionHandler": {
				"!type": "fn(file: +AVAudioFile, startFrame: number, numberFrames: number, when: +AVAudioTime, completionHandler: +Function) -> void"
			},
			"playAtTime": {
				"!type": "fn(when: +AVAudioTime) -> void"
			},
			"scheduleBufferCompletionHandler": {
				"!type": "fn(buffer: +AVAudioPCMBuffer, completionHandler: +Function) -> void"
			},
			"scheduleBufferAtTimeOptionsCompletionHandler": {
				"!type": "fn(buffer: +AVAudioPCMBuffer, when: +AVAudioTime, options: number, completionHandler: +Function) -> void"
			},
			"scheduleFileAtTimeCompletionHandler": {
				"!type": "fn(file: +AVAudioFile, when: +AVAudioTime, completionHandler: +Function) -> void"
			},
			"stop": {
				"!type": "fn() -> void"
			},
			"playerTimeForNodeTime": {
				"!type": "fn(nodeTime: +AVAudioTime) -> +AVAudioTime"
			},
			"scheduleBufferCompletionCallbackTypeCompletionHandler": {
				"!type": "fn(buffer: +AVAudioPCMBuffer, callbackType: number, completionHandler: +Function) -> void"
			},
			"scheduleFileAtTimeCompletionCallbackTypeCompletionHandler": {
				"!type": "fn(file: +AVAudioFile, when: +AVAudioTime, callbackType: number, completionHandler: +Function) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioPlayerNode"
			},
			"prepareWithFrameCount": {
				"!type": "fn(frameCount: number) -> void"
			},
			"scheduleSegmentStartingFrameFrameCountAtTimeCompletionCallbackTypeCompletionHandler": {
				"!type": "fn(file: +AVAudioFile, startFrame: number, numberFrames: number, when: +AVAudioTime, callbackType: number, completionHandler: +Function) -> void"
			},
			"scheduleBufferAtTimeOptionsCompletionCallbackTypeCompletionHandler": {
				"!type": "fn(buffer: +AVAudioPCMBuffer, when: +AVAudioTime, options: number, callbackType: number, completionHandler: +Function) -> void"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioPlayerNode"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPortraitEffectsMatte": {
		"portraitEffectsMatteFromDictionaryRepresentationError": {
			"!type": "fn(imageSourceAuxDataInfoDictionary: +Object, outError: +Object) -> +AVPortraitEffectsMatte"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPortraitEffectsMatte"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPortraitEffectsMatte"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPortraitEffectsMatte"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"mattingImage": {
				"!type": "+Object"
			},
			"pixelFormatType": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"portraitEffectsMatteByReplacingPortraitEffectsMatteWithPixelBufferError": {
				"!type": "fn(pixelBuffer: +Object, outError: +Object) -> +AVPortraitEffectsMatte"
			},
			"dictionaryRepresentationForAuxiliaryDataType": {
				"!type": "fn(outAuxDataType: +Object) -> +Object"
			},
			"portraitEffectsMatteByApplyingExifOrientation": {
				"!type": "fn(exifOrientation: number) -> +AVPortraitEffectsMatte"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPortraitEffectsMatte"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSXPCCoder": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSXPCCoder"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSXPCCoder"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSXPCCoder"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"connection": {
				"!type": "+NSXPCConnection"
			},
			"userInfo": {
				"!type": "+Object"
			},
			"requiresSecureCoding": {
				"!type": "bool"
			},
			"systemVersion": {
				"!type": "number"
			},
			"error": {
				"!type": "+NSError"
			},
			"allowedClasses": {
				"!type": "+NSSet"
			},
			"decodingFailurePolicy": {
				"!type": "number"
			},
			"allowsKeyedCoding": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"decodeObjectOfClassForKey": {
				"!type": "fn(aClass: +Object, key: string) -> +Object"
			},
			"decodeDataObject": {
				"!type": "fn() -> +NSData"
			},
			"versionForClassName": {
				"!type": "fn(className: string) -> number"
			},
			"encodeBoolForKey": {
				"!type": "fn(value: bool, key: string) -> void"
			},
			"encodeConditionalObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"decodeCMTimeForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"failWithError": {
				"!type": "fn(error: +NSError) -> void"
			},
			"encodeArrayOfObjCTypeCountAt": {
				"!type": "fn(type: +Object, count: number, array: +Object) -> void"
			},
			"setObjectZone": {
				"!type": "fn(zone: +Object) -> void"
			},
			"decodeInt64ForKey": {
				"!type": "fn(key: string) -> number"
			},
			"decodeArrayOfObjectsOfClassesForKey": {
				"!type": "fn(classes: +NSSet, key: string) -> +Array"
			},
			"encodeInt64ForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeInt32ForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeValuesOfObjCTypes": {
				"!type": "fn(types: +Object, args: Array.prototype) -> void"
			},
			"encodeIntegerForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"decodeTopLevelObjectForKeyError": {
				"!type": "fn(key: string, error: +Object) -> +Object"
			},
			"decodeCMTimeRangeForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"decodeValuesOfObjCTypes": {
				"!type": "fn(types: +Object, args: Array.prototype) -> void"
			},
			"decodeValueOfObjCTypeAt": {
				"!type": "fn(type: +Object, data: +Object) -> void"
			},
			"containsValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"encodeFloatForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"objectZone": {
				"!type": "fn() -> +Object"
			},
			"decodeDoubleForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeByrefObject": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"decodeInt32ForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"decodeDictionaryWithKeysOfClassesObjectsOfClassesForKey": {
				"!type": "fn(keyClasses: +NSSet, objectClasses: +NSSet, key: string) -> +Object"
			},
			"encodeDataObject": {
				"!type": "fn(data: +NSData) -> void"
			},
			"decodeTopLevelObjectAndReturnError": {
				"!type": "fn(error: +Object) -> +Object"
			},
			"decodeFloatForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeValueOfObjCTypeAt": {
				"!type": "fn(type: +Object, addr: +Object) -> void"
			},
			"decodeObjectForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"encodeBytesLengthForKey": {
				"!type": "fn(bytes: +Object, length: number, key: string) -> void"
			},
			"decodeArrayOfObjCTypeCountAt": {
				"!type": "fn(itemType: +Object, count: number, array: +Object) -> void"
			},
			"encodeRootObject": {
				"!type": "fn(rootObject: +Object) -> void"
			},
			"decodeBoolForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"encodeBytesLength": {
				"!type": "fn(byteaddr: +Object, length: number) -> void"
			},
			"encodeCMTimeRangeForKey": {
				"!type": "fn(timeRange: +Object, key: string) -> void"
			},
			"decodeBytesWithReturnedLength": {
				"!type": "fn(lengthp: +Object) -> +Object"
			},
			"decodeIntForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeCMTimeMappingForKey": {
				"!type": "fn(timeMapping: +Object, key: string) -> void"
			},
			"decodeArrayOfObjectsOfClassForKey": {
				"!type": "fn(cls: +Object, key: string) -> +Array"
			},
			"encodeDoubleForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeCMTimeForKey": {
				"!type": "fn(time: +Object, key: string) -> void"
			},
			"decodeObjectOfClassesForKey": {
				"!type": "fn(classes: +NSSet, key: string) -> +Object"
			},
			"decodeDictionaryWithKeysOfClassObjectsOfClassForKey": {
				"!type": "fn(keyCls: +Object, objectCls: +Object, key: string) -> +Object"
			},
			"encodeIntForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"decodeCMTimeMappingForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"decodeTopLevelObjectOfClassesForKeyError": {
				"!type": "fn(classes: +NSSet, key: string, error: +Object) -> +Object"
			},
			"encodeObjectForKey": {
				"!type": "fn(object: +Object, key: string) -> void"
			},
			"decodeObject": {
				"!type": "fn() -> +Object"
			},
			"encodeBycopyObject": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"decodePropertyListForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"decodeTopLevelObjectOfClassForKeyError": {
				"!type": "fn(aClass: +Object, key: string, error: +Object) -> +Object"
			},
			"decodeIntegerForKey": {
				"!type": "fn(key: string) -> number"
			},
			"decodeValueOfObjCTypeAtSize": {
				"!type": "fn(type: +Object, data: +Object, size: number) -> void"
			},
			"decodeBytesForKeyReturnedLength": {
				"!type": "fn(key: string, lengthp: +Object) -> +Object"
			},
			"encodeConditionalObjectForKey": {
				"!type": "fn(object: +Object, key: string) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSXPCCoder"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitPressure": {
		"inchesOfMercury": {
			"!type": "fn() -> +NSUnitPressure"
		},
		"megapascals": {
			"!type": "fn() -> +NSUnitPressure"
		},
		"kilopascals": {
			"!type": "fn() -> +NSUnitPressure"
		},
		"gigapascals": {
			"!type": "fn() -> +NSUnitPressure"
		},
		"bars": {
			"!type": "fn() -> +NSUnitPressure"
		},
		"newtonsPerMetersSquared": {
			"!type": "fn() -> +NSUnitPressure"
		},
		"poundsForcePerSquareInch": {
			"!type": "fn() -> +NSUnitPressure"
		},
		"millimetersOfMercury": {
			"!type": "fn() -> +NSUnitPressure"
		},
		"hectopascals": {
			"!type": "fn() -> +NSUnitPressure"
		},
		"millibars": {
			"!type": "fn() -> +NSUnitPressure"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitPressure"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitPressure"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitPressure"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitPressure"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitPressure"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitPressure"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitPressure"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSCompoundPredicate": {
		"orPredicateWithSubpredicates": {
			"!type": "fn(subpredicates: +Array) -> +NSCompoundPredicate"
		},
		"notPredicateWithSubpredicate": {
			"!type": "fn(predicate: +NSPredicate) -> +NSCompoundPredicate"
		},
		"andPredicateWithSubpredicates": {
			"!type": "fn(subpredicates: +Array) -> +NSCompoundPredicate"
		},
		"predicateWithFormatArguments": {
			"!type": "fn(predicateFormat: string, argList: +Object) -> +NSPredicate"
		},
		"predicateWithFormat": {
			"!type": "fn(predicateFormat: string, args: Array.prototype) -> +NSPredicate"
		},
		"predicateWithValue": {
			"!type": "fn(value: bool) -> +NSPredicate"
		},
		"predicateWithFormatArgumentArray": {
			"!type": "fn(predicateFormat: string, arguments: +Array) -> +NSPredicate"
		},
		"predicateWithBlock": {
			"!type": "fn(block: +Function) -> +NSPredicate"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSCompoundPredicate"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSCompoundPredicate"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSCompoundPredicate"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"subpredicates": {
				"!type": "+Array"
			},
			"compoundPredicateType": {
				"!type": "number"
			},
			"predicateFormat": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithTypeSubpredicates": {
				"!type": "fn(type: number, subpredicates: +Array) -> +NSCompoundPredicate"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSCompoundPredicate"
			},
			"predicateWithSubstitutionVariables": {
				"!type": "fn(variables: +Object) -> +NSCompoundPredicate"
			},
			"evaluateWithObject": {
				"!type": "fn(object: +Object) -> bool"
			},
			"allowEvaluation": {
				"!type": "fn() -> void"
			},
			"evaluateWithObjectSubstitutionVariables": {
				"!type": "fn(object: +Object, bindings: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSCompoundPredicate"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnitEQFilterParameters": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnitEQFilterParameters"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnitEQFilterParameters"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnitEQFilterParameters"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"bandwidth": {
				"!type": "number"
			},
			"frequency": {
				"!type": "number"
			},
			"filterType": {
				"!type": "number"
			},
			"gain": {
				"!type": "number"
			},
			"bypass": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnitEQFilterParameters"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSConstantString": {
		"stringWithCStringLength": {
			"!type": "fn(bytes: +Object, length: number) -> +Object"
		},
		"defaultCStringEncoding": {
			"!type": "fn() -> number"
		},
		"stringWithContentsOfFile": {
			"!type": "fn(path: string) -> +Object"
		},
		"string": {
			"!type": "fn() -> +NSConstantString"
		},
		"stringEncodingForDataEncodingOptionsConvertedStringUsedLossyConversion": {
			"!type": "fn(data: +NSData, opts: +Object, string: +Object, usedLossyConversion: +Object) -> number"
		},
		"stringWithUTF8String": {
			"!type": "fn(nullTerminatedCString: +Object) -> +NSConstantString"
		},
		"stringWithCString": {
			"!type": "fn(bytes: +Object) -> +Object"
		},
		"stringWithContentsOfFileUsedEncodingError": {
			"!type": "fn(path: string, enc: +Object, error: +Object) -> +NSConstantString"
		},
		"stringWithContentsOfURL": {
			"!type": "fn(url: +NSURL) -> +Object"
		},
		"stringWithCharactersLength": {
			"!type": "fn(characters: +Object, length: number) -> +NSConstantString"
		},
		"pathWithComponents": {
			"!type": "fn(components: +Array) -> string"
		},
		"localizedStringWithFormat": {
			"!type": "fn(format: string, args: Array.prototype) -> +NSConstantString"
		},
		"availableStringEncodings": {
			"!type": "fn() -> +Object"
		},
		"stringWithContentsOfFileEncodingError": {
			"!type": "fn(path: string, enc: number, error: +Object) -> +NSConstantString"
		},
		"localizedNameOfStringEncoding": {
			"!type": "fn(encoding: number) -> string"
		},
		"stringWithCStringEncoding": {
			"!type": "fn(cString: +Object, enc: number) -> +NSConstantString"
		},
		"stringWithFormat": {
			"!type": "fn(format: string, args: Array.prototype) -> +NSConstantString"
		},
		"stringWithString": {
			"!type": "fn(string: string) -> +NSConstantString"
		},
		"stringWithContentsOfURLUsedEncodingError": {
			"!type": "fn(url: +NSURL, enc: +Object, error: +Object) -> +NSConstantString"
		},
		"stringWithContentsOfURLEncodingError": {
			"!type": "fn(url: +NSURL, enc: number, error: +Object) -> +NSConstantString"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSConstantString"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSConstantString"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSConstantString"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"stringByRemovingPercentEncoding": {
				"!type": "string"
			},
			"stringByStandardizingPath": {
				"!type": "string"
			},
			"doubleValue": {
				"!type": "number"
			},
			"boolValue": {
				"!type": "bool"
			},
			"stringByAbbreviatingWithTildeInPath": {
				"!type": "string"
			},
			"description": {
				"!type": "string"
			},
			"decomposedStringWithCanonicalMapping": {
				"!type": "string"
			},
			"smallestEncoding": {
				"!type": "number"
			},
			"uppercaseString": {
				"!type": "string"
			},
			"length": {
				"!type": "number"
			},
			"absolutePath": {
				"!type": "bool"
			},
			"fastestEncoding": {
				"!type": "number"
			},
			"decomposedStringWithCompatibilityMapping": {
				"!type": "string"
			},
			"precomposedStringWithCanonicalMapping": {
				"!type": "string"
			},
			"stringByResolvingSymlinksInPath": {
				"!type": "string"
			},
			"lowercaseString": {
				"!type": "string"
			},
			"pathExtension": {
				"!type": "string"
			},
			"precomposedStringWithCompatibilityMapping": {
				"!type": "string"
			},
			"hash": {
				"!type": "number"
			},
			"localizedLowercaseString": {
				"!type": "string"
			},
			"lastPathComponent": {
				"!type": "string"
			},
			"floatValue": {
				"!type": "number"
			},
			"stringByDeletingPathExtension": {
				"!type": "string"
			},
			"intValue": {
				"!type": "number"
			},
			"localizedUppercaseString": {
				"!type": "string"
			},
			"capitalizedString": {
				"!type": "string"
			},
			"integerValue": {
				"!type": "number"
			},
			"stringByExpandingTildeInPath": {
				"!type": "string"
			},
			"stringByDeletingLastPathComponent": {
				"!type": "string"
			},
			"localizedCapitalizedString": {
				"!type": "string"
			},
			"longLongValue": {
				"!type": "number"
			},
			"pathComponents": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"stringByTrimmingCharactersInSet": {
				"!type": "fn(set: +NSCharacterSet) -> string"
			},
			"getCharacters": {
				"!type": "fn(buffer: +Object) -> void"
			},
			"localizedCaseInsensitiveCompare": {
				"!type": "fn(string: string) -> number"
			},
			"commonPrefixWithStringOptions": {
				"!type": "fn(str: string, mask: number) -> string"
			},
			"initWithFormatArguments": {
				"!type": "fn(format: string, argList: +Object) -> +NSConstantString"
			},
			"lowercaseStringWithLocale": {
				"!type": "fn(locale: +NSLocale) -> string"
			},
			"containsString": {
				"!type": "fn(str: string) -> bool"
			},
			"componentsSeparatedByCharactersInSet": {
				"!type": "fn(separator: +NSCharacterSet) -> +Array"
			},
			"stringByAddingPercentEncodingWithAllowedCharacters": {
				"!type": "fn(allowedCharacters: +NSCharacterSet) -> string"
			},
			"initWithContentsOfFile": {
				"!type": "fn(path: string) -> +Object"
			},
			"propertyListFromStringsFileFormat": {
				"!type": "fn() -> +Object"
			},
			"enumerateLinguisticTagsInRangeSchemeOptionsOrthographyUsingBlock": {
				"!type": "fn(range: +Object, scheme: string, options: number, orthography: +NSOrthography, block: +Function) -> void"
			},
			"hasSuffix": {
				"!type": "fn(str: string) -> bool"
			},
			"lineRangeForRange": {
				"!type": "fn(range: +Object) -> +Object"
			},
			"initWithContentsOfFileEncodingError": {
				"!type": "fn(path: string, enc: number, error: +Object) -> +NSConstantString"
			},
			"initWithFormatLocale": {
				"!type": "fn(format: string, locale: +Object, args: Array.prototype) -> +NSConstantString"
			},
			"lossyCString": {
				"!type": "fn() -> +Object"
			},
			"substringWithRange": {
				"!type": "fn(range: +Object) -> string"
			},
			"jsinit": {
				"!type": "fn() -> +NSConstantString"
			},
			"getParagraphStartEndContentsEndForRange": {
				"!type": "fn(startPtr: +Object, parEndPtr: +Object, contentsEndPtr: +Object, range: +Object) -> void"
			},
			"getCharactersRange": {
				"!type": "fn(buffer: +Object, range: +Object) -> void"
			},
			"rangeOfComposedCharacterSequencesForRange": {
				"!type": "fn(range: +Object) -> +Object"
			},
			"cStringUsingEncoding": {
				"!type": "fn(encoding: number) -> +Object"
			},
			"rangeOfCharacterFromSetOptions": {
				"!type": "fn(searchSet: +NSCharacterSet, mask: number) -> +Object"
			},
			"lengthOfBytesUsingEncoding": {
				"!type": "fn(enc: number) -> number"
			},
			"substringToIndex": {
				"!type": "fn(to: number) -> string"
			},
			"writeToFileAtomicallyEncodingError": {
				"!type": "fn(path: string, useAuxiliaryFile: bool, enc: number, error: +Object) -> bool"
			},
			"rangeOfCharacterFromSet": {
				"!type": "fn(searchSet: +NSCharacterSet) -> +Object"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSConstantString"
			},
			"getCStringMaxLengthEncoding": {
				"!type": "fn(buffer: +Object, maxBufferCount: number, encoding: number) -> bool"
			},
			"stringByAppendingPathExtension": {
				"!type": "fn(str: string) -> string"
			},
			"initWithCStringNoCopyLengthFreeWhenDone": {
				"!type": "fn(bytes: +Object, length: number, freeBuffer: bool) -> +Object"
			},
			"localizedCompare": {
				"!type": "fn(string: string) -> number"
			},
			"stringByApplyingTransformReverse": {
				"!type": "fn(transform: string, reverse: bool) -> string"
			},
			"completePathIntoStringCaseSensitiveMatchesIntoArrayFilterTypes": {
				"!type": "fn(outputName: +Object, flag: bool, outputArray: +Object, filterTypes: +Array) -> number"
			},
			"stringByReplacingOccurrencesOfStringWithStringOptionsRange": {
				"!type": "fn(target: string, replacement: string, options: number, searchRange: +Object) -> string"
			},
			"localizedCaseInsensitiveContainsString": {
				"!type": "fn(str: string) -> bool"
			},
			"stringByAddingPercentEscapesUsingEncoding": {
				"!type": "fn(enc: number) -> string"
			},
			"initWithCharactersLength": {
				"!type": "fn(characters: +Object, length: number) -> +NSConstantString"
			},
			"stringByReplacingOccurrencesOfStringWithString": {
				"!type": "fn(target: string, replacement: string) -> string"
			},
			"propertyList": {
				"!type": "fn() -> +Object"
			},
			"initWithFormatLocaleArguments": {
				"!type": "fn(format: string, locale: +Object, argList: +Object) -> +NSConstantString"
			},
			"getCString": {
				"!type": "fn(bytes: +Object) -> void"
			},
			"getLineStartEndContentsEndForRange": {
				"!type": "fn(startPtr: +Object, lineEndPtr: +Object, contentsEndPtr: +Object, range: +Object) -> void"
			},
			"hasPrefix": {
				"!type": "fn(str: string) -> bool"
			},
			"initWithCStringLength": {
				"!type": "fn(bytes: +Object, length: number) -> +Object"
			},
			"getBytesMaxLengthUsedLengthEncodingOptionsRangeRemainingRange": {
				"!type": "fn(buffer: +Object, maxBufferCount: number, usedBufferCount: +Object, encoding: number, options: number, range: +Object, leftover: +Object) -> bool"
			},
			"componentsSeparatedByString": {
				"!type": "fn(separator: string) -> +Array"
			},
			"initWithBytesNoCopyLengthEncodingFreeWhenDone": {
				"!type": "fn(bytes: +Object, len: number, encoding: number, freeBuffer: bool) -> +NSConstantString"
			},
			"maximumLengthOfBytesUsingEncoding": {
				"!type": "fn(enc: number) -> number"
			},
			"initWithDataEncoding": {
				"!type": "fn(data: +NSData, encoding: number) -> +NSConstantString"
			},
			"rangeOfStringOptionsRange": {
				"!type": "fn(searchString: string, mask: number, rangeOfReceiverToSearch: +Object) -> +Object"
			},
			"initWithCharactersNoCopyLengthDeallocator": {
				"!type": "fn(chars: +Object, len: number, deallocator: +Function) -> +NSConstantString"
			},
			"caseInsensitiveCompare": {
				"!type": "fn(string: string) -> number"
			},
			"stringByReplacingCharactersInRangeWithString": {
				"!type": "fn(range: +Object, replacement: string) -> string"
			},
			"compareOptions": {
				"!type": "fn(string: string, mask: number) -> number"
			},
			"initWithContentsOfURLEncodingError": {
				"!type": "fn(url: +NSURL, enc: number, error: +Object) -> +NSConstantString"
			},
			"canBeConvertedToEncoding": {
				"!type": "fn(encoding: number) -> bool"
			},
			"rangeOfStringOptions": {
				"!type": "fn(searchString: string, mask: number) -> +Object"
			},
			"initWithCStringEncoding": {
				"!type": "fn(nullTerminatedCString: +Object, encoding: number) -> +NSConstantString"
			},
			"stringByFoldingWithOptionsLocale": {
				"!type": "fn(options: number, locale: +NSLocale) -> string"
			},
			"initWithFormat": {
				"!type": "fn(format: string, args: Array.prototype) -> +NSConstantString"
			},
			"enumerateSubstringsInRangeOptionsUsingBlock": {
				"!type": "fn(range: +Object, opts: number, block: +Function) -> void"
			},
			"initWithString": {
				"!type": "fn(aString: string) -> +NSConstantString"
			},
			"stringByPaddingToLengthWithStringStartingAtIndex": {
				"!type": "fn(newLength: number, padString: string, padIndex: number) -> string"
			},
			"localizedStandardRangeOfString": {
				"!type": "fn(str: string) -> +Object"
			},
			"rangeOfString": {
				"!type": "fn(searchString: string) -> +Object"
			},
			"getCStringMaxLengthRangeRemainingRange": {
				"!type": "fn(bytes: +Object, maxLength: number, aRange: +Object, leftoverRange: +Object) -> void"
			},
			"initWithCString": {
				"!type": "fn(bytes: +Object) -> +Object"
			},
			"getFileSystemRepresentationMaxLength": {
				"!type": "fn(cname: +Object, max: number) -> bool"
			},
			"compare": {
				"!type": "fn(string: string) -> number"
			},
			"enumerateLinesUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"writeToURLAtomically": {
				"!type": "fn(url: +NSURL, atomically: bool) -> bool"
			},
			"initWithBytesNoCopyLengthEncodingDeallocator": {
				"!type": "fn(bytes: +Object, len: number, encoding: number, deallocator: +Function) -> +NSConstantString"
			},
			"stringByAppendingString": {
				"!type": "fn(aString: string) -> string"
			},
			"compareOptionsRange": {
				"!type": "fn(string: string, mask: number, rangeOfReceiverToCompare: +Object) -> number"
			},
			"substringFromIndex": {
				"!type": "fn(from: number) -> string"
			},
			"initWithCharactersNoCopyLengthFreeWhenDone": {
				"!type": "fn(characters: +Object, length: number, freeBuffer: bool) -> +NSConstantString"
			},
			"stringByAppendingPathComponent": {
				"!type": "fn(str: string) -> string"
			},
			"capitalizedStringWithLocale": {
				"!type": "fn(locale: +NSLocale) -> string"
			},
			"localizedStandardContainsString": {
				"!type": "fn(str: string) -> bool"
			},
			"stringsByAppendingPaths": {
				"!type": "fn(paths: +Array) -> +Array"
			},
			"stringByAppendingFormat": {
				"!type": "fn(format: string, args: Array.prototype) -> string"
			},
			"cString": {
				"!type": "fn() -> +Object"
			},
			"isEqualToString": {
				"!type": "fn(aString: string) -> bool"
			},
			"getCStringMaxLength": {
				"!type": "fn(bytes: +Object, maxLength: number) -> void"
			},
			"linguisticTagsInRangeSchemeOptionsOrthographyTokenRanges": {
				"!type": "fn(range: +Object, scheme: string, options: number, orthography: +NSOrthography, tokenRanges: +Object) -> +Array"
			},
			"cStringLength": {
				"!type": "fn() -> number"
			},
			"rangeOfCharacterFromSetOptionsRange": {
				"!type": "fn(searchSet: +NSCharacterSet, mask: number, rangeOfReceiverToSearch: +Object) -> +Object"
			},
			"variantFittingPresentationWidth": {
				"!type": "fn(width: number) -> string"
			},
			"rangeOfComposedCharacterSequenceAtIndex": {
				"!type": "fn(index: number) -> +Object"
			},
			"writeToURLAtomicallyEncodingError": {
				"!type": "fn(url: +NSURL, useAuxiliaryFile: bool, enc: number, error: +Object) -> bool"
			},
			"initWithContentsOfURLUsedEncodingError": {
				"!type": "fn(url: +NSURL, enc: +Object, error: +Object) -> +NSConstantString"
			},
			"dataUsingEncoding": {
				"!type": "fn(encoding: number) -> +NSData"
			},
			"initWithContentsOfURL": {
				"!type": "fn(url: +NSURL) -> +Object"
			},
			"initWithBytesLengthEncoding": {
				"!type": "fn(bytes: +Object, len: number, encoding: number) -> +NSConstantString"
			},
			"initWithContentsOfFileUsedEncodingError": {
				"!type": "fn(path: string, enc: +Object, error: +Object) -> +NSConstantString"
			},
			"dataUsingEncodingAllowLossyConversion": {
				"!type": "fn(encoding: number, lossy: bool) -> +NSData"
			},
			"compareOptionsRangeLocale": {
				"!type": "fn(string: string, mask: number, rangeOfReceiverToCompare: +Object, locale: +Object) -> number"
			},
			"writeToFileAtomically": {
				"!type": "fn(path: string, useAuxiliaryFile: bool) -> bool"
			},
			"localizedStandardCompare": {
				"!type": "fn(string: string) -> number"
			},
			"characterAtIndex": {
				"!type": "fn(index: number) -> number"
			},
			"paragraphRangeForRange": {
				"!type": "fn(range: +Object) -> +Object"
			},
			"rangeOfStringOptionsRangeLocale": {
				"!type": "fn(searchString: string, mask: number, rangeOfReceiverToSearch: +Object, locale: +NSLocale) -> +Object"
			},
			"initWithUTF8String": {
				"!type": "fn(nullTerminatedCString: +Object) -> +NSConstantString"
			},
			"stringByReplacingPercentEscapesUsingEncoding": {
				"!type": "fn(enc: number) -> string"
			},
			"uppercaseStringWithLocale": {
				"!type": "fn(locale: +NSLocale) -> string"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSConstantString"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMetadataFaceObject": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMetadataFaceObject"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMetadataFaceObject"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMetadataFaceObject"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"faceID": {
				"!type": "number"
			},
			"hasYawAngle": {
				"!type": "bool"
			},
			"hasRollAngle": {
				"!type": "bool"
			},
			"yawAngle": {
				"!type": "number"
			},
			"rollAngle": {
				"!type": "number"
			},
			"duration": {
				"!type": "+Object"
			},
			"type": {
				"!type": "string"
			},
			"bounds": {
				"!type": "+Object"
			},
			"time": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMetadataFaceObject"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerLooper": {
		"playerLooperWithPlayerTemplateItem": {
			"!type": "fn(player: +AVQueuePlayer, itemToLoop: +AVPlayerItem) -> +AVPlayerLooper"
		},
		"playerLooperWithPlayerTemplateItemTimeRange": {
			"!type": "fn(player: +AVQueuePlayer, itemToLoop: +AVPlayerItem, loopRange: +Object) -> +AVPlayerLooper"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerLooper"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerLooper"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerLooper"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"status": {
				"!type": "number"
			},
			"loopingPlayerItems": {
				"!type": "+Array"
			},
			"loopCount": {
				"!type": "number"
			},
			"error": {
				"!type": "+NSError"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"disableLooping": {
				"!type": "fn() -> void"
			},
			"initWithPlayerTemplateItemTimeRange": {
				"!type": "fn(player: +AVQueuePlayer, itemToLoop: +AVPlayerItem, loopRange: +Object) -> +AVPlayerLooper"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerLooper"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCompositionTrack": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCompositionTrack"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCompositionTrack"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCompositionTrack"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"segments": {
				"!type": "+Array"
			},
			"formatDescriptionReplacements": {
				"!type": "+Array"
			},
			"languageCode": {
				"!type": "string"
			},
			"minFrameDuration": {
				"!type": "+Object"
			},
			"formatDescriptions": {
				"!type": "+Array"
			},
			"availableTrackAssociationTypes": {
				"!type": "+Array"
			},
			"nominalFrameRate": {
				"!type": "number"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"estimatedDataRate": {
				"!type": "number"
			},
			"naturalTimeScale": {
				"!type": "number"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"requiresFrameReordering": {
				"!type": "bool"
			},
			"hasAudioSampleDependencies": {
				"!type": "bool"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"selfContained": {
				"!type": "bool"
			},
			"segments": {
				"!type": "+Array"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"extendedLanguageTag": {
				"!type": "string"
			},
			"mediaType": {
				"!type": "string"
			},
			"asset": {
				"!type": "+AVAsset"
			},
			"trackID": {
				"!type": "number"
			},
			"totalSampleDataLength": {
				"!type": "number"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"decodable": {
				"!type": "bool"
			},
			"enabled": {
				"!type": "bool"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"segmentForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +AVCompositionTrackSegment"
			},
			"hasMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> bool"
			},
			"samplePresentationTimeForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +Object"
			},
			"associatedTracksOfType": {
				"!type": "fn(trackAssociationType: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"segmentForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +AVAssetTrackSegment"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCompositionTrack"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSScanner": {
		"scannerWithString": {
			"!type": "fn(string: string) -> +NSScanner"
		},
		"localizedScannerWithString": {
			"!type": "fn(string: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSScanner"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSScanner"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSScanner"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"caseSensitive": {
				"!type": "bool"
			},
			"string": {
				"!type": "string"
			},
			"locale": {
				"!type": "+Object"
			},
			"charactersToBeSkipped": {
				"!type": "+NSCharacterSet"
			},
			"scanLocation": {
				"!type": "number"
			},
			"atEnd": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"scanFloat": {
				"!type": "fn(result: +Object) -> bool"
			},
			"scanUpToStringIntoString": {
				"!type": "fn(string: string, result: +Object) -> bool"
			},
			"scanInt": {
				"!type": "fn(result: +Object) -> bool"
			},
			"scanUpToCharactersFromSetIntoString": {
				"!type": "fn(set: +NSCharacterSet, result: +Object) -> bool"
			},
			"scanHexLongLong": {
				"!type": "fn(result: +Object) -> bool"
			},
			"scanHexInt": {
				"!type": "fn(result: +Object) -> bool"
			},
			"scanInteger": {
				"!type": "fn(result: +Object) -> bool"
			},
			"scanHexFloat": {
				"!type": "fn(result: +Object) -> bool"
			},
			"scanDouble": {
				"!type": "fn(result: +Object) -> bool"
			},
			"scanLongLong": {
				"!type": "fn(result: +Object) -> bool"
			},
			"scanHexDouble": {
				"!type": "fn(result: +Object) -> bool"
			},
			"scanStringIntoString": {
				"!type": "fn(string: string, result: +Object) -> bool"
			},
			"initWithString": {
				"!type": "fn(string: string) -> +NSScanner"
			},
			"scanUnsignedLongLong": {
				"!type": "fn(result: +Object) -> bool"
			},
			"scanDecimal": {
				"!type": "fn(dcm: +Object) -> bool"
			},
			"scanCharactersFromSetIntoString": {
				"!type": "fn(set: +NSCharacterSet, result: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSScanner"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCapturePhotoSettings": {
		"photoSettingsWithRawPixelFormatType": {
			"!type": "fn(rawPixelFormatType: number) -> +AVCapturePhotoSettings"
		},
		"photoSettingsWithRawPixelFormatTypeRawFileTypeProcessedFormatProcessedFileType": {
			"!type": "fn(rawPixelFormatType: number, rawFileType: string, processedFormat: +Object, processedFileType: string) -> +AVCapturePhotoSettings"
		},
		"photoSettings": {
			"!type": "fn() -> +AVCapturePhotoSettings"
		},
		"photoSettingsFromPhotoSettings": {
			"!type": "fn(photoSettings: +AVCapturePhotoSettings) -> +AVCapturePhotoSettings"
		},
		"photoSettingsWithFormat": {
			"!type": "fn(format: +Object) -> +AVCapturePhotoSettings"
		},
		"photoSettingsWithRawPixelFormatTypeProcessedFormat": {
			"!type": "fn(rawPixelFormatType: number, processedFormat: +Object) -> +AVCapturePhotoSettings"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCapturePhotoSettings"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCapturePhotoSettings"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCapturePhotoSettings"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"depthDataFiltered": {
				"!type": "bool"
			},
			"embedsSemanticSegmentationMattesInPhoto": {
				"!type": "bool"
			},
			"uniqueID": {
				"!type": "number"
			},
			"cameraCalibrationDataDeliveryEnabled": {
				"!type": "bool"
			},
			"embedsDepthDataInPhoto": {
				"!type": "bool"
			},
			"rawFileType": {
				"!type": "string"
			},
			"flashMode": {
				"!type": "number"
			},
			"virtualDeviceConstituentPhotoDeliveryEnabledDevices": {
				"!type": "+Array"
			},
			"metadata": {
				"!type": "+Object"
			},
			"portraitEffectsMatteDeliveryEnabled": {
				"!type": "bool"
			},
			"rawEmbeddedThumbnailPhotoFormat": {
				"!type": "+Object"
			},
			"highResolutionPhotoEnabled": {
				"!type": "bool"
			},
			"livePhotoVideoCodecType": {
				"!type": "string"
			},
			"format": {
				"!type": "+Object"
			},
			"livePhotoMovieFileURL": {
				"!type": "+NSURL"
			},
			"previewPhotoFormat": {
				"!type": "+Object"
			},
			"availableRawEmbeddedThumbnailPhotoCodecTypes": {
				"!type": "+Array"
			},
			"autoDualCameraFusionEnabled": {
				"!type": "bool"
			},
			"embedsPortraitEffectsMatteInPhoto": {
				"!type": "bool"
			},
			"availableEmbeddedThumbnailPhotoCodecTypes": {
				"!type": "+Array"
			},
			"livePhotoMovieMetadata": {
				"!type": "+Array"
			},
			"dualCameraDualPhotoDeliveryEnabled": {
				"!type": "bool"
			},
			"availablePreviewPhotoPixelFormatTypes": {
				"!type": "+Array"
			},
			"autoContentAwareDistortionCorrectionEnabled": {
				"!type": "bool"
			},
			"rawPhotoPixelFormatType": {
				"!type": "number"
			},
			"enabledSemanticSegmentationMatteTypes": {
				"!type": "+Array"
			},
			"embeddedThumbnailPhotoFormat": {
				"!type": "+Object"
			},
			"depthDataDeliveryEnabled": {
				"!type": "bool"
			},
			"autoVirtualDeviceFusionEnabled": {
				"!type": "bool"
			},
			"processedFileType": {
				"!type": "string"
			},
			"autoRedEyeReductionEnabled": {
				"!type": "bool"
			},
			"autoStillImageStabilizationEnabled": {
				"!type": "bool"
			},
			"photoQualityPrioritization": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCapturePhotoSettings"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMetadataQueryResultGroup": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMetadataQueryResultGroup"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMetadataQueryResultGroup"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMetadataQueryResultGroup"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"attribute": {
				"!type": "string"
			},
			"resultCount": {
				"!type": "number"
			},
			"results": {
				"!type": "+Array"
			},
			"value": {
				"!type": "+Object"
			},
			"subgroups": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"resultAtIndex": {
				"!type": "fn(idx: number) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMetadataQueryResultGroup"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitDuration": {
		"picoseconds": {
			"!type": "fn() -> +NSUnitDuration"
		},
		"seconds": {
			"!type": "fn() -> +NSUnitDuration"
		},
		"nanoseconds": {
			"!type": "fn() -> +NSUnitDuration"
		},
		"hours": {
			"!type": "fn() -> +NSUnitDuration"
		},
		"microseconds": {
			"!type": "fn() -> +NSUnitDuration"
		},
		"minutes": {
			"!type": "fn() -> +NSUnitDuration"
		},
		"milliseconds": {
			"!type": "fn() -> +NSUnitDuration"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitDuration"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitDuration"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitDuration"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitDuration"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitDuration"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitDuration"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitDuration"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCompositionTrackFormatDescriptionReplacement": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCompositionTrackFormatDescriptionReplacement"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCompositionTrackFormatDescriptionReplacement"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCompositionTrackFormatDescriptionReplacement"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"replacementFormatDescription": {
				"!type": "+Object"
			},
			"originalFormatDescription": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCompositionTrackFormatDescriptionReplacement"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioSession": {
		"sharedInstance": {
			"!type": "fn() -> +AVAudioSession"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioSession"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioSession"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioSession"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"outputNumberOfChannels": {
				"!type": "number"
			},
			"recordPermission": {
				"!type": "number"
			},
			"inputDataSource": {
				"!type": "+AVAudioSessionDataSourceDescription"
			},
			"inputDataSources": {
				"!type": "+Array"
			},
			"preferredOutputNumberOfChannels": {
				"!type": "number"
			},
			"currentHardwareInputNumberOfChannels": {
				"!type": "number"
			},
			"maximumInputNumberOfChannels": {
				"!type": "number"
			},
			"category": {
				"!type": "string"
			},
			"outputDataSources": {
				"!type": "+Array"
			},
			"inputGain": {
				"!type": "number"
			},
			"allowHapticsAndSystemSoundsDuringRecording": {
				"!type": "bool"
			},
			"preferredIOBufferDuration": {
				"!type": "number"
			},
			"preferredInput": {
				"!type": "+AVAudioSessionPortDescription"
			},
			"delegate": {
				"!type": "+Object"
			},
			"outputVolume": {
				"!type": "number"
			},
			"promptStyle": {
				"!type": "number"
			},
			"inputAvailable": {
				"!type": "bool"
			},
			"outputLatency": {
				"!type": "number"
			},
			"otherAudioPlaying": {
				"!type": "bool"
			},
			"currentHardwareSampleRate": {
				"!type": "number"
			},
			"preferredSampleRate": {
				"!type": "number"
			},
			"routeSharingPolicy": {
				"!type": "number"
			},
			"outputDataSource": {
				"!type": "+AVAudioSessionDataSourceDescription"
			},
			"currentHardwareOutputNumberOfChannels": {
				"!type": "number"
			},
			"availableInputs": {
				"!type": "+Array"
			},
			"inputLatency": {
				"!type": "number"
			},
			"preferredHardwareSampleRate": {
				"!type": "number"
			},
			"availableModes": {
				"!type": "+Array"
			},
			"inputOrientation": {
				"!type": "number"
			},
			"categoryOptions": {
				"!type": "number"
			},
			"secondaryAudioShouldBeSilencedHint": {
				"!type": "bool"
			},
			"inputIsAvailable": {
				"!type": "bool"
			},
			"preferredInputOrientation": {
				"!type": "number"
			},
			"IOBufferDuration": {
				"!type": "number"
			},
			"maximumOutputNumberOfChannels": {
				"!type": "number"
			},
			"mode": {
				"!type": "string"
			},
			"currentRoute": {
				"!type": "+AVAudioSessionRouteDescription"
			},
			"sampleRate": {
				"!type": "number"
			},
			"preferredInputNumberOfChannels": {
				"!type": "number"
			},
			"inputGainSettable": {
				"!type": "bool"
			},
			"availableCategories": {
				"!type": "+Array"
			},
			"inputNumberOfChannels": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setPreferredInputNumberOfChannelsError": {
				"!type": "fn(count: number, outError: +Object) -> bool"
			},
			"setPreferredOutputNumberOfChannelsError": {
				"!type": "fn(count: number, outError: +Object) -> bool"
			},
			"requestRecordPermission": {
				"!type": "fn(response: +Function) -> void"
			},
			"setPreferredSampleRateError": {
				"!type": "fn(sampleRate: number, outError: +Object) -> bool"
			},
			"setOutputDataSourceError": {
				"!type": "fn(dataSource: +AVAudioSessionDataSourceDescription, outError: +Object) -> bool"
			},
			"setActiveWithFlagsError": {
				"!type": "fn(active: bool, flags: number, outError: +Object) -> bool"
			},
			"setCategoryWithOptionsError": {
				"!type": "fn(category: string, options: number, outError: +Object) -> bool"
			},
			"setAggregatedIOPreferenceError": {
				"!type": "fn(inIOType: number, outError: +Object) -> bool"
			},
			"setPreferredIOBufferDurationError": {
				"!type": "fn(duration: number, outError: +Object) -> bool"
			},
			"setCategoryModeRouteSharingPolicyOptionsError": {
				"!type": "fn(category: string, mode: string, policy: number, options: number, outError: +Object) -> bool"
			},
			"setPreferredHardwareSampleRateError": {
				"!type": "fn(sampleRate: number, outError: +Object) -> bool"
			},
			"setPreferredInputOrientationError": {
				"!type": "fn(orientation: number, outError: +Object) -> bool"
			},
			"setCategoryError": {
				"!type": "fn(category: string, outError: +Object) -> bool"
			},
			"setAllowHapticsAndSystemSoundsDuringRecordingError": {
				"!type": "fn(inValue: bool, outError: +Object) -> bool"
			},
			"overrideOutputAudioPortError": {
				"!type": "fn(portOverride: number, outError: +Object) -> bool"
			},
			"setCategoryModeOptionsError": {
				"!type": "fn(category: string, mode: string, options: number, outError: +Object) -> bool"
			},
			"setInputGainError": {
				"!type": "fn(gain: number, outError: +Object) -> bool"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioSession"
			},
			"setActiveWithOptionsError": {
				"!type": "fn(active: bool, options: number, outError: +Object) -> bool"
			},
			"setModeError": {
				"!type": "fn(mode: string, outError: +Object) -> bool"
			},
			"setPreferredInputError": {
				"!type": "fn(inPort: +AVAudioSessionPortDescription, outError: +Object) -> bool"
			},
			"setActiveError": {
				"!type": "fn(active: bool, outError: +Object) -> bool"
			},
			"setInputDataSourceError": {
				"!type": "fn(dataSource: +AVAudioSessionDataSourceDescription, outError: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioSession"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSNull": {
		"null": {
			"!type": "fn() -> null"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> null"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> null"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> null"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> null"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioChannelLayout": {
		"layoutWithLayoutTag": {
			"!type": "fn(layoutTag: number) -> +AVAudioChannelLayout"
		},
		"layoutWithLayout": {
			"!type": "fn(layout: +Object) -> +AVAudioChannelLayout"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioChannelLayout"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioChannelLayout"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioChannelLayout"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"channelCount": {
				"!type": "number"
			},
			"layoutTag": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithLayoutTag": {
				"!type": "fn(layoutTag: number) -> +AVAudioChannelLayout"
			},
			"isEqual": {
				"!type": "fn(object: +Object) -> bool"
			},
			"initWithLayout": {
				"!type": "fn(layout: +Object) -> +AVAudioChannelLayout"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioChannelLayout"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSInputStream": {
		"inputStreamWithFileAtPath": {
			"!type": "fn(path: string) -> +NSInputStream"
		},
		"inputStreamWithData": {
			"!type": "fn(data: +NSData) -> +NSInputStream"
		},
		"inputStreamWithURL": {
			"!type": "fn(url: +NSURL) -> +NSInputStream"
		},
		"getBoundStreamsWithBufferSizeInputStreamOutputStream": {
			"!type": "fn(bufferSize: number, inputStream: +Object, outputStream: +Object) -> void"
		},
		"getStreamsToHostWithNamePortInputStreamOutputStream": {
			"!type": "fn(hostname: string, port: number, inputStream: +Object, outputStream: +Object) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSInputStream"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSInputStream"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSInputStream"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"hasBytesAvailable": {
				"!type": "bool"
			},
			"streamError": {
				"!type": "+NSError"
			},
			"streamStatus": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"getBufferLength": {
				"!type": "fn(buffer: +Object, len: +Object) -> bool"
			},
			"readMaxLength": {
				"!type": "fn(buffer: +Object, len: number) -> number"
			},
			"initWithURL": {
				"!type": "fn(url: +NSURL) -> +NSInputStream"
			},
			"initWithData": {
				"!type": "fn(data: +NSData) -> +NSInputStream"
			},
			"initWithFileAtPath": {
				"!type": "fn(path: string) -> +NSInputStream"
			},
			"setPropertyForKey": {
				"!type": "fn(property: +Object, key: string) -> bool"
			},
			"scheduleInRunLoopForMode": {
				"!type": "fn(aRunLoop: +NSRunLoop, mode: string) -> void"
			},
			"propertyForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"removeFromRunLoopForMode": {
				"!type": "fn(aRunLoop: +NSRunLoop, mode: string) -> void"
			},
			"close": {
				"!type": "fn() -> void"
			},
			"open": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSInputStream"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLCache": {
		"sharedURLCache": {
			"!type": "fn() -> +NSURLCache"
		},
		"setSharedURLCache": {
			"!type": "fn(sharedURLCache: +NSURLCache) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLCache"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLCache"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLCache"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"currentMemoryUsage": {
				"!type": "number"
			},
			"memoryCapacity": {
				"!type": "number"
			},
			"currentDiskUsage": {
				"!type": "number"
			},
			"diskCapacity": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"storeCachedResponseForRequest": {
				"!type": "fn(cachedResponse: +NSCachedURLResponse, request: +NSURLRequest) -> void"
			},
			"removeCachedResponseForRequest": {
				"!type": "fn(request: +NSURLRequest) -> void"
			},
			"removeCachedResponsesSinceDate": {
				"!type": "fn(date: +Date) -> void"
			},
			"getCachedResponseForDataTaskCompletionHandler": {
				"!type": "fn(dataTask: +NSURLSessionDataTask, completionHandler: +Function) -> void"
			},
			"cachedResponseForRequest": {
				"!type": "fn(request: +NSURLRequest) -> +NSCachedURLResponse"
			},
			"removeAllCachedResponses": {
				"!type": "fn() -> void"
			},
			"initWithMemoryCapacityDiskCapacityDiskPath": {
				"!type": "fn(memoryCapacity: number, diskCapacity: number, path: string) -> +NSURLCache"
			},
			"removeCachedResponseForDataTask": {
				"!type": "fn(dataTask: +NSURLSessionDataTask) -> void"
			},
			"storeCachedResponseForDataTask": {
				"!type": "fn(cachedResponse: +NSCachedURLResponse, dataTask: +NSURLSessionDataTask) -> void"
			},
			"initWithMemoryCapacityDiskCapacityDirectoryURL": {
				"!type": "fn(memoryCapacity: number, diskCapacity: number, directoryURL: +NSURL) -> +NSURLCache"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLCache"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMutableVideoComposition": {
		"videoComposition": {
			"!type": "fn() -> +AVMutableVideoComposition"
		},
		"videoCompositionWithPropertiesOfAssetPrototypeInstruction": {
			"!type": "fn(asset: +AVAsset, prototypeInstruction: +AVVideoCompositionInstruction) -> +AVMutableVideoComposition"
		},
		"videoCompositionWithAssetApplyingCIFiltersWithHandler": {
			"!type": "fn(asset: +AVAsset, applier: +Function) -> +AVMutableVideoComposition"
		},
		"videoCompositionWithPropertiesOfAsset": {
			"!type": "fn(asset: +AVAsset) -> +AVMutableVideoComposition"
		},
		"videoCompositionWithPropertiesOfAsset": {
			"!type": "fn(asset: +AVAsset) -> +AVVideoComposition"
		},
		"videoCompositionWithAssetApplyingCIFiltersWithHandler": {
			"!type": "fn(asset: +AVAsset, applier: +Function) -> +AVVideoComposition"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMutableVideoComposition"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMutableVideoComposition"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMutableVideoComposition"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"animationTool": {
				"!type": "+AVVideoCompositionCoreAnimationTool"
			},
			"colorYCbCrMatrix": {
				"!type": "string"
			},
			"frameDuration": {
				"!type": "+Object"
			},
			"colorPrimaries": {
				"!type": "string"
			},
			"renderScale": {
				"!type": "number"
			},
			"renderSize": {
				"!type": "+Object"
			},
			"colorTransferFunction": {
				"!type": "string"
			},
			"jscustomVideoCompositorClass": {
				"!type": "+Object"
			},
			"sourceTrackIDForFrameTiming": {
				"!type": "number"
			},
			"instructions": {
				"!type": "+Array"
			},
			"animationTool": {
				"!type": "+AVVideoCompositionCoreAnimationTool"
			},
			"colorYCbCrMatrix": {
				"!type": "string"
			},
			"frameDuration": {
				"!type": "+Object"
			},
			"colorPrimaries": {
				"!type": "string"
			},
			"renderScale": {
				"!type": "number"
			},
			"renderSize": {
				"!type": "+Object"
			},
			"colorTransferFunction": {
				"!type": "string"
			},
			"jscustomVideoCompositorClass": {
				"!type": "+Object"
			},
			"sourceTrackIDForFrameTiming": {
				"!type": "number"
			},
			"instructions": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"isValidForAssetTimeRangeValidationDelegate": {
				"!type": "fn(asset: +AVAsset, timeRange: +Object, validationDelegate: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMutableVideoComposition"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayer": {
		"availableHDRModes": {
			"!type": "fn() -> number"
		},
		"eligibleForHDRPlayback": {
			"!type": "fn() -> bool"
		},
		"playerWithPlayerItem": {
			"!type": "fn(item: +AVPlayerItem) -> +AVPlayer"
		},
		"playerWithURL": {
			"!type": "fn(URL: +NSURL) -> +AVPlayer"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"status": {
				"!type": "number"
			},
			"masterClock": {
				"!type": "+Object"
			},
			"automaticallyWaitsToMinimizeStalling": {
				"!type": "bool"
			},
			"error": {
				"!type": "+NSError"
			},
			"reasonForWaitingToPlay": {
				"!type": "string"
			},
			"airPlayVideoActive": {
				"!type": "bool"
			},
			"volume": {
				"!type": "number"
			},
			"rate": {
				"!type": "number"
			},
			"closedCaptionDisplayEnabled": {
				"!type": "bool"
			},
			"preventsDisplaySleepDuringVideoPlayback": {
				"!type": "bool"
			},
			"externalPlaybackActive": {
				"!type": "bool"
			},
			"externalPlaybackVideoGravity": {
				"!type": "string"
			},
			"actionAtItemEnd": {
				"!type": "number"
			},
			"usesAirPlayVideoWhileAirPlayScreenIsActive": {
				"!type": "bool"
			},
			"muted": {
				"!type": "bool"
			},
			"outputObscuredDueToInsufficientExternalProtection": {
				"!type": "bool"
			},
			"usesExternalPlaybackWhileExternalScreenIsActive": {
				"!type": "bool"
			},
			"timeControlStatus": {
				"!type": "number"
			},
			"appliesMediaSelectionCriteriaAutomatically": {
				"!type": "bool"
			},
			"allowsAirPlayVideo": {
				"!type": "bool"
			},
			"currentItem": {
				"!type": "+AVPlayerItem"
			},
			"allowsExternalPlayback": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"play": {
				"!type": "fn() -> void"
			},
			"pause": {
				"!type": "fn() -> void"
			},
			"addBoundaryTimeObserverForTimesQueueUsingBlock": {
				"!type": "fn(times: +Array, queue: +Object, block: +Function) -> +Object"
			},
			"setRateTimeAtHostTime": {
				"!type": "fn(rate: number, itemTime: +Object, hostClockTime: +Object) -> void"
			},
			"seekToDateCompletionHandler": {
				"!type": "fn(date: +Date, completionHandler: +Function) -> void"
			},
			"currentTime": {
				"!type": "fn() -> +Object"
			},
			"initWithPlayerItem": {
				"!type": "fn(item: +AVPlayerItem) -> +AVPlayer"
			},
			"removeTimeObserver": {
				"!type": "fn(observer: +Object) -> void"
			},
			"playImmediatelyAtRate": {
				"!type": "fn(rate: number) -> void"
			},
			"mediaSelectionCriteriaForMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +AVPlayerMediaSelectionCriteria"
			},
			"seekToTimeCompletionHandler": {
				"!type": "fn(time: +Object, completionHandler: +Function) -> void"
			},
			"initWithURL": {
				"!type": "fn(URL: +NSURL) -> +AVPlayer"
			},
			"seekToTimeToleranceBeforeToleranceAfterCompletionHandler": {
				"!type": "fn(time: +Object, toleranceBefore: +Object, toleranceAfter: +Object, completionHandler: +Function) -> void"
			},
			"replaceCurrentItemWithPlayerItem": {
				"!type": "fn(item: +AVPlayerItem) -> void"
			},
			"prerollAtRateCompletionHandler": {
				"!type": "fn(rate: number, completionHandler: +Function) -> void"
			},
			"cancelPendingPrerolls": {
				"!type": "fn() -> void"
			},
			"setMediaSelectionCriteriaForMediaCharacteristic": {
				"!type": "fn(criteria: +AVPlayerMediaSelectionCriteria, mediaCharacteristic: string) -> void"
			},
			"seekToTime": {
				"!type": "fn(time: +Object) -> void"
			},
			"seekToTimeToleranceBeforeToleranceAfter": {
				"!type": "fn(time: +Object, toleranceBefore: +Object, toleranceAfter: +Object) -> void"
			},
			"seekToDate": {
				"!type": "fn(date: +Date) -> void"
			},
			"addPeriodicTimeObserverForIntervalQueueUsingBlock": {
				"!type": "fn(interval: +Object, queue: +Object, block: +Function) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSTimer": {
		"scheduledTimerWithTimeIntervalRepeatsBlock": {
			"!type": "fn(interval: number, repeats: bool, block: +Function) -> +NSTimer"
		},
		"timerWithTimeIntervalRepeatsBlock": {
			"!type": "fn(interval: number, repeats: bool, block: +Function) -> +NSTimer"
		},
		"scheduledTimerWithTimeIntervalInvocationRepeats": {
			"!type": "fn(ti: number, invocation: +NSInvocation, yesOrNo: bool) -> +NSTimer"
		},
		"scheduledTimerWithTimeIntervalTargetSelectorUserInfoRepeats": {
			"!type": "fn(ti: number, aTarget: +Object, aSelector: string, userInfo: +Object, yesOrNo: bool) -> +NSTimer"
		},
		"timerWithTimeIntervalInvocationRepeats": {
			"!type": "fn(ti: number, invocation: +NSInvocation, yesOrNo: bool) -> +NSTimer"
		},
		"timerWithTimeIntervalTargetSelectorUserInfoRepeats": {
			"!type": "fn(ti: number, aTarget: +Object, aSelector: string, userInfo: +Object, yesOrNo: bool) -> +NSTimer"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSTimer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSTimer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSTimer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"fireDate": {
				"!type": "+Date"
			},
			"timeInterval": {
				"!type": "number"
			},
			"valid": {
				"!type": "bool"
			},
			"tolerance": {
				"!type": "number"
			},
			"userInfo": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"invalidate": {
				"!type": "fn() -> void"
			},
			"initWithFireDateIntervalRepeatsBlock": {
				"!type": "fn(date: +Date, interval: number, repeats: bool, block: +Function) -> +NSTimer"
			},
			"fire": {
				"!type": "fn() -> void"
			},
			"initWithFireDateIntervalTargetSelectorUserInfoRepeats": {
				"!type": "fn(date: +Date, ti: number, t: +Object, s: string, ui: +Object, rep: bool) -> +NSTimer"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSTimer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnitTimePitch": {
		"instantiateWithComponentDescriptionOptionsCompletionHandler": {
			"!type": "fn(audioComponentDescription: +Object, options: number, completionHandler: +Function) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnitTimePitch"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnitTimePitch"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnitTimePitch"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"rate": {
				"!type": "number"
			},
			"overlap": {
				"!type": "number"
			},
			"pitch": {
				"!type": "number"
			},
			"bypass": {
				"!type": "bool"
			},
			"name": {
				"!type": "string"
			},
			"audioComponentDescription": {
				"!type": "+Object"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"version": {
				"!type": "number"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithAudioComponentDescription": {
				"!type": "fn(audioComponentDescription: +Object) -> +AVAudioUnitTimePitch"
			},
			"loadAudioUnitPresetAtURLError": {
				"!type": "fn(url: +NSURL, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnitTimePitch"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMetadataHumanBodyObject": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMetadataHumanBodyObject"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMetadataHumanBodyObject"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMetadataHumanBodyObject"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"bodyID": {
				"!type": "number"
			},
			"duration": {
				"!type": "+Object"
			},
			"type": {
				"!type": "string"
			},
			"bounds": {
				"!type": "+Object"
			},
			"time": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMetadataHumanBodyObject"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetWriter": {
		"assetWriterWithURLFileTypeError": {
			"!type": "fn(outputURL: +NSURL, outputFileType: string, outError: +Object) -> +AVAssetWriter"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetWriter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetWriter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetWriter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"status": {
				"!type": "number"
			},
			"inputs": {
				"!type": "+Array"
			},
			"movieFragmentInterval": {
				"!type": "+Object"
			},
			"overallDurationHint": {
				"!type": "+Object"
			},
			"delegate": {
				"!type": "+Object"
			},
			"availableMediaTypes": {
				"!type": "+Array"
			},
			"producesCombinableFragments": {
				"!type": "bool"
			},
			"directoryForTemporaryFiles": {
				"!type": "+NSURL"
			},
			"initialSegmentStartTime": {
				"!type": "+Object"
			},
			"movieTimeScale": {
				"!type": "number"
			},
			"outputFileType": {
				"!type": "string"
			},
			"outputFileTypeProfile": {
				"!type": "string"
			},
			"shouldOptimizeForNetworkUse": {
				"!type": "bool"
			},
			"error": {
				"!type": "+NSError"
			},
			"inputGroups": {
				"!type": "+Array"
			},
			"outputURL": {
				"!type": "+NSURL"
			},
			"initialMovieFragmentSequenceNumber": {
				"!type": "number"
			},
			"preferredOutputSegmentInterval": {
				"!type": "+Object"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"addInput": {
				"!type": "fn(input: +AVAssetWriterInput) -> void"
			},
			"addInputGroup": {
				"!type": "fn(inputGroup: +AVAssetWriterInputGroup) -> void"
			},
			"flushSegment": {
				"!type": "fn() -> void"
			},
			"canApplyOutputSettingsForMediaType": {
				"!type": "fn(outputSettings: +Object, mediaType: string) -> bool"
			},
			"startWriting": {
				"!type": "fn() -> bool"
			},
			"finishWritingWithCompletionHandler": {
				"!type": "fn(handler: +Function) -> void"
			},
			"endSessionAtSourceTime": {
				"!type": "fn(endTime: +Object) -> void"
			},
			"cancelWriting": {
				"!type": "fn() -> void"
			},
			"startSessionAtSourceTime": {
				"!type": "fn(startTime: +Object) -> void"
			},
			"canAddInput": {
				"!type": "fn(input: +AVAssetWriterInput) -> bool"
			},
			"initWithURLFileTypeError": {
				"!type": "fn(outputURL: +NSURL, outputFileType: string, outError: +Object) -> +AVAssetWriter"
			},
			"initWithContentType": {
				"!type": "fn(outputContentType: +UTType) -> +AVAssetWriter"
			},
			"canAddInputGroup": {
				"!type": "fn(inputGroup: +AVAssetWriterInputGroup) -> bool"
			},
			"finishWriting": {
				"!type": "fn() -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetWriter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSBundle": {
		"pathForResourceOfTypeInDirectory": {
			"!type": "fn(name: string, ext: string, bundlePath: string) -> string"
		},
		"preferredLocalizationsFromArray": {
			"!type": "fn(localizationsArray: +Array) -> +Array"
		},
		"bundleWithPath": {
			"!type": "fn(path: string) -> +NSBundle"
		},
		"allFrameworks": {
			"!type": "fn() -> +Array"
		},
		"URLForResourceWithExtensionSubdirectoryInBundleWithURL": {
			"!type": "fn(name: string, ext: string, subpath: string, bundleURL: +NSURL) -> +NSURL"
		},
		"bundleForClass": {
			"!type": "fn(aClass: +Object) -> +NSBundle"
		},
		"URLsForResourcesWithExtensionSubdirectoryInBundleWithURL": {
			"!type": "fn(ext: string, subpath: string, bundleURL: +NSURL) -> +Array"
		},
		"bundleWithURL": {
			"!type": "fn(url: +NSURL) -> +NSBundle"
		},
		"preferredLocalizationsFromArrayForPreferences": {
			"!type": "fn(localizationsArray: +Array, preferencesArray: +Array) -> +Array"
		},
		"allBundles": {
			"!type": "fn() -> +Array"
		},
		"pathsForResourcesOfTypeInDirectory": {
			"!type": "fn(ext: string, bundlePath: string) -> +Array"
		},
		"bundleWithIdentifier": {
			"!type": "fn(identifier: string) -> +NSBundle"
		},
		"mainBundle": {
			"!type": "fn() -> +NSBundle"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSBundle"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSBundle"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSBundle"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"localizedInfoDictionary": {
				"!type": "+Object"
			},
			"sharedFrameworksURL": {
				"!type": "+NSURL"
			},
			"privateFrameworksPath": {
				"!type": "string"
			},
			"loaded": {
				"!type": "bool"
			},
			"bundleURL": {
				"!type": "+NSURL"
			},
			"sharedSupportPath": {
				"!type": "string"
			},
			"builtInPlugInsPath": {
				"!type": "string"
			},
			"developmentLocalization": {
				"!type": "string"
			},
			"preferredLocalizations": {
				"!type": "+Array"
			},
			"executableArchitectures": {
				"!type": "+Array"
			},
			"sharedFrameworksPath": {
				"!type": "string"
			},
			"infoDictionary": {
				"!type": "+Object"
			},
			"executableURL": {
				"!type": "+NSURL"
			},
			"bundlePath": {
				"!type": "string"
			},
			"builtInPlugInsURL": {
				"!type": "+NSURL"
			},
			"resourcePath": {
				"!type": "string"
			},
			"jsprincipalClass": {
				"!type": "+Object"
			},
			"executablePath": {
				"!type": "string"
			},
			"localizations": {
				"!type": "+Array"
			},
			"appStoreReceiptURL": {
				"!type": "+NSURL"
			},
			"resourceURL": {
				"!type": "+NSURL"
			},
			"sharedSupportURL": {
				"!type": "+NSURL"
			},
			"privateFrameworksURL": {
				"!type": "+NSURL"
			},
			"bundleIdentifier": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"load": {
				"!type": "fn() -> bool"
			},
			"URLsForResourcesWithExtensionSubdirectory": {
				"!type": "fn(ext: string, subpath: string) -> +Array"
			},
			"pathForResourceOfTypeInDirectoryForLocalization": {
				"!type": "fn(name: string, ext: string, subpath: string, localizationName: string) -> string"
			},
			"pathForAuxiliaryExecutable": {
				"!type": "fn(executableName: string) -> string"
			},
			"URLForAuxiliaryExecutable": {
				"!type": "fn(executableName: string) -> +NSURL"
			},
			"localizedStringForKeyValueTable": {
				"!type": "fn(key: string, value: string, tableName: string) -> string"
			},
			"initWithPath": {
				"!type": "fn(path: string) -> +NSBundle"
			},
			"objectForInfoDictionaryKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"pathsForResourcesOfTypeInDirectoryForLocalization": {
				"!type": "fn(ext: string, subpath: string, localizationName: string) -> +Array"
			},
			"URLsForResourcesWithExtensionSubdirectoryLocalization": {
				"!type": "fn(ext: string, subpath: string, localizationName: string) -> +Array"
			},
			"classNamed": {
				"!type": "fn(className: string) -> +Object"
			},
			"loadAndReturnError": {
				"!type": "fn(error: +Object) -> bool"
			},
			"preflightAndReturnError": {
				"!type": "fn(error: +Object) -> bool"
			},
			"URLForResourceWithExtensionSubdirectoryLocalization": {
				"!type": "fn(name: string, ext: string, subpath: string, localizationName: string) -> +NSURL"
			},
			"pathsForResourcesOfTypeInDirectory": {
				"!type": "fn(ext: string, subpath: string) -> +Array"
			},
			"pathForResourceOfTypeInDirectory": {
				"!type": "fn(name: string, ext: string, subpath: string) -> string"
			},
			"URLForResourceWithExtension": {
				"!type": "fn(name: string, ext: string) -> +NSURL"
			},
			"URLForResourceWithExtensionSubdirectory": {
				"!type": "fn(name: string, ext: string, subpath: string) -> +NSURL"
			},
			"unload": {
				"!type": "fn() -> bool"
			},
			"initWithURL": {
				"!type": "fn(url: +NSURL) -> +NSBundle"
			},
			"preservationPriorityForTag": {
				"!type": "fn(tag: string) -> number"
			},
			"pathForResourceOfType": {
				"!type": "fn(name: string, ext: string) -> string"
			},
			"setPreservationPriorityForTags": {
				"!type": "fn(priority: number, tags: +NSSet) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSBundle"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMetadataQueryAttributeValueTuple": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMetadataQueryAttributeValueTuple"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMetadataQueryAttributeValueTuple"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMetadataQueryAttributeValueTuple"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"attribute": {
				"!type": "string"
			},
			"value": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMetadataQueryAttributeValueTuple"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMovie": {
		"movieWithDataOptions": {
			"!type": "fn(data: +NSData, options: +Object) -> +AVMovie"
		},
		"movieWithURLOptions": {
			"!type": "fn(URL: +NSURL, options: +Object) -> +AVMovie"
		},
		"movieTypes": {
			"!type": "fn() -> +Array"
		},
		"assetWithURL": {
			"!type": "fn(URL: +NSURL) -> +AVMovie"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMovie"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMovie"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMovie"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"defaultMediaDataStorage": {
				"!type": "+AVMediaDataStorage"
			},
			"URL": {
				"!type": "+NSURL"
			},
			"containsMovieFragments": {
				"!type": "bool"
			},
			"tracks": {
				"!type": "+Array"
			},
			"data": {
				"!type": "+NSData"
			},
			"canContainMovieFragments": {
				"!type": "bool"
			},
			"creationDate": {
				"!type": "+AVMetadataItem"
			},
			"referenceRestrictions": {
				"!type": "number"
			},
			"canContainFragments": {
				"!type": "bool"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"preferredRate": {
				"!type": "number"
			},
			"composable": {
				"!type": "bool"
			},
			"tracks": {
				"!type": "+Array"
			},
			"containsFragments": {
				"!type": "bool"
			},
			"availableMediaCharacteristicsWithMediaSelectionOptions": {
				"!type": "+Array"
			},
			"preferredMediaSelection": {
				"!type": "+AVMediaSelection"
			},
			"duration": {
				"!type": "+Object"
			},
			"providesPreciseDurationAndTiming": {
				"!type": "bool"
			},
			"compatibleWithAirPlayVideo": {
				"!type": "bool"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"exportable": {
				"!type": "bool"
			},
			"lyrics": {
				"!type": "string"
			},
			"trackGroups": {
				"!type": "+Array"
			},
			"compatibleWithSavedPhotosAlbum": {
				"!type": "bool"
			},
			"readable": {
				"!type": "bool"
			},
			"hasProtectedContent": {
				"!type": "bool"
			},
			"overallDurationHint": {
				"!type": "+Object"
			},
			"availableChapterLocales": {
				"!type": "+Array"
			},
			"minimumTimeOffsetFromLive": {
				"!type": "+Object"
			},
			"allMediaSelections": {
				"!type": "+Array"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithURLOptions": {
				"!type": "fn(URL: +NSURL, options: +Object) -> +AVMovie"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVMovieTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"initWithDataOptions": {
				"!type": "fn(data: +NSData, options: +Object) -> +AVMovie"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"writeMovieHeaderToURLFileTypeOptionsError": {
				"!type": "fn(URL: +NSURL, fileType: string, options: number, outError: +Object) -> bool"
			},
			"movieHeaderWithFileTypeError": {
				"!type": "fn(fileType: string, outError: +Object) -> +NSData"
			},
			"isCompatibleWithFileType": {
				"!type": "fn(fileType: string) -> bool"
			},
			"unusedTrackID": {
				"!type": "fn() -> number"
			},
			"chapterMetadataGroupsWithTitleLocaleContainingItemsWithCommonKeys": {
				"!type": "fn(locale: +NSLocale, commonKeys: +Array) -> +Array"
			},
			"cancelLoading": {
				"!type": "fn() -> void"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVAssetTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"mediaSelectionGroupForMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +AVMediaSelectionGroup"
			},
			"chapterMetadataGroupsBestMatchingPreferredLanguages": {
				"!type": "fn(preferredLanguages: +Array) -> +Array"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMovie"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitTemperature": {
		"fahrenheit": {
			"!type": "fn() -> +NSUnitTemperature"
		},
		"kelvin": {
			"!type": "fn() -> +NSUnitTemperature"
		},
		"celsius": {
			"!type": "fn() -> +NSUnitTemperature"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitTemperature"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitTemperature"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitTemperature"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitTemperature"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitTemperature"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitTemperature"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitTemperature"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioFile": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioFile"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioFile"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioFile"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"url": {
				"!type": "+NSURL"
			},
			"length": {
				"!type": "number"
			},
			"framePosition": {
				"!type": "number"
			},
			"processingFormat": {
				"!type": "+AVAudioFormat"
			},
			"fileFormat": {
				"!type": "+AVAudioFormat"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initForReadingError": {
				"!type": "fn(fileURL: +NSURL, outError: +Object) -> +AVAudioFile"
			},
			"initForWritingSettingsError": {
				"!type": "fn(fileURL: +NSURL, settings: +Object, outError: +Object) -> +AVAudioFile"
			},
			"readIntoBufferError": {
				"!type": "fn(buffer: +AVAudioPCMBuffer, outError: +Object) -> bool"
			},
			"initForWritingSettingsCommonFormatInterleavedError": {
				"!type": "fn(fileURL: +NSURL, settings: +Object, format: number, interleaved: bool, outError: +Object) -> +AVAudioFile"
			},
			"writeFromBufferError": {
				"!type": "fn(buffer: +AVAudioPCMBuffer, outError: +Object) -> bool"
			},
			"readIntoBufferFrameCountError": {
				"!type": "fn(buffer: +AVAudioPCMBuffer, frames: number, outError: +Object) -> bool"
			},
			"initForReadingCommonFormatInterleavedError": {
				"!type": "fn(fileURL: +NSURL, format: number, interleaved: bool, outError: +Object) -> +AVAudioFile"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioFile"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVSampleBufferRenderSynchronizer": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVSampleBufferRenderSynchronizer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVSampleBufferRenderSynchronizer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVSampleBufferRenderSynchronizer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"rate": {
				"!type": "number"
			},
			"timebase": {
				"!type": "+Object"
			},
			"renderers": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"addBoundaryTimeObserverForTimesQueueUsingBlock": {
				"!type": "fn(times: +Array, queue: +Object, block: +Function) -> +Object"
			},
			"setRateTime": {
				"!type": "fn(rate: number, time: +Object) -> void"
			},
			"currentTime": {
				"!type": "fn() -> +Object"
			},
			"removeRendererAtTimeCompletionHandler": {
				"!type": "fn(renderer: +Object, time: +Object, completionHandler: +Function) -> void"
			},
			"addRenderer": {
				"!type": "fn(renderer: +Object) -> void"
			},
			"removeTimeObserver": {
				"!type": "fn(observer: +Object) -> void"
			},
			"addPeriodicTimeObserverForIntervalQueueUsingBlock": {
				"!type": "fn(interval: +Object, queue: +Object, block: +Function) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVSampleBufferRenderSynchronizer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMovieTrack": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMovieTrack"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMovieTrack"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMovieTrack"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"mediaDecodeTimeRange": {
				"!type": "+Object"
			},
			"alternateGroupID": {
				"!type": "number"
			},
			"mediaPresentationTimeRange": {
				"!type": "+Object"
			},
			"mediaDataStorage": {
				"!type": "+AVMediaDataStorage"
			},
			"languageCode": {
				"!type": "string"
			},
			"minFrameDuration": {
				"!type": "+Object"
			},
			"formatDescriptions": {
				"!type": "+Array"
			},
			"availableTrackAssociationTypes": {
				"!type": "+Array"
			},
			"nominalFrameRate": {
				"!type": "number"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"estimatedDataRate": {
				"!type": "number"
			},
			"naturalTimeScale": {
				"!type": "number"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"requiresFrameReordering": {
				"!type": "bool"
			},
			"hasAudioSampleDependencies": {
				"!type": "bool"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"selfContained": {
				"!type": "bool"
			},
			"segments": {
				"!type": "+Array"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"extendedLanguageTag": {
				"!type": "string"
			},
			"mediaType": {
				"!type": "string"
			},
			"asset": {
				"!type": "+AVAsset"
			},
			"trackID": {
				"!type": "number"
			},
			"totalSampleDataLength": {
				"!type": "number"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"decodable": {
				"!type": "bool"
			},
			"enabled": {
				"!type": "bool"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hasMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> bool"
			},
			"samplePresentationTimeForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +Object"
			},
			"associatedTracksOfType": {
				"!type": "fn(trackAssociationType: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"segmentForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +AVAssetTrackSegment"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMovieTrack"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerItemLegibleOutput": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerItemLegibleOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerItemLegibleOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerItemLegibleOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"advanceIntervalForDelegateInvocation": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"textStylingResolution": {
				"!type": "string"
			},
			"suppressesPlayerRendering": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithMediaSubtypesForNativeRepresentation": {
				"!type": "fn(subtypes: +Array) -> +AVPlayerItemLegibleOutput"
			},
			"setDelegateQueue": {
				"!type": "fn(delegate: +Object, delegateQueue: +Object) -> void"
			},
			"itemTimeForHostTime": {
				"!type": "fn(hostTimeInSeconds: number) -> +Object"
			},
			"itemTimeForMachAbsoluteTime": {
				"!type": "fn(machAbsoluteTime: number) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerItemLegibleOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetImageGenerator": {
		"assetImageGeneratorWithAsset": {
			"!type": "fn(asset: +AVAsset) -> +AVAssetImageGenerator"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetImageGenerator"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetImageGenerator"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetImageGenerator"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"requestedTimeToleranceBefore": {
				"!type": "+Object"
			},
			"requestedTimeToleranceAfter": {
				"!type": "+Object"
			},
			"apertureMode": {
				"!type": "string"
			},
			"videoComposition": {
				"!type": "+AVVideoComposition"
			},
			"asset": {
				"!type": "+AVAsset"
			},
			"appliesPreferredTrackTransform": {
				"!type": "bool"
			},
			"customVideoCompositor": {
				"!type": "+Object"
			},
			"maximumSize": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"cancelAllCGImageGeneration": {
				"!type": "fn() -> void"
			},
			"copyCGImageAtTimeActualTimeError": {
				"!type": "fn(requestedTime: +Object, actualTime: +Object, outError: +Object) -> +Object"
			},
			"initWithAsset": {
				"!type": "fn(asset: +AVAsset) -> +AVAssetImageGenerator"
			},
			"generateCGImagesAsynchronouslyForTimesCompletionHandler": {
				"!type": "fn(requestedTimes: +Array, handler: +Function) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetImageGenerator"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSSortDescriptor": {
		"sortDescriptorWithKeyAscendingSelector": {
			"!type": "fn(key: string, ascending: bool, selector: string) -> +NSSortDescriptor"
		},
		"sortDescriptorWithKeyAscending": {
			"!type": "fn(key: string, ascending: bool) -> +NSSortDescriptor"
		},
		"sortDescriptorWithKeyAscendingComparator": {
			"!type": "fn(key: string, ascending: bool, cmptr: +Function) -> +NSSortDescriptor"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSSortDescriptor"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSSortDescriptor"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSSortDescriptor"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsselector": {
				"!type": "string"
			},
			"reversedSortDescriptor": {
				"!type": "+Object"
			},
			"jscomparator": {
				"!type": "+Function"
			},
			"key": {
				"!type": "string"
			},
			"ascending": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithKeyAscending": {
				"!type": "fn(key: string, ascending: bool) -> +NSSortDescriptor"
			},
			"initWithKeyAscendingComparator": {
				"!type": "fn(key: string, ascending: bool, cmptr: +Function) -> +NSSortDescriptor"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSSortDescriptor"
			},
			"compareObjectToObject": {
				"!type": "fn(object1: +Object, object2: +Object) -> number"
			},
			"initWithKeyAscendingSelector": {
				"!type": "fn(key: string, ascending: bool, selector: string) -> +NSSortDescriptor"
			},
			"allowEvaluation": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSSortDescriptor"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetSegmentTrackReport": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetSegmentTrackReport"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetSegmentTrackReport"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetSegmentTrackReport"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"duration": {
				"!type": "+Object"
			},
			"trackID": {
				"!type": "number"
			},
			"firstVideoSampleInformation": {
				"!type": "+AVAssetSegmentReportSampleInformation"
			},
			"earliestPresentationTimeStamp": {
				"!type": "+Object"
			},
			"mediaType": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetSegmentTrackReport"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSAttributedString": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSAttributedString"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSAttributedString"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSAttributedString"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"length": {
				"!type": "number"
			},
			"string": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"attributeAtIndexEffectiveRange": {
				"!type": "fn(attrName: string, location: number, range: +Object) -> +Object"
			},
			"initWithAttributedString": {
				"!type": "fn(attrStr: +NSAttributedString) -> +NSAttributedString"
			},
			"initWithStringAttributes": {
				"!type": "fn(str: string, attrs: +Object) -> +NSAttributedString"
			},
			"enumerateAttributeInRangeOptionsUsingBlock": {
				"!type": "fn(attrName: string, enumerationRange: +Object, opts: number, block: +Function) -> void"
			},
			"attributesAtIndexLongestEffectiveRangeInRange": {
				"!type": "fn(location: number, range: +Object, rangeLimit: +Object) -> +Object"
			},
			"attributesAtIndexEffectiveRange": {
				"!type": "fn(location: number, range: +Object) -> +Object"
			},
			"attributeAtIndexLongestEffectiveRangeInRange": {
				"!type": "fn(attrName: string, location: number, range: +Object, rangeLimit: +Object) -> +Object"
			},
			"isEqualToAttributedString": {
				"!type": "fn(other: +NSAttributedString) -> bool"
			},
			"enumerateAttributesInRangeOptionsUsingBlock": {
				"!type": "fn(enumerationRange: +Object, opts: number, block: +Function) -> void"
			},
			"initWithString": {
				"!type": "fn(str: string) -> +NSAttributedString"
			},
			"attributedSubstringFromRange": {
				"!type": "fn(range: +Object) -> +NSAttributedString"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSAttributedString"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetReader": {
		"assetReaderWithAssetError": {
			"!type": "fn(asset: +AVAsset, outError: +Object) -> +AVAssetReader"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetReader"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetReader"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetReader"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"status": {
				"!type": "number"
			},
			"outputs": {
				"!type": "+Array"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"asset": {
				"!type": "+AVAsset"
			},
			"error": {
				"!type": "+NSError"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"canAddOutput": {
				"!type": "fn(output: +AVAssetReaderOutput) -> bool"
			},
			"addOutput": {
				"!type": "fn(output: +AVAssetReaderOutput) -> void"
			},
			"startReading": {
				"!type": "fn() -> bool"
			},
			"cancelReading": {
				"!type": "fn() -> void"
			},
			"initWithAssetError": {
				"!type": "fn(asset: +AVAsset, outError: +Object) -> +AVAssetReader"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetReader"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCapturePhotoBracketSettings": {
		"photoBracketSettingsWithRawPixelFormatTypeRawFileTypeProcessedFormatProcessedFileTypeBracketedSettings": {
			"!type": "fn(rawPixelFormatType: number, rawFileType: string, processedFormat: +Object, processedFileType: string, bracketedSettings: +Array) -> +AVCapturePhotoBracketSettings"
		},
		"photoBracketSettingsWithRawPixelFormatTypeProcessedFormatBracketedSettings": {
			"!type": "fn(rawPixelFormatType: number, processedFormat: +Object, bracketedSettings: +Array) -> +AVCapturePhotoBracketSettings"
		},
		"photoSettingsWithRawPixelFormatType": {
			"!type": "fn(rawPixelFormatType: number) -> +AVCapturePhotoBracketSettings"
		},
		"photoSettingsWithRawPixelFormatTypeRawFileTypeProcessedFormatProcessedFileType": {
			"!type": "fn(rawPixelFormatType: number, rawFileType: string, processedFormat: +Object, processedFileType: string) -> +AVCapturePhotoBracketSettings"
		},
		"photoSettings": {
			"!type": "fn() -> +AVCapturePhotoBracketSettings"
		},
		"photoSettingsFromPhotoSettings": {
			"!type": "fn(photoSettings: +AVCapturePhotoSettings) -> +AVCapturePhotoBracketSettings"
		},
		"photoSettingsWithFormat": {
			"!type": "fn(format: +Object) -> +AVCapturePhotoBracketSettings"
		},
		"photoSettingsWithRawPixelFormatTypeProcessedFormat": {
			"!type": "fn(rawPixelFormatType: number, processedFormat: +Object) -> +AVCapturePhotoBracketSettings"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCapturePhotoBracketSettings"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCapturePhotoBracketSettings"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCapturePhotoBracketSettings"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"bracketedSettings": {
				"!type": "+Array"
			},
			"lensStabilizationEnabled": {
				"!type": "bool"
			},
			"depthDataFiltered": {
				"!type": "bool"
			},
			"embedsSemanticSegmentationMattesInPhoto": {
				"!type": "bool"
			},
			"uniqueID": {
				"!type": "number"
			},
			"cameraCalibrationDataDeliveryEnabled": {
				"!type": "bool"
			},
			"embedsDepthDataInPhoto": {
				"!type": "bool"
			},
			"rawFileType": {
				"!type": "string"
			},
			"flashMode": {
				"!type": "number"
			},
			"virtualDeviceConstituentPhotoDeliveryEnabledDevices": {
				"!type": "+Array"
			},
			"metadata": {
				"!type": "+Object"
			},
			"portraitEffectsMatteDeliveryEnabled": {
				"!type": "bool"
			},
			"rawEmbeddedThumbnailPhotoFormat": {
				"!type": "+Object"
			},
			"highResolutionPhotoEnabled": {
				"!type": "bool"
			},
			"livePhotoVideoCodecType": {
				"!type": "string"
			},
			"format": {
				"!type": "+Object"
			},
			"livePhotoMovieFileURL": {
				"!type": "+NSURL"
			},
			"previewPhotoFormat": {
				"!type": "+Object"
			},
			"availableRawEmbeddedThumbnailPhotoCodecTypes": {
				"!type": "+Array"
			},
			"autoDualCameraFusionEnabled": {
				"!type": "bool"
			},
			"embedsPortraitEffectsMatteInPhoto": {
				"!type": "bool"
			},
			"availableEmbeddedThumbnailPhotoCodecTypes": {
				"!type": "+Array"
			},
			"livePhotoMovieMetadata": {
				"!type": "+Array"
			},
			"dualCameraDualPhotoDeliveryEnabled": {
				"!type": "bool"
			},
			"availablePreviewPhotoPixelFormatTypes": {
				"!type": "+Array"
			},
			"autoContentAwareDistortionCorrectionEnabled": {
				"!type": "bool"
			},
			"rawPhotoPixelFormatType": {
				"!type": "number"
			},
			"enabledSemanticSegmentationMatteTypes": {
				"!type": "+Array"
			},
			"embeddedThumbnailPhotoFormat": {
				"!type": "+Object"
			},
			"depthDataDeliveryEnabled": {
				"!type": "bool"
			},
			"autoVirtualDeviceFusionEnabled": {
				"!type": "bool"
			},
			"processedFileType": {
				"!type": "string"
			},
			"autoRedEyeReductionEnabled": {
				"!type": "bool"
			},
			"autoStillImageStabilizationEnabled": {
				"!type": "bool"
			},
			"photoQualityPrioritization": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCapturePhotoBracketSettings"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSCountedSet": {
		"setWithCapacity": {
			"!type": "fn(numItems: number) -> +NSCountedSet"
		},
		"setWithObjects": {
			"!type": "fn(firstObj: +Object, args: Array.prototype) -> +NSCountedSet"
		},
		"setWithArray": {
			"!type": "fn(array: +Array) -> +NSCountedSet"
		},
		"set": {
			"!type": "fn() -> +NSCountedSet"
		},
		"setWithSet": {
			"!type": "fn(set: +NSSet) -> +NSCountedSet"
		},
		"setWithObject": {
			"!type": "fn(object: +Object) -> +NSCountedSet"
		},
		"setWithObjectsCount": {
			"!type": "fn(objects: +Object, cnt: number) -> +NSCountedSet"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSCountedSet"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSCountedSet"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSCountedSet"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"allObjects": {
				"!type": "+Array"
			},
			"description": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSet": {
				"!type": "fn(set: +NSSet) -> +NSCountedSet"
			},
			"objectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"countForObject": {
				"!type": "fn(object: +Object) -> number"
			},
			"addObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"initWithCapacity": {
				"!type": "fn(numItems: number) -> +NSCountedSet"
			},
			"removeObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"initWithArray": {
				"!type": "fn(array: +Array) -> +NSCountedSet"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSCountedSet"
			},
			"removeObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"initWithCapacity": {
				"!type": "fn(numItems: number) -> +NSCountedSet"
			},
			"minusSet": {
				"!type": "fn(otherSet: +NSSet) -> void"
			},
			"filterUsingPredicate": {
				"!type": "fn(predicate: +NSPredicate) -> void"
			},
			"unionSet": {
				"!type": "fn(otherSet: +NSSet) -> void"
			},
			"addObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSCountedSet"
			},
			"removeAllObjects": {
				"!type": "fn() -> void"
			},
			"addObjectsFromArray": {
				"!type": "fn(array: +Array) -> void"
			},
			"intersectSet": {
				"!type": "fn(otherSet: +NSSet) -> void"
			},
			"setSet": {
				"!type": "fn(otherSet: +NSSet) -> void"
			},
			"initWithSet": {
				"!type": "fn(set: +NSSet) -> +NSCountedSet"
			},
			"anyObject": {
				"!type": "fn() -> +Object"
			},
			"initWithObjectsCount": {
				"!type": "fn(objects: +Object, cnt: number) -> +NSCountedSet"
			},
			"containsObject": {
				"!type": "fn(anObject: +Object) -> bool"
			},
			"enumerateObjectsWithOptionsUsingBlock": {
				"!type": "fn(opts: number, block: +Function) -> void"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSCountedSet"
			},
			"isEqualToSet": {
				"!type": "fn(otherSet: +NSSet) -> bool"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"sortedArrayUsingDescriptors": {
				"!type": "fn(sortDescriptors: +Array) -> +Array"
			},
			"makeObjectsPerformSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"initWithObjects": {
				"!type": "fn(firstObj: +Object, args: Array.prototype) -> +NSCountedSet"
			},
			"initWithArray": {
				"!type": "fn(array: +Array) -> +NSCountedSet"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"setByAddingObject": {
				"!type": "fn(anObject: +Object) -> +NSSet"
			},
			"descriptionWithLocale": {
				"!type": "fn(locale: +Object) -> string"
			},
			"isSubsetOfSet": {
				"!type": "fn(otherSet: +NSSet) -> bool"
			},
			"member": {
				"!type": "fn(object: +Object) -> +Object"
			},
			"filteredSetUsingPredicate": {
				"!type": "fn(predicate: +NSPredicate) -> +NSSet"
			},
			"objectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"objectsWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> +NSSet"
			},
			"enumerateObjectsUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"intersectsSet": {
				"!type": "fn(otherSet: +NSSet) -> bool"
			},
			"initWithSetCopyItems": {
				"!type": "fn(set: +NSSet, flag: bool) -> +NSCountedSet"
			},
			"setByAddingObjectsFromSet": {
				"!type": "fn(other: +NSSet) -> +NSSet"
			},
			"jsinit": {
				"!type": "fn() -> +NSCountedSet"
			},
			"setByAddingObjectsFromArray": {
				"!type": "fn(other: +Array) -> +NSSet"
			},
			"objectsPassingTest": {
				"!type": "fn(predicate: +Function) -> +NSSet"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"makeObjectsPerformSelectorWithObject": {
				"!type": "fn(aSelector: string, argument: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSCountedSet"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVSpeechUtterance": {
		"speechUtteranceWithString": {
			"!type": "fn(string: string) -> +AVSpeechUtterance"
		},
		"speechUtteranceWithAttributedString": {
			"!type": "fn(string: +NSAttributedString) -> +AVSpeechUtterance"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVSpeechUtterance"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVSpeechUtterance"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVSpeechUtterance"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"preUtteranceDelay": {
				"!type": "number"
			},
			"speechString": {
				"!type": "string"
			},
			"pitchMultiplier": {
				"!type": "number"
			},
			"volume": {
				"!type": "number"
			},
			"rate": {
				"!type": "number"
			},
			"voice": {
				"!type": "+AVSpeechSynthesisVoice"
			},
			"prefersAssistiveTechnologySettings": {
				"!type": "bool"
			},
			"postUtteranceDelay": {
				"!type": "number"
			},
			"attributedSpeechString": {
				"!type": "+NSAttributedString"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithAttributedString": {
				"!type": "fn(string: +NSAttributedString) -> +AVSpeechUtterance"
			},
			"initWithString": {
				"!type": "fn(string: string) -> +AVSpeechUtterance"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVSpeechUtterance"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSJSONSerialization": {
		"writeJSONObjectToStreamOptionsError": {
			"!type": "fn(obj: +Object, stream: +NSOutputStream, opt: number, error: +Object) -> number"
		},
		"JSONObjectWithStreamOptionsError": {
			"!type": "fn(stream: +NSInputStream, opt: number, error: +Object) -> +Object"
		},
		"JSONObjectWithDataOptionsError": {
			"!type": "fn(data: +NSData, opt: number, error: +Object) -> +Object"
		},
		"isValidJSONObject": {
			"!type": "fn(obj: +Object) -> bool"
		},
		"dataWithJSONObjectOptionsError": {
			"!type": "fn(obj: +Object, opt: number, error: +Object) -> +NSData"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSJSONSerialization"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSJSONSerialization"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSJSONSerialization"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSJSONSerialization"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSDateComponentsFormatter": {
		"localizedStringFromDateComponentsUnitsStyle": {
			"!type": "fn(components: +NSDateComponents, unitsStyle: number) -> string"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSDateComponentsFormatter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSDateComponentsFormatter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSDateComponentsFormatter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"allowedUnits": {
				"!type": "number"
			},
			"includesApproximationPhrase": {
				"!type": "bool"
			},
			"allowsFractionalUnits": {
				"!type": "bool"
			},
			"referenceDate": {
				"!type": "+Date"
			},
			"zeroFormattingBehavior": {
				"!type": "number"
			},
			"formattingContext": {
				"!type": "number"
			},
			"unitsStyle": {
				"!type": "number"
			},
			"includesTimeRemainingPhrase": {
				"!type": "bool"
			},
			"calendar": {
				"!type": "+NSCalendar"
			},
			"maximumUnitCount": {
				"!type": "number"
			},
			"collapsesLargestUnit": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"stringFromTimeInterval": {
				"!type": "fn(ti: number) -> string"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"stringFromDateToDate": {
				"!type": "fn(startDate: +Date, endDate: +Date) -> string"
			},
			"stringFromDateComponents": {
				"!type": "fn(components: +NSDateComponents) -> string"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"editingStringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription": {
				"!type": "fn(partialStringPtr: +Object, proposedSelRangePtr: +Object, origString: string, origSelRange: +Object, error: +Object) -> bool"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"attributedStringForObjectValueWithDefaultAttributes": {
				"!type": "fn(obj: +Object, attrs: +Object) -> +NSAttributedString"
			},
			"isPartialStringValidNewEditingStringErrorDescription": {
				"!type": "fn(partialString: string, newString: +Object, error: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSDateComponentsFormatter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetWriterInputGroup": {
		"assetWriterInputGroupWithInputsDefaultInput": {
			"!type": "fn(inputs: +Array, defaultInput: +AVAssetWriterInput) -> +AVAssetWriterInputGroup"
		},
		"mediaSelectionOptionsFromArrayWithoutMediaCharacteristics": {
			"!type": "fn(mediaSelectionOptions: +Array, mediaCharacteristics: +Array) -> +Array"
		},
		"mediaSelectionOptionsFromArrayWithMediaCharacteristics": {
			"!type": "fn(mediaSelectionOptions: +Array, mediaCharacteristics: +Array) -> +Array"
		},
		"mediaSelectionOptionsFromArrayFilteredAndSortedAccordingToPreferredLanguages": {
			"!type": "fn(mediaSelectionOptions: +Array, preferredLanguages: +Array) -> +Array"
		},
		"playableMediaSelectionOptionsFromArray": {
			"!type": "fn(mediaSelectionOptions: +Array) -> +Array"
		},
		"mediaSelectionOptionsFromArrayWithLocale": {
			"!type": "fn(mediaSelectionOptions: +Array, locale: +NSLocale) -> +Array"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetWriterInputGroup"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetWriterInputGroup"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetWriterInputGroup"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"inputs": {
				"!type": "+Array"
			},
			"defaultInput": {
				"!type": "+AVAssetWriterInput"
			},
			"defaultOption": {
				"!type": "+AVMediaSelectionOption"
			},
			"options": {
				"!type": "+Array"
			},
			"allowsEmptySelection": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithInputsDefaultInput": {
				"!type": "fn(inputs: +Array, defaultInput: +AVAssetWriterInput) -> +AVAssetWriterInputGroup"
			},
			"mediaSelectionOptionWithPropertyList": {
				"!type": "fn(plist: +Object) -> +AVMediaSelectionOption"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetWriterInputGroup"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSOrderedCollectionChange": {
		"changeWithObjectTypeIndex": {
			"!type": "fn(anObject: +Object, type: number, index: number) -> +NSOrderedCollectionChange"
		},
		"changeWithObjectTypeIndexAssociatedIndex": {
			"!type": "fn(anObject: +Object, type: number, index: number, associatedIndex: number) -> +NSOrderedCollectionChange"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSOrderedCollectionChange"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSOrderedCollectionChange"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSOrderedCollectionChange"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"index": {
				"!type": "number"
			},
			"changeType": {
				"!type": "number"
			},
			"object": {
				"!type": "+Object"
			},
			"associatedIndex": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithObjectTypeIndexAssociatedIndex": {
				"!type": "fn(anObject: +Object, type: number, index: number, associatedIndex: number) -> +NSOrderedCollectionChange"
			},
			"initWithObjectTypeIndex": {
				"!type": "fn(anObject: +Object, type: number, index: number) -> +NSOrderedCollectionChange"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSOrderedCollectionChange"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetReaderAudioMixOutput": {
		"assetReaderAudioMixOutputWithAudioTracksAudioSettings": {
			"!type": "fn(audioTracks: +Array, audioSettings: +Object) -> +AVAssetReaderAudioMixOutput"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetReaderAudioMixOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetReaderAudioMixOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetReaderAudioMixOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"audioSettings": {
				"!type": "+Object"
			},
			"audioTracks": {
				"!type": "+Array"
			},
			"audioTimePitchAlgorithm": {
				"!type": "string"
			},
			"audioMix": {
				"!type": "+AVAudioMix"
			},
			"alwaysCopiesSampleData": {
				"!type": "bool"
			},
			"mediaType": {
				"!type": "string"
			},
			"supportsRandomAccess": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithAudioTracksAudioSettings": {
				"!type": "fn(audioTracks: +Array, audioSettings: +Object) -> +AVAssetReaderAudioMixOutput"
			},
			"copyNextSampleBuffer": {
				"!type": "fn() -> +Object"
			},
			"resetForReadingTimeRanges": {
				"!type": "fn(timeRanges: +Array) -> void"
			},
			"markConfigurationAsFinal": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetReaderAudioMixOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSEnumerator": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSEnumerator"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSEnumerator"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSEnumerator"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"allObjects": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"nextObject": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSEnumerator"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CASpringAnimation": {
		"animationWithKeyPath": {
			"!type": "fn(path: string) -> +CASpringAnimation"
		},
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"animation": {
			"!type": "fn() -> +CASpringAnimation"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CASpringAnimation"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CASpringAnimation"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CASpringAnimation"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"settlingDuration": {
				"!type": "number"
			},
			"initialVelocity": {
				"!type": "number"
			},
			"mass": {
				"!type": "number"
			},
			"damping": {
				"!type": "number"
			},
			"stiffness": {
				"!type": "number"
			},
			"byValue": {
				"!type": "+Object"
			},
			"fromValue": {
				"!type": "+Object"
			},
			"toValue": {
				"!type": "+Object"
			},
			"valueFunction": {
				"!type": "+CAValueFunction"
			},
			"cumulative": {
				"!type": "bool"
			},
			"additive": {
				"!type": "bool"
			},
			"keyPath": {
				"!type": "string"
			},
			"timingFunction": {
				"!type": "+CAMediaTimingFunction"
			},
			"delegate": {
				"!type": "+Object"
			},
			"removedOnCompletion": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CASpringAnimation"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitLength": {
		"nanometers": {
			"!type": "fn() -> +NSUnitLength"
		},
		"feet": {
			"!type": "fn() -> +NSUnitLength"
		},
		"meters": {
			"!type": "fn() -> +NSUnitLength"
		},
		"astronomicalUnits": {
			"!type": "fn() -> +NSUnitLength"
		},
		"picometers": {
			"!type": "fn() -> +NSUnitLength"
		},
		"lightyears": {
			"!type": "fn() -> +NSUnitLength"
		},
		"parsecs": {
			"!type": "fn() -> +NSUnitLength"
		},
		"inches": {
			"!type": "fn() -> +NSUnitLength"
		},
		"micrometers": {
			"!type": "fn() -> +NSUnitLength"
		},
		"decimeters": {
			"!type": "fn() -> +NSUnitLength"
		},
		"fathoms": {
			"!type": "fn() -> +NSUnitLength"
		},
		"centimeters": {
			"!type": "fn() -> +NSUnitLength"
		},
		"megameters": {
			"!type": "fn() -> +NSUnitLength"
		},
		"nauticalMiles": {
			"!type": "fn() -> +NSUnitLength"
		},
		"yards": {
			"!type": "fn() -> +NSUnitLength"
		},
		"kilometers": {
			"!type": "fn() -> +NSUnitLength"
		},
		"furlongs": {
			"!type": "fn() -> +NSUnitLength"
		},
		"decameters": {
			"!type": "fn() -> +NSUnitLength"
		},
		"scandinavianMiles": {
			"!type": "fn() -> +NSUnitLength"
		},
		"miles": {
			"!type": "fn() -> +NSUnitLength"
		},
		"millimeters": {
			"!type": "fn() -> +NSUnitLength"
		},
		"hectometers": {
			"!type": "fn() -> +NSUnitLength"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitLength"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitLength"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitLength"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitLength"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitLength"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitLength"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitLength"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCompositionTrackSegment": {
		"compositionTrackSegmentWithURLTrackIDSourceTimeRangeTargetTimeRange": {
			"!type": "fn(URL: +NSURL, trackID: number, sourceTimeRange: +Object, targetTimeRange: +Object) -> +AVCompositionTrackSegment"
		},
		"compositionTrackSegmentWithTimeRange": {
			"!type": "fn(timeRange: +Object) -> +AVCompositionTrackSegment"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCompositionTrackSegment"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCompositionTrackSegment"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCompositionTrackSegment"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"sourceURL": {
				"!type": "+NSURL"
			},
			"sourceTrackID": {
				"!type": "number"
			},
			"empty": {
				"!type": "bool"
			},
			"timeMapping": {
				"!type": "+Object"
			},
			"empty": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithURLTrackIDSourceTimeRangeTargetTimeRange": {
				"!type": "fn(URL: +NSURL, trackID: number, sourceTimeRange: +Object, targetTimeRange: +Object) -> +AVCompositionTrackSegment"
			},
			"initWithTimeRange": {
				"!type": "fn(timeRange: +Object) -> +AVCompositionTrackSegment"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCompositionTrackSegment"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSNumberFormatter": {
		"setDefaultFormatterBehavior": {
			"!type": "fn(behavior: number) -> void"
		},
		"localizedStringFromNumberNumberStyle": {
			"!type": "fn(num: number, nstyle: number) -> string"
		},
		"defaultFormatterBehavior": {
			"!type": "fn() -> number"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSNumberFormatter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSNumberFormatter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSNumberFormatter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"paddingCharacter": {
				"!type": "string"
			},
			"internationalCurrencySymbol": {
				"!type": "string"
			},
			"locale": {
				"!type": "+NSLocale"
			},
			"multiplier": {
				"!type": "number"
			},
			"formatWidth": {
				"!type": "number"
			},
			"usesGroupingSeparator": {
				"!type": "bool"
			},
			"textAttributesForNegativeValues": {
				"!type": "+Object"
			},
			"textAttributesForZero": {
				"!type": "+Object"
			},
			"notANumberSymbol": {
				"!type": "string"
			},
			"partialStringValidationEnabled": {
				"!type": "bool"
			},
			"negativeInfinitySymbol": {
				"!type": "string"
			},
			"negativeSuffix": {
				"!type": "string"
			},
			"groupingSeparator": {
				"!type": "string"
			},
			"perMillSymbol": {
				"!type": "string"
			},
			"currencyCode": {
				"!type": "string"
			},
			"textAttributesForNegativeInfinity": {
				"!type": "+Object"
			},
			"usesSignificantDigits": {
				"!type": "bool"
			},
			"formatterBehavior": {
				"!type": "number"
			},
			"currencyGroupingSeparator": {
				"!type": "string"
			},
			"plusSign": {
				"!type": "string"
			},
			"minimum": {
				"!type": "number"
			},
			"percentSymbol": {
				"!type": "string"
			},
			"allowsFloats": {
				"!type": "bool"
			},
			"numberStyle": {
				"!type": "number"
			},
			"textAttributesForPositiveValues": {
				"!type": "+Object"
			},
			"generatesDecimalNumbers": {
				"!type": "bool"
			},
			"positiveInfinitySymbol": {
				"!type": "string"
			},
			"positiveFormat": {
				"!type": "string"
			},
			"exponentSymbol": {
				"!type": "string"
			},
			"textAttributesForNil": {
				"!type": "+Object"
			},
			"roundingIncrement": {
				"!type": "number"
			},
			"negativePrefix": {
				"!type": "string"
			},
			"paddingPosition": {
				"!type": "number"
			},
			"textAttributesForNotANumber": {
				"!type": "+Object"
			},
			"nilSymbol": {
				"!type": "string"
			},
			"currencySymbol": {
				"!type": "string"
			},
			"maximumSignificantDigits": {
				"!type": "number"
			},
			"textAttributesForPositiveInfinity": {
				"!type": "+Object"
			},
			"maximumIntegerDigits": {
				"!type": "number"
			},
			"minimumFractionDigits": {
				"!type": "number"
			},
			"maximumFractionDigits": {
				"!type": "number"
			},
			"minimumIntegerDigits": {
				"!type": "number"
			},
			"decimalSeparator": {
				"!type": "string"
			},
			"negativeFormat": {
				"!type": "string"
			},
			"formattingContext": {
				"!type": "number"
			},
			"alwaysShowsDecimalSeparator": {
				"!type": "bool"
			},
			"secondaryGroupingSize": {
				"!type": "number"
			},
			"positiveSuffix": {
				"!type": "string"
			},
			"maximum": {
				"!type": "number"
			},
			"currencyDecimalSeparator": {
				"!type": "string"
			},
			"positivePrefix": {
				"!type": "string"
			},
			"roundingMode": {
				"!type": "number"
			},
			"minimumSignificantDigits": {
				"!type": "number"
			},
			"groupingSize": {
				"!type": "number"
			},
			"zeroSymbol": {
				"!type": "string"
			},
			"minusSign": {
				"!type": "string"
			},
			"lenient": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"stringFromNumber": {
				"!type": "fn(number: number) -> string"
			},
			"getObjectValueForStringRangeError": {
				"!type": "fn(obj: +Object, string: string, rangep: +Object, error: +Object) -> bool"
			},
			"numberFromString": {
				"!type": "fn(string: string) -> number"
			},
			"editingStringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription": {
				"!type": "fn(partialStringPtr: +Object, proposedSelRangePtr: +Object, origString: string, origSelRange: +Object, error: +Object) -> bool"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"attributedStringForObjectValueWithDefaultAttributes": {
				"!type": "fn(obj: +Object, attrs: +Object) -> +NSAttributedString"
			},
			"isPartialStringValidNewEditingStringErrorDescription": {
				"!type": "fn(partialString: string, newString: +Object, error: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSNumberFormatter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioEnvironmentReverbParameters": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioEnvironmentReverbParameters"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioEnvironmentReverbParameters"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioEnvironmentReverbParameters"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"enable": {
				"!type": "bool"
			},
			"filterParameters": {
				"!type": "+AVAudioUnitEQFilterParameters"
			},
			"level": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"loadFactoryReverbPreset": {
				"!type": "fn(preset: number) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioEnvironmentReverbParameters"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetResourceLoadingRequest": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetResourceLoadingRequest"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetResourceLoadingRequest"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetResourceLoadingRequest"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"redirect": {
				"!type": "+NSURLRequest"
			},
			"requestor": {
				"!type": "+AVAssetResourceLoadingRequestor"
			},
			"request": {
				"!type": "+NSURLRequest"
			},
			"dataRequest": {
				"!type": "+AVAssetResourceLoadingDataRequest"
			},
			"finished": {
				"!type": "bool"
			},
			"cancelled": {
				"!type": "bool"
			},
			"response": {
				"!type": "+NSURLResponse"
			},
			"contentInformationRequest": {
				"!type": "+AVAssetResourceLoadingContentInformationRequest"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"streamingContentKeyRequestDataForAppContentIdentifierOptionsError": {
				"!type": "fn(appIdentifier: +NSData, contentIdentifier: +NSData, options: +Object, outError: +Object) -> +NSData"
			},
			"finishLoadingWithError": {
				"!type": "fn(error: +NSError) -> void"
			},
			"finishLoadingWithResponseDataRedirect": {
				"!type": "fn(response: +NSURLResponse, data: +NSData, redirect: +NSURLRequest) -> void"
			},
			"persistentContentKeyFromKeyVendorResponseOptionsError": {
				"!type": "fn(keyVendorResponse: +NSData, options: +Object, outError: +Object) -> +NSData"
			},
			"finishLoading": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetResourceLoadingRequest"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureSystemPressureState": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureSystemPressureState"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureSystemPressureState"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureSystemPressureState"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"factors": {
				"!type": "number"
			},
			"level": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureSystemPressureState"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMediaSelection": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMediaSelection"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMediaSelection"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMediaSelection"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"asset": {
				"!type": "+AVAsset"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"selectedMediaOptionInMediaSelectionGroup": {
				"!type": "fn(mediaSelectionGroup: +AVMediaSelectionGroup) -> +AVMediaSelectionOption"
			},
			"mediaSelectionCriteriaCanBeAppliedAutomaticallyToMediaSelectionGroup": {
				"!type": "fn(mediaSelectionGroup: +AVMediaSelectionGroup) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMediaSelection"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMetadataQuery": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMetadataQuery"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMetadataQuery"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMetadataQuery"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"predicate": {
				"!type": "+NSPredicate"
			},
			"valueLists": {
				"!type": "+Object"
			},
			"groupedResults": {
				"!type": "+Array"
			},
			"notificationBatchingInterval": {
				"!type": "number"
			},
			"searchScopes": {
				"!type": "+Array"
			},
			"started": {
				"!type": "bool"
			},
			"searchItems": {
				"!type": "+Array"
			},
			"gathering": {
				"!type": "bool"
			},
			"results": {
				"!type": "+Array"
			},
			"sortDescriptors": {
				"!type": "+Array"
			},
			"operationQueue": {
				"!type": "+NSOperationQueue"
			},
			"stopped": {
				"!type": "bool"
			},
			"delegate": {
				"!type": "+Object"
			},
			"valueListAttributes": {
				"!type": "+Array"
			},
			"resultCount": {
				"!type": "number"
			},
			"groupingAttributes": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"enableUpdates": {
				"!type": "fn() -> void"
			},
			"indexOfResult": {
				"!type": "fn(result: +Object) -> number"
			},
			"startQuery": {
				"!type": "fn() -> bool"
			},
			"resultAtIndex": {
				"!type": "fn(idx: number) -> +Object"
			},
			"enumerateResultsUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"disableUpdates": {
				"!type": "fn() -> void"
			},
			"valueOfAttributeForResultAtIndex": {
				"!type": "fn(attrName: string, idx: number) -> +Object"
			},
			"stopQuery": {
				"!type": "fn() -> void"
			},
			"enumerateResultsWithOptionsUsingBlock": {
				"!type": "fn(opts: number, block: +Function) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMetadataQuery"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetResourceLoadingContentInformationRequest": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetResourceLoadingContentInformationRequest"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetResourceLoadingContentInformationRequest"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetResourceLoadingContentInformationRequest"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"contentLength": {
				"!type": "number"
			},
			"byteRangeAccessSupported": {
				"!type": "bool"
			},
			"contentType": {
				"!type": "string"
			},
			"allowedContentTypes": {
				"!type": "+Array"
			},
			"renewalDate": {
				"!type": "+Date"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetResourceLoadingContentInformationRequest"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSFileSecurity": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSFileSecurity"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSFileSecurity"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSFileSecurity"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSFileSecurity"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSFileSecurity"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSXPCListener": {
		"anonymousListener": {
			"!type": "fn() -> +NSXPCListener"
		},
		"serviceListener": {
			"!type": "fn() -> +NSXPCListener"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSXPCListener"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSXPCListener"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSXPCListener"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"endpoint": {
				"!type": "+NSXPCListenerEndpoint"
			},
			"delegate": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"suspend": {
				"!type": "fn() -> void"
			},
			"invalidate": {
				"!type": "fn() -> void"
			},
			"resume": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSXPCListener"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSFileWrapper": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSFileWrapper"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSFileWrapper"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSFileWrapper"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"serializedRepresentation": {
				"!type": "+NSData"
			},
			"regularFileContents": {
				"!type": "+NSData"
			},
			"regularFile": {
				"!type": "bool"
			},
			"fileWrappers": {
				"!type": "+Object"
			},
			"filename": {
				"!type": "string"
			},
			"symbolicLink": {
				"!type": "bool"
			},
			"directory": {
				"!type": "bool"
			},
			"preferredFilename": {
				"!type": "string"
			},
			"symbolicLinkDestinationURL": {
				"!type": "+NSURL"
			},
			"fileAttributes": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initRegularFileWithContents": {
				"!type": "fn(contents: +NSData) -> +NSFileWrapper"
			},
			"initDirectoryWithFileWrappers": {
				"!type": "fn(childrenByPreferredName: +Object) -> +NSFileWrapper"
			},
			"addRegularFileWithContentsPreferredFilename": {
				"!type": "fn(data: +NSData, fileName: string) -> string"
			},
			"initWithURLOptionsError": {
				"!type": "fn(url: +NSURL, options: number, outError: +Object) -> +NSFileWrapper"
			},
			"initSymbolicLinkWithDestinationURL": {
				"!type": "fn(url: +NSURL) -> +NSFileWrapper"
			},
			"initWithSerializedRepresentation": {
				"!type": "fn(serializeRepresentation: +NSData) -> +NSFileWrapper"
			},
			"initWithCoder": {
				"!type": "fn(inCoder: +NSCoder) -> +NSFileWrapper"
			},
			"writeToURLOptionsOriginalContentsURLError": {
				"!type": "fn(url: +NSURL, options: number, originalContentsURL: +NSURL, outError: +Object) -> bool"
			},
			"readFromURLOptionsError": {
				"!type": "fn(url: +NSURL, options: number, outError: +Object) -> bool"
			},
			"keyForFileWrapper": {
				"!type": "fn(child: +NSFileWrapper) -> string"
			},
			"addFileWrapper": {
				"!type": "fn(child: +NSFileWrapper) -> string"
			},
			"matchesContentsOfURL": {
				"!type": "fn(url: +NSURL) -> bool"
			},
			"removeFileWrapper": {
				"!type": "fn(child: +NSFileWrapper) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSFileWrapper"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureInput": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureInput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureInput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureInput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"ports": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureInput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureConnection": {
		"connectionWithInputPortsOutput": {
			"!type": "fn(ports: +Array, output: +AVCaptureOutput) -> +AVCaptureConnection"
		},
		"connectionWithInputPortVideoPreviewLayer": {
			"!type": "fn(port: +AVCaptureInputPort, layer: +AVCaptureVideoPreviewLayer) -> +AVCaptureConnection"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureConnection"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureConnection"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureConnection"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"videoOrientation": {
				"!type": "number"
			},
			"videoScaleAndCropFactor": {
				"!type": "number"
			},
			"cameraIntrinsicMatrixDeliveryEnabled": {
				"!type": "bool"
			},
			"audioChannels": {
				"!type": "+Array"
			},
			"supportsVideoMinFrameDuration": {
				"!type": "bool"
			},
			"supportsVideoStabilization": {
				"!type": "bool"
			},
			"activeVideoStabilizationMode": {
				"!type": "number"
			},
			"videoMaxFrameDuration": {
				"!type": "+Object"
			},
			"videoMirrored": {
				"!type": "bool"
			},
			"videoMinFrameDuration": {
				"!type": "+Object"
			},
			"preferredVideoStabilizationMode": {
				"!type": "number"
			},
			"videoPreviewLayer": {
				"!type": "+AVCaptureVideoPreviewLayer"
			},
			"videoStabilizationEnabled": {
				"!type": "bool"
			},
			"output": {
				"!type": "+AVCaptureOutput"
			},
			"active": {
				"!type": "bool"
			},
			"supportsVideoMirroring": {
				"!type": "bool"
			},
			"enablesVideoStabilizationWhenAvailable": {
				"!type": "bool"
			},
			"videoMaxScaleAndCropFactor": {
				"!type": "number"
			},
			"enabled": {
				"!type": "bool"
			},
			"cameraIntrinsicMatrixDeliverySupported": {
				"!type": "bool"
			},
			"supportsVideoOrientation": {
				"!type": "bool"
			},
			"inputPorts": {
				"!type": "+Array"
			},
			"supportsVideoMaxFrameDuration": {
				"!type": "bool"
			},
			"automaticallyAdjustsVideoMirroring": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithInputPortVideoPreviewLayer": {
				"!type": "fn(port: +AVCaptureInputPort, layer: +AVCaptureVideoPreviewLayer) -> +AVCaptureConnection"
			},
			"initWithInputPortsOutput": {
				"!type": "fn(ports: +Array, output: +AVCaptureOutput) -> +AVCaptureConnection"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureConnection"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAsynchronousCIImageFilteringRequest": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAsynchronousCIImageFilteringRequest"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAsynchronousCIImageFilteringRequest"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAsynchronousCIImageFilteringRequest"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"renderSize": {
				"!type": "+Object"
			},
			"sourceImage": {
				"!type": "+CIImage"
			},
			"compositionTime": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"finishWithError": {
				"!type": "fn(error: +NSError) -> void"
			},
			"finishWithImageContext": {
				"!type": "fn(filteredImage: +CIImage, context: +CIContext) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAsynchronousCIImageFilteringRequest"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVURLAsset": {
		"URLAssetWithURLOptions": {
			"!type": "fn(URL: +NSURL, options: +Object) -> +AVURLAsset"
		},
		"audiovisualMIMETypes": {
			"!type": "fn() -> +Array"
		},
		"isPlayableExtendedMIMEType": {
			"!type": "fn(extendedMIMEType: string) -> bool"
		},
		"audiovisualTypes": {
			"!type": "fn() -> +Array"
		},
		"assetWithURL": {
			"!type": "fn(URL: +NSURL) -> +AVURLAsset"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVURLAsset"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVURLAsset"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVURLAsset"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"URL": {
				"!type": "+NSURL"
			},
			"resourceLoader": {
				"!type": "+AVAssetResourceLoader"
			},
			"assetCache": {
				"!type": "+AVAssetCache"
			},
			"mayRequireContentKeysForMediaDataProcessing": {
				"!type": "bool"
			},
			"creationDate": {
				"!type": "+AVMetadataItem"
			},
			"referenceRestrictions": {
				"!type": "number"
			},
			"canContainFragments": {
				"!type": "bool"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"preferredRate": {
				"!type": "number"
			},
			"composable": {
				"!type": "bool"
			},
			"tracks": {
				"!type": "+Array"
			},
			"containsFragments": {
				"!type": "bool"
			},
			"availableMediaCharacteristicsWithMediaSelectionOptions": {
				"!type": "+Array"
			},
			"preferredMediaSelection": {
				"!type": "+AVMediaSelection"
			},
			"duration": {
				"!type": "+Object"
			},
			"providesPreciseDurationAndTiming": {
				"!type": "bool"
			},
			"compatibleWithAirPlayVideo": {
				"!type": "bool"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"exportable": {
				"!type": "bool"
			},
			"lyrics": {
				"!type": "string"
			},
			"trackGroups": {
				"!type": "+Array"
			},
			"compatibleWithSavedPhotosAlbum": {
				"!type": "bool"
			},
			"readable": {
				"!type": "bool"
			},
			"hasProtectedContent": {
				"!type": "bool"
			},
			"overallDurationHint": {
				"!type": "+Object"
			},
			"availableChapterLocales": {
				"!type": "+Array"
			},
			"minimumTimeOffsetFromLive": {
				"!type": "+Object"
			},
			"allMediaSelections": {
				"!type": "+Array"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"compatibleTrackForCompositionTrack": {
				"!type": "fn(compositionTrack: +AVCompositionTrack) -> +AVAssetTrack"
			},
			"initWithURLOptions": {
				"!type": "fn(URL: +NSURL, options: +Object) -> +AVURLAsset"
			},
			"unusedTrackID": {
				"!type": "fn() -> number"
			},
			"chapterMetadataGroupsWithTitleLocaleContainingItemsWithCommonKeys": {
				"!type": "fn(locale: +NSLocale, commonKeys: +Array) -> +Array"
			},
			"cancelLoading": {
				"!type": "fn() -> void"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVAssetTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"mediaSelectionGroupForMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +AVMediaSelectionGroup"
			},
			"chapterMetadataGroupsBestMatchingPreferredLanguages": {
				"!type": "fn(preferredLanguages: +Array) -> +Array"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVURLAsset"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"EAGLContext": {
		"currentContext": {
			"!type": "fn() -> +EAGLContext"
		},
		"setCurrentContext": {
			"!type": "fn(context: +EAGLContext) -> bool"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +EAGLContext"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +EAGLContext"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +EAGLContext"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"API": {
				"!type": "number"
			},
			"sharegroup": {
				"!type": "+EAGLSharegroup"
			},
			"multiThreaded": {
				"!type": "bool"
			},
			"debugLabel": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"presentRenderbuffer": {
				"!type": "fn(target: number) -> bool"
			},
			"presentRenderbufferAtTime": {
				"!type": "fn(target: number, presentationTime: number) -> bool"
			},
			"initWithAPI": {
				"!type": "fn(api: number) -> +EAGLContext"
			},
			"renderbufferStorageFromDrawable": {
				"!type": "fn(target: number, drawable: +Object) -> bool"
			},
			"presentRenderbufferAfterMinimumDuration": {
				"!type": "fn(target: number, duration: number) -> bool"
			},
			"initWithAPISharegroup": {
				"!type": "fn(api: number, sharegroup: +EAGLSharegroup) -> +EAGLContext"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +EAGLContext"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetReaderVideoCompositionOutput": {
		"assetReaderVideoCompositionOutputWithVideoTracksVideoSettings": {
			"!type": "fn(videoTracks: +Array, videoSettings: +Object) -> +AVAssetReaderVideoCompositionOutput"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetReaderVideoCompositionOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetReaderVideoCompositionOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetReaderVideoCompositionOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"customVideoCompositor": {
				"!type": "+Object"
			},
			"videoComposition": {
				"!type": "+AVVideoComposition"
			},
			"videoTracks": {
				"!type": "+Array"
			},
			"videoSettings": {
				"!type": "+Object"
			},
			"alwaysCopiesSampleData": {
				"!type": "bool"
			},
			"mediaType": {
				"!type": "string"
			},
			"supportsRandomAccess": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithVideoTracksVideoSettings": {
				"!type": "fn(videoTracks: +Array, videoSettings: +Object) -> +AVAssetReaderVideoCompositionOutput"
			},
			"copyNextSampleBuffer": {
				"!type": "fn() -> +Object"
			},
			"resetForReadingTimeRanges": {
				"!type": "fn(timeRanges: +Array) -> void"
			},
			"markConfigurationAsFinal": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetReaderVideoCompositionOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMutableMetadataItem": {
		"metadataItem": {
			"!type": "fn() -> +AVMutableMetadataItem"
		},
		"metadataItemWithPropertiesOfMetadataItemValueLoadingHandler": {
			"!type": "fn(metadataItem: +AVMetadataItem, handler: +Function) -> +AVMetadataItem"
		},
		"keySpaceForIdentifier": {
			"!type": "fn(identifier: string) -> string"
		},
		"identifierForKeyKeySpace": {
			"!type": "fn(key: +Object, keySpace: string) -> string"
		},
		"metadataItemsFromArrayWithKeyKeySpace": {
			"!type": "fn(metadataItems: +Array, key: +Object, keySpace: string) -> +Array"
		},
		"metadataItemsFromArrayFilteredByIdentifier": {
			"!type": "fn(metadataItems: +Array, identifier: string) -> +Array"
		},
		"metadataItemsFromArrayWithLocale": {
			"!type": "fn(metadataItems: +Array, locale: +NSLocale) -> +Array"
		},
		"metadataItemsFromArrayFilteredAndSortedAccordingToPreferredLanguages": {
			"!type": "fn(metadataItems: +Array, preferredLanguages: +Array) -> +Array"
		},
		"keyForIdentifier": {
			"!type": "fn(identifier: string) -> +Object"
		},
		"metadataItemsFromArrayFilteredByMetadataItemFilter": {
			"!type": "fn(metadataItems: +Array, metadataItemFilter: +AVMetadataItemFilter) -> +Array"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMutableMetadataItem"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMutableMetadataItem"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMutableMetadataItem"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"startDate": {
				"!type": "+Date"
			},
			"keySpace": {
				"!type": "string"
			},
			"locale": {
				"!type": "+NSLocale"
			},
			"extendedLanguageTag": {
				"!type": "string"
			},
			"value": {
				"!type": "+Object"
			},
			"dataType": {
				"!type": "string"
			},
			"extraAttributes": {
				"!type": "+Object"
			},
			"key": {
				"!type": "+Object"
			},
			"time": {
				"!type": "+Object"
			},
			"duration": {
				"!type": "+Object"
			},
			"identifier": {
				"!type": "string"
			},
			"startDate": {
				"!type": "+Date"
			},
			"dateValue": {
				"!type": "+Date"
			},
			"keySpace": {
				"!type": "string"
			},
			"locale": {
				"!type": "+NSLocale"
			},
			"commonKey": {
				"!type": "string"
			},
			"dataValue": {
				"!type": "+NSData"
			},
			"extendedLanguageTag": {
				"!type": "string"
			},
			"value": {
				"!type": "+Object"
			},
			"dataType": {
				"!type": "string"
			},
			"numberValue": {
				"!type": "number"
			},
			"extraAttributes": {
				"!type": "+Object"
			},
			"key": {
				"!type": "+Object"
			},
			"time": {
				"!type": "+Object"
			},
			"duration": {
				"!type": "+Object"
			},
			"stringValue": {
				"!type": "string"
			},
			"identifier": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"statusOfValueForKeyError": {
				"!type": "fn(key: string, outError: +Object) -> number"
			},
			"loadValuesAsynchronouslyForKeysCompletionHandler": {
				"!type": "fn(keys: +Array, handler: +Function) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMutableMetadataItem"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSCondition": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSCondition"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSCondition"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSCondition"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"name": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"signal": {
				"!type": "fn() -> void"
			},
			"broadcast": {
				"!type": "fn() -> void"
			},
			"waitUntilDate": {
				"!type": "fn(limit: +Date) -> bool"
			},
			"wait": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSCondition"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLCredential": {
		"credentialWithIdentityCertificatesPersistence": {
			"!type": "fn(identity: +Object, certArray: +Array, persistence: number) -> +NSURLCredential"
		},
		"credentialWithUserPasswordPersistence": {
			"!type": "fn(user: string, password: string, persistence: number) -> +NSURLCredential"
		},
		"credentialForTrust": {
			"!type": "fn(trust: +Object) -> +NSURLCredential"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLCredential"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLCredential"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLCredential"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"hasPassword": {
				"!type": "bool"
			},
			"persistence": {
				"!type": "number"
			},
			"certificates": {
				"!type": "+Array"
			},
			"password": {
				"!type": "string"
			},
			"identity": {
				"!type": "+Object"
			},
			"user": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithTrust": {
				"!type": "fn(trust: +Object) -> +NSURLCredential"
			},
			"initWithUserPasswordPersistence": {
				"!type": "fn(user: string, password: string, persistence: number) -> +NSURLCredential"
			},
			"initWithIdentityCertificatesPersistence": {
				"!type": "fn(identity: +Object, certArray: +Array, persistence: number) -> +NSURLCredential"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLCredential"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSDecimalNumberHandler": {
		"decimalNumberHandlerWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero": {
			"!type": "fn(roundingMode: number, scale: number, exact: bool, overflow: bool, underflow: bool, divideByZero: bool) -> +NSDecimalNumberHandler"
		},
		"defaultDecimalNumberHandler": {
			"!type": "fn() -> +NSDecimalNumberHandler"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSDecimalNumberHandler"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSDecimalNumberHandler"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSDecimalNumberHandler"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero": {
				"!type": "fn(roundingMode: number, scale: number, exact: bool, overflow: bool, underflow: bool, divideByZero: bool) -> +NSDecimalNumberHandler"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSDecimalNumberHandler"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLSessionConfiguration": {
		"jsnew": {
			"!type": "fn() -> +NSURLSessionConfiguration"
		},
		"backgroundSessionConfigurationWithIdentifier": {
			"!type": "fn(identifier: string) -> +NSURLSessionConfiguration"
		},
		"ephemeralSessionConfiguration": {
			"!type": "fn() -> +NSURLSessionConfiguration"
		},
		"defaultSessionConfiguration": {
			"!type": "fn() -> +NSURLSessionConfiguration"
		},
		"backgroundSessionConfiguration": {
			"!type": "fn(identifier: string) -> +NSURLSessionConfiguration"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLSessionConfiguration"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLSessionConfiguration"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionConfiguration"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"timeoutIntervalForResource": {
				"!type": "number"
			},
			"allowsCellularAccess": {
				"!type": "bool"
			},
			"URLCredentialStorage": {
				"!type": "+NSURLCredentialStorage"
			},
			"multipathServiceType": {
				"!type": "number"
			},
			"requestCachePolicy": {
				"!type": "number"
			},
			"sessionSendsLaunchEvents": {
				"!type": "bool"
			},
			"timeoutIntervalForRequest": {
				"!type": "number"
			},
			"networkServiceType": {
				"!type": "number"
			},
			"discretionary": {
				"!type": "bool"
			},
			"TLSMinimumSupportedProtocol": {
				"!type": "number"
			},
			"HTTPShouldUsePipelining": {
				"!type": "bool"
			},
			"HTTPShouldSetCookies": {
				"!type": "bool"
			},
			"HTTPAdditionalHeaders": {
				"!type": "+Object"
			},
			"HTTPMaximumConnectionsPerHost": {
				"!type": "number"
			},
			"TLSMaximumSupportedProtocolVersion": {
				"!type": "number"
			},
			"TLSMaximumSupportedProtocol": {
				"!type": "number"
			},
			"waitsForConnectivity": {
				"!type": "bool"
			},
			"HTTPCookieAcceptPolicy": {
				"!type": "number"
			},
			"allowsConstrainedNetworkAccess": {
				"!type": "bool"
			},
			"shouldUseExtendedBackgroundIdleMode": {
				"!type": "bool"
			},
			"connectionProxyDictionary": {
				"!type": "+Object"
			},
			"HTTPCookieStorage": {
				"!type": "+NSHTTPCookieStorage"
			},
			"URLCache": {
				"!type": "+NSURLCache"
			},
			"protocolClasses": {
				"!type": "+Array"
			},
			"sharedContainerIdentifier": {
				"!type": "string"
			},
			"identifier": {
				"!type": "string"
			},
			"TLSMinimumSupportedProtocolVersion": {
				"!type": "number"
			},
			"allowsExpensiveNetworkAccess": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionConfiguration"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionConfiguration"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSDictionary": {
		"dictionaryWithObjectsForKeysCount": {
			"!type": "fn(objects: +Object, keys: +Object, cnt: number) -> +Object"
		},
		"dictionaryWithDictionary": {
			"!type": "fn(dict: +Object) -> +Object"
		},
		"dictionaryWithContentsOfFile": {
			"!type": "fn(path: string) -> +Object"
		},
		"dictionary": {
			"!type": "fn() -> +Object"
		},
		"dictionaryWithObjectsForKeys": {
			"!type": "fn(objects: +Array, keys: +Array) -> +Object"
		},
		"sharedKeySetForKeys": {
			"!type": "fn(keys: +Array) -> +Object"
		},
		"dictionaryWithObjectsAndKeys": {
			"!type": "fn(firstObject: +Object, args: Array.prototype) -> +Object"
		},
		"dictionaryWithContentsOfURLError": {
			"!type": "fn(url: +NSURL, error: +Object) -> +Object"
		},
		"dictionaryWithObjectForKey": {
			"!type": "fn(object: +Object, key: +Object) -> +Object"
		},
		"dictionaryWithContentsOfURL": {
			"!type": "fn(url: +NSURL) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +Object"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"allValues": {
				"!type": "+Array"
			},
			"description": {
				"!type": "string"
			},
			"allKeys": {
				"!type": "+Array"
			},
			"descriptionInStringsFileFormat": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"keysSortedByValueUsingComparator": {
				"!type": "fn(cmptr: +Function) -> +Array"
			},
			"fileSystemNumber": {
				"!type": "fn() -> number"
			},
			"countByEnumeratingWithStateObjectsCount": {
				"!type": "fn(state: +Object, buffer: +Object, len: number) -> number"
			},
			"keysOfEntriesWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> +NSSet"
			},
			"initWithContentsOfURLError": {
				"!type": "fn(url: +NSURL, error: +Object) -> +Object"
			},
			"fileGroupOwnerAccountName": {
				"!type": "fn() -> string"
			},
			"initWithContentsOfFile": {
				"!type": "fn(path: string) -> +Object"
			},
			"getObjectsAndKeysCount": {
				"!type": "fn(objects: +Object, keys: +Object, count: number) -> void"
			},
			"enumerateKeysAndObjectsWithOptionsUsingBlock": {
				"!type": "fn(opts: number, block: +Function) -> void"
			},
			"fileCreationDate": {
				"!type": "fn() -> +Date"
			},
			"fileModificationDate": {
				"!type": "fn() -> +Date"
			},
			"objectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"fileExtensionHidden": {
				"!type": "fn() -> bool"
			},
			"allKeysForObject": {
				"!type": "fn(anObject: +Object) -> +Array"
			},
			"fileType": {
				"!type": "fn() -> string"
			},
			"fileIsImmutable": {
				"!type": "fn() -> bool"
			},
			"writeToURLAtomically": {
				"!type": "fn(url: +NSURL, atomically: bool) -> bool"
			},
			"enumerateKeysAndObjectsUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +Object"
			},
			"initWithDictionaryCopyItems": {
				"!type": "fn(otherDictionary: +Object, flag: bool) -> +Object"
			},
			"keysOfEntriesPassingTest": {
				"!type": "fn(predicate: +Function) -> +NSSet"
			},
			"fileGroupOwnerAccountID": {
				"!type": "fn() -> number"
			},
			"initWithObjectsForKeysCount": {
				"!type": "fn(objects: +Object, keys: +Object, cnt: number) -> +Object"
			},
			"keysSortedByValueWithOptionsUsingComparator": {
				"!type": "fn(opts: number, cmptr: +Function) -> +Array"
			},
			"descriptionWithLocale": {
				"!type": "fn(locale: +Object) -> string"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"keyEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"fileIsAppendOnly": {
				"!type": "fn() -> bool"
			},
			"fileOwnerAccountName": {
				"!type": "fn() -> string"
			},
			"fileSize": {
				"!type": "fn() -> number"
			},
			"getObjectsAndKeys": {
				"!type": "fn(objects: +Object, keys: +Object) -> void"
			},
			"keysSortedByValueUsingSelector": {
				"!type": "fn(comparator: string) -> +Array"
			},
			"fileSystemFileNumber": {
				"!type": "fn() -> number"
			},
			"fileHFSTypeCode": {
				"!type": "fn() -> number"
			},
			"initWithObjectsForKeys": {
				"!type": "fn(objects: +Array, keys: +Array) -> +Object"
			},
			"initWithObjectsAndKeys": {
				"!type": "fn(firstObject: +Object, args: Array.prototype) -> +Object"
			},
			"fileHFSCreatorCode": {
				"!type": "fn() -> number"
			},
			"initWithContentsOfURL": {
				"!type": "fn(url: +NSURL) -> +Object"
			},
			"objectForKeyedSubscript": {
				"!type": "fn(key: +Object) -> +Object"
			},
			"filePosixPermissions": {
				"!type": "fn() -> number"
			},
			"writeToFileAtomically": {
				"!type": "fn(path: string, useAuxiliaryFile: bool) -> bool"
			},
			"descriptionWithLocaleIndent": {
				"!type": "fn(locale: +Object, level: number) -> string"
			},
			"fileOwnerAccountID": {
				"!type": "fn() -> number"
			},
			"objectsForKeysNotFoundMarker": {
				"!type": "fn(keys: +Array, marker: +Object) -> +Array"
			},
			"isEqualToDictionary": {
				"!type": "fn(otherDictionary: +Object) -> bool"
			},
			"writeToURLError": {
				"!type": "fn(url: +NSURL, error: +Object) -> bool"
			},
			"initWithDictionary": {
				"!type": "fn(otherDictionary: +Object) -> +Object"
			},
			"objectForKey": {
				"!type": "fn(aKey: +Object) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +Object"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CAPropertyAnimation": {
		"animationWithKeyPath": {
			"!type": "fn(path: string) -> +CAPropertyAnimation"
		},
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"animation": {
			"!type": "fn() -> +CAPropertyAnimation"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CAPropertyAnimation"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CAPropertyAnimation"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CAPropertyAnimation"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"valueFunction": {
				"!type": "+CAValueFunction"
			},
			"cumulative": {
				"!type": "bool"
			},
			"additive": {
				"!type": "bool"
			},
			"keyPath": {
				"!type": "string"
			},
			"timingFunction": {
				"!type": "+CAMediaTimingFunction"
			},
			"delegate": {
				"!type": "+Object"
			},
			"removedOnCompletion": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAPropertyAnimation"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVFragmentedAssetTrack": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVFragmentedAssetTrack"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVFragmentedAssetTrack"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVFragmentedAssetTrack"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"languageCode": {
				"!type": "string"
			},
			"minFrameDuration": {
				"!type": "+Object"
			},
			"formatDescriptions": {
				"!type": "+Array"
			},
			"availableTrackAssociationTypes": {
				"!type": "+Array"
			},
			"nominalFrameRate": {
				"!type": "number"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"estimatedDataRate": {
				"!type": "number"
			},
			"naturalTimeScale": {
				"!type": "number"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"requiresFrameReordering": {
				"!type": "bool"
			},
			"hasAudioSampleDependencies": {
				"!type": "bool"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"selfContained": {
				"!type": "bool"
			},
			"segments": {
				"!type": "+Array"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"extendedLanguageTag": {
				"!type": "string"
			},
			"mediaType": {
				"!type": "string"
			},
			"asset": {
				"!type": "+AVAsset"
			},
			"trackID": {
				"!type": "number"
			},
			"totalSampleDataLength": {
				"!type": "number"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"decodable": {
				"!type": "bool"
			},
			"enabled": {
				"!type": "bool"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hasMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> bool"
			},
			"samplePresentationTimeForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +Object"
			},
			"associatedTracksOfType": {
				"!type": "fn(trackAssociationType: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"segmentForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +AVAssetTrackSegment"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVFragmentedAssetTrack"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetTrackSegment": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetTrackSegment"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetTrackSegment"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetTrackSegment"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"timeMapping": {
				"!type": "+Object"
			},
			"empty": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetTrackSegment"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLAuthenticationChallenge": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLAuthenticationChallenge"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLAuthenticationChallenge"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLAuthenticationChallenge"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"protectionSpace": {
				"!type": "+NSURLProtectionSpace"
			},
			"sender": {
				"!type": "+Object"
			},
			"failureResponse": {
				"!type": "+NSURLResponse"
			},
			"error": {
				"!type": "+NSError"
			},
			"previousFailureCount": {
				"!type": "number"
			},
			"proposedCredential": {
				"!type": "+NSURLCredential"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithProtectionSpaceProposedCredentialPreviousFailureCountFailureResponseErrorSender": {
				"!type": "fn(space: +NSURLProtectionSpace, credential: +NSURLCredential, previousFailureCount: number, response: +NSURLResponse, error: +NSError, sender: +Object) -> +NSURLAuthenticationChallenge"
			},
			"initWithAuthenticationChallengeSender": {
				"!type": "fn(challenge: +NSURLAuthenticationChallenge, sender: +Object) -> +NSURLAuthenticationChallenge"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLAuthenticationChallenge"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSDirectoryEnumerator": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSDirectoryEnumerator"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSDirectoryEnumerator"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSDirectoryEnumerator"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"directoryAttributes": {
				"!type": "+Object"
			},
			"level": {
				"!type": "number"
			},
			"isEnumeratingDirectoryPostOrder": {
				"!type": "bool"
			},
			"fileAttributes": {
				"!type": "+Object"
			},
			"allObjects": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"skipDescendents": {
				"!type": "fn() -> void"
			},
			"skipDescendants": {
				"!type": "fn() -> void"
			},
			"nextObject": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSDirectoryEnumerator"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSPropertyListSerialization": {
		"propertyListWithStreamOptionsFormatError": {
			"!type": "fn(stream: +NSInputStream, opt: number, format: +Object, error: +Object) -> +Object"
		},
		"propertyListFromDataMutabilityOptionFormatErrorDescription": {
			"!type": "fn(data: +NSData, opt: number, format: +Object, errorString: +Object) -> +Object"
		},
		"propertyListIsValidForFormat": {
			"!type": "fn(plist: +Object, format: number) -> bool"
		},
		"dataFromPropertyListFormatErrorDescription": {
			"!type": "fn(plist: +Object, format: number, errorString: +Object) -> +NSData"
		},
		"writePropertyListToStreamFormatOptionsError": {
			"!type": "fn(plist: +Object, stream: +NSOutputStream, format: number, opt: number, error: +Object) -> number"
		},
		"dataWithPropertyListFormatOptionsError": {
			"!type": "fn(plist: +Object, format: number, opt: number, error: +Object) -> +NSData"
		},
		"propertyListWithDataOptionsFormatError": {
			"!type": "fn(data: +NSData, opt: number, format: +Object, error: +Object) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSPropertyListSerialization"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSPropertyListSerialization"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSPropertyListSerialization"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSPropertyListSerialization"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVVideoCompositionRenderHint": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVVideoCompositionRenderHint"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVVideoCompositionRenderHint"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVVideoCompositionRenderHint"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"startCompositionTime": {
				"!type": "+Object"
			},
			"endCompositionTime": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVVideoCompositionRenderHint"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLSessionStreamTask": {
		"jsnew": {
			"!type": "fn() -> +NSURLSessionStreamTask"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionStreamTask"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLSessionStreamTask"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLSessionStreamTask"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionStreamTask"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"countOfBytesSent": {
				"!type": "number"
			},
			"earliestBeginDate": {
				"!type": "+Date"
			},
			"countOfBytesExpectedToReceive": {
				"!type": "number"
			},
			"taskDescription": {
				"!type": "string"
			},
			"countOfBytesExpectedToSend": {
				"!type": "number"
			},
			"state": {
				"!type": "number"
			},
			"priority": {
				"!type": "number"
			},
			"countOfBytesClientExpectsToSend": {
				"!type": "number"
			},
			"taskIdentifier": {
				"!type": "number"
			},
			"countOfBytesReceived": {
				"!type": "number"
			},
			"error": {
				"!type": "+NSError"
			},
			"currentRequest": {
				"!type": "+NSURLRequest"
			},
			"progress": {
				"!type": "+NSProgress"
			},
			"countOfBytesClientExpectsToReceive": {
				"!type": "number"
			},
			"response": {
				"!type": "+NSURLResponse"
			},
			"originalRequest": {
				"!type": "+NSURLRequest"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"closeRead": {
				"!type": "fn() -> void"
			},
			"stopSecureConnection": {
				"!type": "fn() -> void"
			},
			"writeDataTimeoutCompletionHandler": {
				"!type": "fn(data: +NSData, timeout: number, completionHandler: +Function) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionStreamTask"
			},
			"captureStreams": {
				"!type": "fn() -> void"
			},
			"closeWrite": {
				"!type": "fn() -> void"
			},
			"readDataOfMinLengthMaxLengthTimeoutCompletionHandler": {
				"!type": "fn(minBytes: number, maxBytes: number, timeout: number, completionHandler: +Function) -> void"
			},
			"startSecureConnection": {
				"!type": "fn() -> void"
			},
			"suspend": {
				"!type": "fn() -> void"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"resume": {
				"!type": "fn() -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionStreamTask"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionStreamTask"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitElectricPotentialDifference": {
		"volts": {
			"!type": "fn() -> +NSUnitElectricPotentialDifference"
		},
		"microvolts": {
			"!type": "fn() -> +NSUnitElectricPotentialDifference"
		},
		"millivolts": {
			"!type": "fn() -> +NSUnitElectricPotentialDifference"
		},
		"kilovolts": {
			"!type": "fn() -> +NSUnitElectricPotentialDifference"
		},
		"megavolts": {
			"!type": "fn() -> +NSUnitElectricPotentialDifference"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitElectricPotentialDifference"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitElectricPotentialDifference"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitElectricPotentialDifference"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitElectricPotentialDifference"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitElectricPotentialDifference"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitElectricPotentialDifference"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitElectricPotentialDifference"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CATransaction": {
		"begin": {
			"!type": "fn() -> void"
		},
		"valueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"completionBlock": {
			"!type": "fn() -> +Function"
		},
		"lock": {
			"!type": "fn() -> void"
		},
		"flush": {
			"!type": "fn() -> void"
		},
		"setValueForKey": {
			"!type": "fn(anObject: +Object, key: string) -> void"
		},
		"setCompletionBlock": {
			"!type": "fn(block: +Function) -> void"
		},
		"setAnimationTimingFunction": {
			"!type": "fn(function: +CAMediaTimingFunction) -> void"
		},
		"unlock": {
			"!type": "fn() -> void"
		},
		"disableActions": {
			"!type": "fn() -> bool"
		},
		"animationDuration": {
			"!type": "fn() -> number"
		},
		"commit": {
			"!type": "fn() -> void"
		},
		"setDisableActions": {
			"!type": "fn(flag: bool) -> void"
		},
		"setAnimationDuration": {
			"!type": "fn(dur: number) -> void"
		},
		"animationTimingFunction": {
			"!type": "fn() -> +CAMediaTimingFunction"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CATransaction"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CATransaction"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CATransaction"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CATransaction"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSCache": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSCache"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSCache"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSCache"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"countLimit": {
				"!type": "number"
			},
			"evictsObjectsWithDiscardedContent": {
				"!type": "bool"
			},
			"totalCostLimit": {
				"!type": "number"
			},
			"name": {
				"!type": "string"
			},
			"delegate": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setObjectForKeyCost": {
				"!type": "fn(obj: +Object, key: +Object, g: number) -> void"
			},
			"setObjectForKey": {
				"!type": "fn(obj: +Object, key: +Object) -> void"
			},
			"removeAllObjects": {
				"!type": "fn() -> void"
			},
			"removeObjectForKey": {
				"!type": "fn(key: +Object) -> void"
			},
			"objectForKey": {
				"!type": "fn(key: +Object) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSCache"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSXMLParser": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSXMLParser"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSXMLParser"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSXMLParser"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"columnNumber": {
				"!type": "number"
			},
			"publicID": {
				"!type": "string"
			},
			"externalEntityResolvingPolicy": {
				"!type": "number"
			},
			"allowedExternalEntityURLs": {
				"!type": "+NSSet"
			},
			"systemID": {
				"!type": "string"
			},
			"delegate": {
				"!type": "+Object"
			},
			"parserError": {
				"!type": "+NSError"
			},
			"lineNumber": {
				"!type": "number"
			},
			"shouldResolveExternalEntities": {
				"!type": "bool"
			},
			"shouldProcessNamespaces": {
				"!type": "bool"
			},
			"shouldReportNamespacePrefixes": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithContentsOfURL": {
				"!type": "fn(url: +NSURL) -> +NSXMLParser"
			},
			"abortParsing": {
				"!type": "fn() -> void"
			},
			"initWithData": {
				"!type": "fn(data: +NSData) -> +NSXMLParser"
			},
			"initWithStream": {
				"!type": "fn(stream: +NSInputStream) -> +NSXMLParser"
			},
			"parse": {
				"!type": "fn() -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSXMLParser"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioInputNode": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioInputNode"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioInputNode"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioInputNode"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"voiceProcessingInputMuted": {
				"!type": "bool"
			},
			"voiceProcessingAGCEnabled": {
				"!type": "bool"
			},
			"voiceProcessingBypassed": {
				"!type": "bool"
			},
			"voiceProcessingEnabled": {
				"!type": "bool"
			},
			"presentationLatency": {
				"!type": "number"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setManualRenderingInputPCMFormatInputBlock": {
				"!type": "fn(format: +AVAudioFormat, block: +Function) -> bool"
			},
			"setVoiceProcessingEnabledError": {
				"!type": "fn(enabled: bool, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioInputNode"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetDownloadURLSession": {
		"sessionWithConfigurationAssetDownloadDelegateDelegateQueue": {
			"!type": "fn(configuration: +NSURLSessionConfiguration, delegate: +Object, delegateQueue: +NSOperationQueue) -> +AVAssetDownloadURLSession"
		},
		"sharedSession": {
			"!type": "fn() -> +NSURLSession"
		},
		"sessionWithConfigurationDelegateDelegateQueue": {
			"!type": "fn(configuration: +NSURLSessionConfiguration, delegate: +Object, queue: +NSOperationQueue) -> +NSURLSession"
		},
		"sessionWithConfiguration": {
			"!type": "fn(configuration: +NSURLSessionConfiguration) -> +NSURLSession"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetDownloadURLSession"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetDownloadURLSession"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetDownloadURLSession"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetDownloadURLSession"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"sessionDescription": {
				"!type": "string"
			},
			"configuration": {
				"!type": "+NSURLSessionConfiguration"
			},
			"delegate": {
				"!type": "+Object"
			},
			"delegateQueue": {
				"!type": "+NSOperationQueue"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"assetDownloadTaskWithURLAssetAssetTitleAssetArtworkDataOptions": {
				"!type": "fn(URLAsset: +AVURLAsset, title: string, artworkData: +NSData, options: +Object) -> +AVAssetDownloadTask"
			},
			"aggregateAssetDownloadTaskWithURLAssetMediaSelectionsAssetTitleAssetArtworkDataOptions": {
				"!type": "fn(URLAsset: +AVURLAsset, mediaSelections: +Array, title: string, artworkData: +NSData, options: +Object) -> +AVAggregateAssetDownloadTask"
			},
			"assetDownloadTaskWithURLAssetDestinationURLOptions": {
				"!type": "fn(URLAsset: +AVURLAsset, destinationURL: +NSURL, options: +Object) -> +AVAssetDownloadTask"
			},
			"dataTaskWithRequest": {
				"!type": "fn(request: +NSURLRequest) -> +NSURLSessionDataTask"
			},
			"streamTaskWithNetService": {
				"!type": "fn(service: +NSNetService) -> +NSURLSessionStreamTask"
			},
			"downloadTaskWithResumeData": {
				"!type": "fn(resumeData: +NSData) -> +NSURLSessionDownloadTask"
			},
			"uploadTaskWithRequestFromDataCompletionHandler": {
				"!type": "fn(request: +NSURLRequest, bodyData: +NSData, completionHandler: +Function) -> +NSURLSessionUploadTask"
			},
			"uploadTaskWithStreamedRequest": {
				"!type": "fn(request: +NSURLRequest) -> +NSURLSessionUploadTask"
			},
			"dataTaskWithURLCompletionHandler": {
				"!type": "fn(url: +NSURL, completionHandler: +Function) -> +NSURLSessionDataTask"
			},
			"flushWithCompletionHandler": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"getTasksWithCompletionHandler": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"getAllTasksWithCompletionHandler": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetDownloadURLSession"
			},
			"downloadTaskWithRequestCompletionHandler": {
				"!type": "fn(request: +NSURLRequest, completionHandler: +Function) -> +NSURLSessionDownloadTask"
			},
			"invalidateAndCancel": {
				"!type": "fn() -> void"
			},
			"uploadTaskWithRequestFromFile": {
				"!type": "fn(request: +NSURLRequest, fileURL: +NSURL) -> +NSURLSessionUploadTask"
			},
			"downloadTaskWithURL": {
				"!type": "fn(url: +NSURL) -> +NSURLSessionDownloadTask"
			},
			"streamTaskWithHostNamePort": {
				"!type": "fn(hostname: string, port: number) -> +NSURLSessionStreamTask"
			},
			"resetWithCompletionHandler": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"webSocketTaskWithURLProtocols": {
				"!type": "fn(url: +NSURL, protocols: +Array) -> +NSURLSessionWebSocketTask"
			},
			"uploadTaskWithRequestFromData": {
				"!type": "fn(request: +NSURLRequest, bodyData: +NSData) -> +NSURLSessionUploadTask"
			},
			"downloadTaskWithResumeDataCompletionHandler": {
				"!type": "fn(resumeData: +NSData, completionHandler: +Function) -> +NSURLSessionDownloadTask"
			},
			"downloadTaskWithURLCompletionHandler": {
				"!type": "fn(url: +NSURL, completionHandler: +Function) -> +NSURLSessionDownloadTask"
			},
			"finishTasksAndInvalidate": {
				"!type": "fn() -> void"
			},
			"downloadTaskWithRequest": {
				"!type": "fn(request: +NSURLRequest) -> +NSURLSessionDownloadTask"
			},
			"uploadTaskWithRequestFromFileCompletionHandler": {
				"!type": "fn(request: +NSURLRequest, fileURL: +NSURL, completionHandler: +Function) -> +NSURLSessionUploadTask"
			},
			"dataTaskWithURL": {
				"!type": "fn(url: +NSURL) -> +NSURLSessionDataTask"
			},
			"webSocketTaskWithRequest": {
				"!type": "fn(request: +NSURLRequest) -> +NSURLSessionWebSocketTask"
			},
			"webSocketTaskWithURL": {
				"!type": "fn(url: +NSURL) -> +NSURLSessionWebSocketTask"
			},
			"dataTaskWithRequestCompletionHandler": {
				"!type": "fn(request: +NSURLRequest, completionHandler: +Function) -> +NSURLSessionDataTask"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetDownloadURLSession"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnitMIDIInstrument": {
		"instantiateWithComponentDescriptionOptionsCompletionHandler": {
			"!type": "fn(audioComponentDescription: +Object, options: number, completionHandler: +Function) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnitMIDIInstrument"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnitMIDIInstrument"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnitMIDIInstrument"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"name": {
				"!type": "string"
			},
			"audioComponentDescription": {
				"!type": "+Object"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"version": {
				"!type": "number"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"sendMIDIEventData1": {
				"!type": "fn(midiStatus: number, data1: number) -> void"
			},
			"sendPitchBendOnChannel": {
				"!type": "fn(pitchbend: number, channel: number) -> void"
			},
			"sendProgramChangeBankMSBBankLSBOnChannel": {
				"!type": "fn(program: number, bankMSB: number, bankLSB: number, channel: number) -> void"
			},
			"sendPressureForKeyWithValueOnChannel": {
				"!type": "fn(key: number, value: number, channel: number) -> void"
			},
			"startNoteWithVelocityOnChannel": {
				"!type": "fn(note: number, velocity: number, channel: number) -> void"
			},
			"sendControllerWithValueOnChannel": {
				"!type": "fn(controller: number, value: number, channel: number) -> void"
			},
			"sendMIDIEventData1Data2": {
				"!type": "fn(midiStatus: number, data1: number, data2: number) -> void"
			},
			"sendPressureOnChannel": {
				"!type": "fn(pressure: number, channel: number) -> void"
			},
			"stopNoteOnChannel": {
				"!type": "fn(note: number, channel: number) -> void"
			},
			"sendProgramChangeOnChannel": {
				"!type": "fn(program: number, channel: number) -> void"
			},
			"initWithAudioComponentDescription": {
				"!type": "fn(description: +Object) -> +AVAudioUnitMIDIInstrument"
			},
			"sendMIDISysExEvent": {
				"!type": "fn(midiData: +NSData) -> void"
			},
			"loadAudioUnitPresetAtURLError": {
				"!type": "fn(url: +NSURL, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnitMIDIInstrument"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureVideoPreviewLayer": {
		"layerWithSession": {
			"!type": "fn(session: +AVCaptureSession) -> +AVCaptureVideoPreviewLayer"
		},
		"layerWithSessionWithNoConnection": {
			"!type": "fn(session: +AVCaptureSession) -> +AVCaptureVideoPreviewLayer"
		},
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +AVCaptureVideoPreviewLayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureVideoPreviewLayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureVideoPreviewLayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureVideoPreviewLayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"videoGravity": {
				"!type": "string"
			},
			"previewing": {
				"!type": "bool"
			},
			"mirrored": {
				"!type": "bool"
			},
			"mirroringSupported": {
				"!type": "bool"
			},
			"connection": {
				"!type": "+AVCaptureConnection"
			},
			"session": {
				"!type": "+AVCaptureSession"
			},
			"orientationSupported": {
				"!type": "bool"
			},
			"automaticallyAdjustsMirroring": {
				"!type": "bool"
			},
			"orientation": {
				"!type": "number"
			},
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSession": {
				"!type": "fn(session: +AVCaptureSession) -> +AVCaptureVideoPreviewLayer"
			},
			"initWithSessionWithNoConnection": {
				"!type": "fn(session: +AVCaptureSession) -> +AVCaptureVideoPreviewLayer"
			},
			"transformedMetadataObjectForMetadataObject": {
				"!type": "fn(metadataObject: +AVMetadataObject) -> +AVMetadataObject"
			},
			"setSessionWithNoConnection": {
				"!type": "fn(session: +AVCaptureSession) -> void"
			},
			"captureDevicePointOfInterestForPoint": {
				"!type": "fn(pointInLayer: +Object) -> +Object"
			},
			"rectForMetadataOutputRectOfInterest": {
				"!type": "fn(rectInMetadataOutputCoordinates: +Object) -> +Object"
			},
			"pointForCaptureDevicePointOfInterest": {
				"!type": "fn(captureDevicePointOfInterest: +Object) -> +Object"
			},
			"metadataOutputRectOfInterestForRect": {
				"!type": "fn(rectInLayerCoordinates: +Object) -> +Object"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureVideoPreviewLayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +AVCaptureVideoPreviewLayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +AVCaptureVideoPreviewLayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +AVCaptureVideoPreviewLayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureVideoPreviewLayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetWriterInputPassDescription": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetWriterInputPassDescription"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetWriterInputPassDescription"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetWriterInputPassDescription"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"sourceTimeRanges": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetWriterInputPassDescription"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLComponents": {
		"componentsWithString": {
			"!type": "fn(URLString: string) -> +NSURLComponents"
		},
		"componentsWithURLResolvingAgainstBaseURL": {
			"!type": "fn(url: +NSURL, resolve: bool) -> +NSURLComponents"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLComponents"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLComponents"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLComponents"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"percentEncodedQueryItems": {
				"!type": "+Array"
			},
			"fragment": {
				"!type": "string"
			},
			"rangeOfPath": {
				"!type": "+Object"
			},
			"percentEncodedFragment": {
				"!type": "string"
			},
			"rangeOfPassword": {
				"!type": "+Object"
			},
			"query": {
				"!type": "string"
			},
			"port": {
				"!type": "number"
			},
			"rangeOfHost": {
				"!type": "+Object"
			},
			"rangeOfUser": {
				"!type": "+Object"
			},
			"percentEncodedPassword": {
				"!type": "string"
			},
			"rangeOfPort": {
				"!type": "+Object"
			},
			"URL": {
				"!type": "+NSURL"
			},
			"rangeOfScheme": {
				"!type": "+Object"
			},
			"percentEncodedQuery": {
				"!type": "string"
			},
			"scheme": {
				"!type": "string"
			},
			"string": {
				"!type": "string"
			},
			"percentEncodedPath": {
				"!type": "string"
			},
			"percentEncodedUser": {
				"!type": "string"
			},
			"rangeOfQuery": {
				"!type": "+Object"
			},
			"host": {
				"!type": "string"
			},
			"user": {
				"!type": "string"
			},
			"path": {
				"!type": "string"
			},
			"password": {
				"!type": "string"
			},
			"queryItems": {
				"!type": "+Array"
			},
			"percentEncodedHost": {
				"!type": "string"
			},
			"rangeOfFragment": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithString": {
				"!type": "fn(URLString: string) -> +NSURLComponents"
			},
			"initWithURLResolvingAgainstBaseURL": {
				"!type": "fn(url: +NSURL, resolve: bool) -> +NSURLComponents"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLComponents"
			},
			"URLRelativeToURL": {
				"!type": "fn(baseURL: +NSURL) -> +NSURL"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLComponents"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSSecureUnarchiveFromDataTransformer": {
		"allowedTopLevelClasses": {
			"!type": "fn() -> +Array"
		},
		"allowsReverseTransformation": {
			"!type": "fn() -> bool"
		},
		"valueTransformerNames": {
			"!type": "fn() -> +Array"
		},
		"valueTransformerForName": {
			"!type": "fn(name: string) -> +NSValueTransformer"
		},
		"transformedValueClass": {
			"!type": "fn() -> +Object"
		},
		"setValueTransformerForName": {
			"!type": "fn(transformer: +NSValueTransformer, name: string) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSSecureUnarchiveFromDataTransformer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSSecureUnarchiveFromDataTransformer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSSecureUnarchiveFromDataTransformer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"transformedValue": {
				"!type": "fn(value: +Object) -> +Object"
			},
			"reverseTransformedValue": {
				"!type": "fn(value: +Object) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSSecureUnarchiveFromDataTransformer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerItemMediaDataCollector": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerItemMediaDataCollector"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerItemMediaDataCollector"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerItemMediaDataCollector"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerItemMediaDataCollector"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMetadataMachineReadableCodeObject": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMetadataMachineReadableCodeObject"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMetadataMachineReadableCodeObject"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMetadataMachineReadableCodeObject"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"corners": {
				"!type": "+Array"
			},
			"descriptor": {
				"!type": "+CIBarcodeDescriptor"
			},
			"stringValue": {
				"!type": "string"
			},
			"duration": {
				"!type": "+Object"
			},
			"type": {
				"!type": "string"
			},
			"bounds": {
				"!type": "+Object"
			},
			"time": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMetadataMachineReadableCodeObject"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSException": {
		"exceptionWithNameReasonUserInfo": {
			"!type": "fn(name: string, reason: string, userInfo: +Object) -> +NSException"
		},
		"raiseFormat": {
			"!type": "fn(name: string, format: string, args: Array.prototype) -> void"
		},
		"raiseFormatArguments": {
			"!type": "fn(name: string, format: string, argList: +Object) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSException"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSException"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSException"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"reason": {
				"!type": "string"
			},
			"callStackSymbols": {
				"!type": "+Array"
			},
			"callStackReturnAddresses": {
				"!type": "+Array"
			},
			"name": {
				"!type": "string"
			},
			"userInfo": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"raise": {
				"!type": "fn() -> void"
			},
			"initWithNameReasonUserInfo": {
				"!type": "fn(aName: string, aReason: string, aUserInfo: +Object) -> +NSException"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSException"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CAEmitterLayer": {
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +CAEmitterLayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CAEmitterLayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CAEmitterLayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CAEmitterLayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"emitterDepth": {
				"!type": "number"
			},
			"scale": {
				"!type": "number"
			},
			"emitterShape": {
				"!type": "string"
			},
			"emitterCells": {
				"!type": "+Array"
			},
			"emitterMode": {
				"!type": "string"
			},
			"preservesDepth": {
				"!type": "bool"
			},
			"emitterSize": {
				"!type": "+Object"
			},
			"birthRate": {
				"!type": "number"
			},
			"seed": {
				"!type": "number"
			},
			"emitterZPosition": {
				"!type": "number"
			},
			"velocity": {
				"!type": "number"
			},
			"spin": {
				"!type": "number"
			},
			"lifetime": {
				"!type": "number"
			},
			"renderMode": {
				"!type": "string"
			},
			"emitterPosition": {
				"!type": "+Object"
			},
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAEmitterLayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +CAEmitterLayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +CAEmitterLayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +CAEmitterLayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAEmitterLayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureDevice": {
		"defaultDeviceWithDeviceTypeMediaTypePosition": {
			"!type": "fn(deviceType: string, mediaType: string, position: number) -> +AVCaptureDevice"
		},
		"devicesWithMediaType": {
			"!type": "fn(mediaType: string) -> +Array"
		},
		"authorizationStatusForMediaType": {
			"!type": "fn(mediaType: string) -> number"
		},
		"extrinsicMatrixFromDeviceToDevice": {
			"!type": "fn(fromDevice: +AVCaptureDevice, toDevice: +AVCaptureDevice) -> +NSData"
		},
		"requestAccessForMediaTypeCompletionHandler": {
			"!type": "fn(mediaType: string, handler: +Function) -> void"
		},
		"defaultDeviceWithMediaType": {
			"!type": "fn(mediaType: string) -> +AVCaptureDevice"
		},
		"deviceWithUniqueID": {
			"!type": "fn(deviceUniqueID: string) -> +AVCaptureDevice"
		},
		"devices": {
			"!type": "fn() -> +Array"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureDevice"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureDevice"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureDevice"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"maxExposureTargetBias": {
				"!type": "number"
			},
			"exposureDuration": {
				"!type": "+Object"
			},
			"suspended": {
				"!type": "bool"
			},
			"minAvailableVideoZoomFactor": {
				"!type": "number"
			},
			"flashMode": {
				"!type": "number"
			},
			"subjectAreaChangeMonitoringEnabled": {
				"!type": "bool"
			},
			"ISO": {
				"!type": "number"
			},
			"activeVideoMaxFrameDuration": {
				"!type": "+Object"
			},
			"uniqueID": {
				"!type": "string"
			},
			"lensAperture": {
				"!type": "number"
			},
			"minExposureTargetBias": {
				"!type": "number"
			},
			"activeVideoMinFrameDuration": {
				"!type": "+Object"
			},
			"manufacturer": {
				"!type": "string"
			},
			"focusPointOfInterest": {
				"!type": "+Object"
			},
			"smoothAutoFocusSupported": {
				"!type": "bool"
			},
			"deviceType": {
				"!type": "string"
			},
			"whiteBalanceMode": {
				"!type": "number"
			},
			"maxWhiteBalanceGain": {
				"!type": "number"
			},
			"virtualDevice": {
				"!type": "bool"
			},
			"deviceWhiteBalanceGains": {
				"!type": "+Object"
			},
			"videoHDREnabled": {
				"!type": "bool"
			},
			"exposureTargetBias": {
				"!type": "number"
			},
			"virtualDeviceSwitchOverVideoZoomFactors": {
				"!type": "+Array"
			},
			"localizedName": {
				"!type": "string"
			},
			"rampingVideoZoom": {
				"!type": "bool"
			},
			"exposurePointOfInterestSupported": {
				"!type": "bool"
			},
			"lowLightBoostEnabled": {
				"!type": "bool"
			},
			"adjustingExposure": {
				"!type": "bool"
			},
			"constituentDevices": {
				"!type": "+Array"
			},
			"systemPressureState": {
				"!type": "+AVCaptureSystemPressureState"
			},
			"modelID": {
				"!type": "string"
			},
			"globalToneMappingEnabled": {
				"!type": "bool"
			},
			"lockingWhiteBalanceWithCustomDeviceGainsSupported": {
				"!type": "bool"
			},
			"lowLightBoostSupported": {
				"!type": "bool"
			},
			"geometricDistortionCorrectionSupported": {
				"!type": "bool"
			},
			"lensPosition": {
				"!type": "number"
			},
			"exposureTargetOffset": {
				"!type": "number"
			},
			"torchAvailable": {
				"!type": "bool"
			},
			"focusMode": {
				"!type": "number"
			},
			"flashAvailable": {
				"!type": "bool"
			},
			"torchLevel": {
				"!type": "number"
			},
			"automaticallyEnablesLowLightBoostWhenAvailable": {
				"!type": "bool"
			},
			"connected": {
				"!type": "bool"
			},
			"activeDepthDataFormat": {
				"!type": "+AVCaptureDeviceFormat"
			},
			"grayWorldDeviceWhiteBalanceGains": {
				"!type": "+Object"
			},
			"geometricDistortionCorrectionEnabled": {
				"!type": "bool"
			},
			"flashActive": {
				"!type": "bool"
			},
			"focusPointOfInterestSupported": {
				"!type": "bool"
			},
			"activeFormat": {
				"!type": "+AVCaptureDeviceFormat"
			},
			"automaticallyAdjustsVideoHDREnabled": {
				"!type": "bool"
			},
			"videoZoomFactor": {
				"!type": "number"
			},
			"dualCameraSwitchOverVideoZoomFactor": {
				"!type": "number"
			},
			"autoFocusRangeRestrictionSupported": {
				"!type": "bool"
			},
			"activeDepthDataMinFrameDuration": {
				"!type": "+Object"
			},
			"exposureMode": {
				"!type": "number"
			},
			"adjustingWhiteBalance": {
				"!type": "bool"
			},
			"torchMode": {
				"!type": "number"
			},
			"torchActive": {
				"!type": "bool"
			},
			"autoFocusRangeRestriction": {
				"!type": "number"
			},
			"activeMaxExposureDuration": {
				"!type": "+Object"
			},
			"adjustingFocus": {
				"!type": "bool"
			},
			"activeColorSpace": {
				"!type": "number"
			},
			"hasFlash": {
				"!type": "bool"
			},
			"lockingFocusWithCustomLensPositionSupported": {
				"!type": "bool"
			},
			"formats": {
				"!type": "+Array"
			},
			"position": {
				"!type": "number"
			},
			"smoothAutoFocusEnabled": {
				"!type": "bool"
			},
			"maxAvailableVideoZoomFactor": {
				"!type": "number"
			},
			"hasTorch": {
				"!type": "bool"
			},
			"exposurePointOfInterest": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setExposureModeCustomWithDurationISOCompletionHandler": {
				"!type": "fn(duration: +Object, ISO: number, handler: +Function) -> void"
			},
			"isExposureModeSupported": {
				"!type": "fn(exposureMode: number) -> bool"
			},
			"hasMediaType": {
				"!type": "fn(mediaType: string) -> bool"
			},
			"setFocusModeLockedWithLensPositionCompletionHandler": {
				"!type": "fn(lensPosition: number, handler: +Function) -> void"
			},
			"deviceWhiteBalanceGainsForChromaticityValues": {
				"!type": "fn(chromaticityValues: +Object) -> +Object"
			},
			"isWhiteBalanceModeSupported": {
				"!type": "fn(whiteBalanceMode: number) -> bool"
			},
			"supportsAVCaptureSessionPreset": {
				"!type": "fn(preset: string) -> bool"
			},
			"isTorchModeSupported": {
				"!type": "fn(torchMode: number) -> bool"
			},
			"unlockForConfiguration": {
				"!type": "fn() -> void"
			},
			"isFocusModeSupported": {
				"!type": "fn(focusMode: number) -> bool"
			},
			"rampToVideoZoomFactorWithRate": {
				"!type": "fn(factor: number, rate: number) -> void"
			},
			"setTorchModeOnWithLevelError": {
				"!type": "fn(torchLevel: number, outError: +Object) -> bool"
			},
			"setExposureTargetBiasCompletionHandler": {
				"!type": "fn(bias: number, handler: +Function) -> void"
			},
			"chromaticityValuesForDeviceWhiteBalanceGains": {
				"!type": "fn(whiteBalanceGains: +Object) -> +Object"
			},
			"setWhiteBalanceModeLockedWithDeviceWhiteBalanceGainsCompletionHandler": {
				"!type": "fn(whiteBalanceGains: +Object, handler: +Function) -> void"
			},
			"temperatureAndTintValuesForDeviceWhiteBalanceGains": {
				"!type": "fn(whiteBalanceGains: +Object) -> +Object"
			},
			"deviceWhiteBalanceGainsForTemperatureAndTintValues": {
				"!type": "fn(tempAndTintValues: +Object) -> +Object"
			},
			"isFlashModeSupported": {
				"!type": "fn(flashMode: number) -> bool"
			},
			"cancelVideoZoomRamp": {
				"!type": "fn() -> void"
			},
			"lockForConfiguration": {
				"!type": "fn(outError: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureDevice"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMachPort": {
		"portWithMachPortOptions": {
			"!type": "fn(machPort: number, f: number) -> +NSPort"
		},
		"portWithMachPort": {
			"!type": "fn(machPort: number) -> +NSPort"
		},
		"port": {
			"!type": "fn() -> +NSPort"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMachPort"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMachPort"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMachPort"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"machPort": {
				"!type": "number"
			},
			"reservedSpaceLength": {
				"!type": "number"
			},
			"valid": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setDelegate": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"scheduleInRunLoopForMode": {
				"!type": "fn(runLoop: +NSRunLoop, mode: string) -> void"
			},
			"delegate": {
				"!type": "fn() -> +Object"
			},
			"initWithMachPortOptions": {
				"!type": "fn(machPort: number, f: number) -> +NSMachPort"
			},
			"initWithMachPort": {
				"!type": "fn(machPort: number) -> +NSMachPort"
			},
			"removeFromRunLoopForMode": {
				"!type": "fn(runLoop: +NSRunLoop, mode: string) -> void"
			},
			"invalidate": {
				"!type": "fn() -> void"
			},
			"sendBeforeDateMsgidComponentsFromReserved": {
				"!type": "fn(limitDate: +Date, msgID: number, components: +NSMutableArray, receivePort: +NSPort, headerSpaceReserved: number) -> bool"
			},
			"setDelegate": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"scheduleInRunLoopForMode": {
				"!type": "fn(runLoop: +NSRunLoop, mode: string) -> void"
			},
			"removeFromRunLoopForMode": {
				"!type": "fn(runLoop: +NSRunLoop, mode: string) -> void"
			},
			"sendBeforeDateComponentsFromReserved": {
				"!type": "fn(limitDate: +Date, components: +NSMutableArray, receivePort: +NSPort, headerSpaceReserved: number) -> bool"
			},
			"delegate": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMachPort"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLSessionDownloadTask": {
		"jsnew": {
			"!type": "fn() -> +NSURLSessionDownloadTask"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionDownloadTask"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLSessionDownloadTask"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLSessionDownloadTask"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionDownloadTask"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"countOfBytesSent": {
				"!type": "number"
			},
			"earliestBeginDate": {
				"!type": "+Date"
			},
			"countOfBytesExpectedToReceive": {
				"!type": "number"
			},
			"taskDescription": {
				"!type": "string"
			},
			"countOfBytesExpectedToSend": {
				"!type": "number"
			},
			"state": {
				"!type": "number"
			},
			"priority": {
				"!type": "number"
			},
			"countOfBytesClientExpectsToSend": {
				"!type": "number"
			},
			"taskIdentifier": {
				"!type": "number"
			},
			"countOfBytesReceived": {
				"!type": "number"
			},
			"error": {
				"!type": "+NSError"
			},
			"currentRequest": {
				"!type": "+NSURLRequest"
			},
			"progress": {
				"!type": "+NSProgress"
			},
			"countOfBytesClientExpectsToReceive": {
				"!type": "number"
			},
			"response": {
				"!type": "+NSURLResponse"
			},
			"originalRequest": {
				"!type": "+NSURLRequest"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionDownloadTask"
			},
			"cancelByProducingResumeData": {
				"!type": "fn(completionHandler: +Function) -> void"
			},
			"suspend": {
				"!type": "fn() -> void"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"resume": {
				"!type": "fn() -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionDownloadTask"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionDownloadTask"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMutableOrderedSet": {
		"orderedSetWithCapacity": {
			"!type": "fn(numItems: number) -> +NSMutableOrderedSet"
		},
		"orderedSetWithOrderedSet": {
			"!type": "fn(set: +NSOrderedSet) -> +NSMutableOrderedSet"
		},
		"orderedSetWithOrderedSetRangeCopyItems": {
			"!type": "fn(set: +NSOrderedSet, range: +Object, flag: bool) -> +NSMutableOrderedSet"
		},
		"orderedSetWithObjects": {
			"!type": "fn(firstObj: +Object, args: Array.prototype) -> +NSMutableOrderedSet"
		},
		"orderedSetWithObjectsCount": {
			"!type": "fn(objects: +Object, cnt: number) -> +NSMutableOrderedSet"
		},
		"orderedSetWithObject": {
			"!type": "fn(object: +Object) -> +NSMutableOrderedSet"
		},
		"orderedSetWithSetCopyItems": {
			"!type": "fn(set: +NSSet, flag: bool) -> +NSMutableOrderedSet"
		},
		"orderedSet": {
			"!type": "fn() -> +NSMutableOrderedSet"
		},
		"orderedSetWithArrayRangeCopyItems": {
			"!type": "fn(array: +Array, range: +Object, flag: bool) -> +NSMutableOrderedSet"
		},
		"orderedSetWithArray": {
			"!type": "fn(array: +Array) -> +NSMutableOrderedSet"
		},
		"orderedSetWithSet": {
			"!type": "fn(set: +NSSet) -> +NSMutableOrderedSet"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMutableOrderedSet"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMutableOrderedSet"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMutableOrderedSet"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"set": {
				"!type": "+NSSet"
			},
			"firstObject": {
				"!type": "+Object"
			},
			"description": {
				"!type": "string"
			},
			"lastObject": {
				"!type": "+Object"
			},
			"array": {
				"!type": "+Array"
			},
			"reversedOrderedSet": {
				"!type": "+NSOrderedSet"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"applyDifference": {
				"!type": "fn(difference: +NSOrderedCollectionDifference) -> void"
			},
			"initWithCapacity": {
				"!type": "fn(numItems: number) -> +NSMutableOrderedSet"
			},
			"replaceObjectsAtIndexesWithObjects": {
				"!type": "fn(indexes: +NSIndexSet, objects: +Array) -> void"
			},
			"setObjectAtIndex": {
				"!type": "fn(obj: +Object, idx: number) -> void"
			},
			"removeObjectsAtIndexes": {
				"!type": "fn(indexes: +NSIndexSet) -> void"
			},
			"removeAllObjects": {
				"!type": "fn() -> void"
			},
			"insertObjectsAtIndexes": {
				"!type": "fn(objects: +Array, indexes: +NSIndexSet) -> void"
			},
			"intersectSet": {
				"!type": "fn(other: +NSSet) -> void"
			},
			"removeObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"sortUsingDescriptors": {
				"!type": "fn(sortDescriptors: +Array) -> void"
			},
			"sortUsingComparator": {
				"!type": "fn(cmptr: +Function) -> void"
			},
			"filterUsingPredicate": {
				"!type": "fn(p: +NSPredicate) -> void"
			},
			"moveObjectsAtIndexesToIndex": {
				"!type": "fn(indexes: +NSIndexSet, idx: number) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableOrderedSet"
			},
			"sortRangeOptionsUsingComparator": {
				"!type": "fn(range: +Object, opts: number, cmptr: +Function) -> void"
			},
			"minusOrderedSet": {
				"!type": "fn(other: +NSOrderedSet) -> void"
			},
			"removeObjectAtIndex": {
				"!type": "fn(idx: number) -> void"
			},
			"insertObjectAtIndex": {
				"!type": "fn(object: +Object, idx: number) -> void"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSMutableOrderedSet"
			},
			"intersectOrderedSet": {
				"!type": "fn(other: +NSOrderedSet) -> void"
			},
			"exchangeObjectAtIndexWithObjectAtIndex": {
				"!type": "fn(idx1: number, idx2: number) -> void"
			},
			"unionSet": {
				"!type": "fn(other: +NSSet) -> void"
			},
			"removeObjectsInArray": {
				"!type": "fn(array: +Array) -> void"
			},
			"replaceObjectAtIndexWithObject": {
				"!type": "fn(idx: number, object: +Object) -> void"
			},
			"unionOrderedSet": {
				"!type": "fn(other: +NSOrderedSet) -> void"
			},
			"setObjectAtIndexedSubscript": {
				"!type": "fn(obj: +Object, idx: number) -> void"
			},
			"removeObjectsInRange": {
				"!type": "fn(range: +Object) -> void"
			},
			"addObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"minusSet": {
				"!type": "fn(other: +NSSet) -> void"
			},
			"sortWithOptionsUsingComparator": {
				"!type": "fn(opts: number, cmptr: +Function) -> void"
			},
			"addObjectsCount": {
				"!type": "fn(objects: +Object, count: number) -> void"
			},
			"addObjectsFromArray": {
				"!type": "fn(array: +Array) -> void"
			},
			"replaceObjectsInRangeWithObjectsCount": {
				"!type": "fn(range: +Object, objects: +Object, count: number) -> void"
			},
			"initWithSet": {
				"!type": "fn(set: +NSSet) -> +NSMutableOrderedSet"
			},
			"initWithObjectsCount": {
				"!type": "fn(objects: +Object, cnt: number) -> +NSMutableOrderedSet"
			},
			"initWithArrayRangeCopyItems": {
				"!type": "fn(set: +Array, range: +Object, flag: bool) -> +NSMutableOrderedSet"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"sortedArrayUsingComparator": {
				"!type": "fn(cmptr: +Function) -> +Array"
			},
			"indexesOfObjectsWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> +NSIndexSet"
			},
			"containsObject": {
				"!type": "fn(object: +Object) -> bool"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"objectAtIndexedSubscript": {
				"!type": "fn(idx: number) -> +Object"
			},
			"isSubsetOfSet": {
				"!type": "fn(set: +NSSet) -> bool"
			},
			"indexesOfObjectsPassingTest": {
				"!type": "fn(predicate: +Function) -> +NSIndexSet"
			},
			"reverseObjectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"objectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"isEqualToOrderedSet": {
				"!type": "fn(other: +NSOrderedSet) -> bool"
			},
			"differenceFromOrderedSetWithOptionsUsingEquivalenceTest": {
				"!type": "fn(other: +NSOrderedSet, options: number, block: +Function) -> +NSOrderedCollectionDifference"
			},
			"descriptionWithLocaleIndent": {
				"!type": "fn(locale: +Object, level: number) -> string"
			},
			"sortedArrayWithOptionsUsingComparator": {
				"!type": "fn(opts: number, cmptr: +Function) -> +Array"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"filteredOrderedSetUsingPredicate": {
				"!type": "fn(p: +NSPredicate) -> +NSOrderedSet"
			},
			"initWithSetCopyItems": {
				"!type": "fn(set: +NSSet, flag: bool) -> +NSMutableOrderedSet"
			},
			"initWithArrayCopyItems": {
				"!type": "fn(set: +Array, flag: bool) -> +NSMutableOrderedSet"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableOrderedSet"
			},
			"differenceFromOrderedSetWithOptions": {
				"!type": "fn(other: +NSOrderedSet, options: number) -> +NSOrderedCollectionDifference"
			},
			"initWithOrderedSetRangeCopyItems": {
				"!type": "fn(set: +NSOrderedSet, range: +Object, flag: bool) -> +NSMutableOrderedSet"
			},
			"enumerateObjectsWithOptionsUsingBlock": {
				"!type": "fn(opts: number, block: +Function) -> void"
			},
			"initWithObject": {
				"!type": "fn(object: +Object) -> +NSMutableOrderedSet"
			},
			"indexOfObjectInSortedRangeOptionsUsingComparator": {
				"!type": "fn(object: +Object, range: +Object, opts: number, cmp: +Function) -> number"
			},
			"differenceFromOrderedSet": {
				"!type": "fn(other: +NSOrderedSet) -> +NSOrderedCollectionDifference"
			},
			"objectsAtIndexes": {
				"!type": "fn(indexes: +NSIndexSet) -> +Array"
			},
			"indexOfObjectWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> number"
			},
			"initWithOrderedSetCopyItems": {
				"!type": "fn(set: +NSOrderedSet, flag: bool) -> +NSMutableOrderedSet"
			},
			"sortedArrayUsingDescriptors": {
				"!type": "fn(sortDescriptors: +Array) -> +Array"
			},
			"descriptionWithLocale": {
				"!type": "fn(locale: +Object) -> string"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSMutableOrderedSet"
			},
			"orderedSetByApplyingDifference": {
				"!type": "fn(difference: +NSOrderedCollectionDifference) -> +NSOrderedSet"
			},
			"indexesOfObjectsAtIndexesOptionsPassingTest": {
				"!type": "fn(s: +NSIndexSet, opts: number, predicate: +Function) -> +NSIndexSet"
			},
			"intersectsOrderedSet": {
				"!type": "fn(other: +NSOrderedSet) -> bool"
			},
			"initWithObjects": {
				"!type": "fn(firstObj: +Object, args: Array.prototype) -> +NSMutableOrderedSet"
			},
			"initWithArray": {
				"!type": "fn(array: +Array) -> +NSMutableOrderedSet"
			},
			"initWithOrderedSet": {
				"!type": "fn(set: +NSOrderedSet) -> +NSMutableOrderedSet"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"objectAtIndex": {
				"!type": "fn(idx: number) -> +Object"
			},
			"enumerateObjectsUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"indexOfObject": {
				"!type": "fn(object: +Object) -> number"
			},
			"indexOfObjectAtIndexesOptionsPassingTest": {
				"!type": "fn(s: +NSIndexSet, opts: number, predicate: +Function) -> number"
			},
			"indexOfObjectPassingTest": {
				"!type": "fn(predicate: +Function) -> number"
			},
			"intersectsSet": {
				"!type": "fn(set: +NSSet) -> bool"
			},
			"isSubsetOfOrderedSet": {
				"!type": "fn(other: +NSOrderedSet) -> bool"
			},
			"getObjectsRange": {
				"!type": "fn(objects: +Object, range: +Object) -> void"
			},
			"enumerateObjectsAtIndexesOptionsUsingBlock": {
				"!type": "fn(s: +NSIndexSet, opts: number, block: +Function) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableOrderedSet"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureVideoDataOutput": {
		"jsnew": {
			"!type": "fn() -> +AVCaptureVideoDataOutput"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureVideoDataOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureVideoDataOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureVideoDataOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"videoSettings": {
				"!type": "+Object"
			},
			"availableVideoCodecTypes": {
				"!type": "+Array"
			},
			"sampleBufferDelegate": {
				"!type": "+Object"
			},
			"automaticallyConfiguresOutputBufferDimensions": {
				"!type": "bool"
			},
			"minFrameDuration": {
				"!type": "+Object"
			},
			"alwaysDiscardsLateVideoFrames": {
				"!type": "bool"
			},
			"availableVideoCVPixelFormatTypes": {
				"!type": "+Array"
			},
			"deliversPreviewSizedOutputBuffers": {
				"!type": "bool"
			},
			"connections": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"recommendedVideoSettingsForVideoCodecTypeAssetWriterOutputFileType": {
				"!type": "fn(videoCodecType: string, outputFileType: string) -> +Object"
			},
			"availableVideoCodecTypesForAssetWriterWithOutputFileType": {
				"!type": "fn(outputFileType: string) -> +Array"
			},
			"recommendedVideoSettingsForAssetWriterWithOutputFileType": {
				"!type": "fn(outputFileType: string) -> +Object"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureVideoDataOutput"
			},
			"setSampleBufferDelegateQueue": {
				"!type": "fn(sampleBufferDelegate: +Object, sampleBufferCallbackQueue: +Object) -> void"
			},
			"metadataOutputRectOfInterestForRect": {
				"!type": "fn(rectInOutputCoordinates: +Object) -> +Object"
			},
			"transformedMetadataObjectForMetadataObjectConnection": {
				"!type": "fn(metadataObject: +AVMetadataObject, connection: +AVCaptureConnection) -> +AVMetadataObject"
			},
			"rectForMetadataOutputRectOfInterest": {
				"!type": "fn(rectInMetadataOutputCoordinates: +Object) -> +Object"
			},
			"connectionWithMediaType": {
				"!type": "fn(mediaType: string) -> +AVCaptureConnection"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureVideoDataOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSCachedURLResponse": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSCachedURLResponse"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSCachedURLResponse"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSCachedURLResponse"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"storagePolicy": {
				"!type": "number"
			},
			"data": {
				"!type": "+NSData"
			},
			"response": {
				"!type": "+NSURLResponse"
			},
			"userInfo": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithResponseData": {
				"!type": "fn(response: +NSURLResponse, data: +NSData) -> +NSCachedURLResponse"
			},
			"initWithResponseDataUserInfoStoragePolicy": {
				"!type": "fn(response: +NSURLResponse, data: +NSData, userInfo: +Object, storagePolicy: number) -> +NSCachedURLResponse"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSCachedURLResponse"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSInvocation": {
		"invocationWithMethodSignature": {
			"!type": "fn(sig: +NSMethodSignature) -> +NSInvocation"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSInvocation"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSInvocation"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSInvocation"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"argumentsRetained": {
				"!type": "bool"
			},
			"methodSignature": {
				"!type": "+NSMethodSignature"
			},
			"target": {
				"!type": "+Object"
			},
			"jsselector": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setArgumentAtIndex": {
				"!type": "fn(argumentLocation: +Object, idx: number) -> void"
			},
			"setReturnValue": {
				"!type": "fn(retLoc: +Object) -> void"
			},
			"invoke": {
				"!type": "fn() -> void"
			},
			"retainArguments": {
				"!type": "fn() -> void"
			},
			"getArgumentAtIndex": {
				"!type": "fn(argumentLocation: +Object, idx: number) -> void"
			},
			"invokeWithTarget": {
				"!type": "fn(target: +Object) -> void"
			},
			"getReturnValue": {
				"!type": "fn(retLoc: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSInvocation"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetCache": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetCache"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetCache"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetCache"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"playableOffline": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"mediaSelectionOptionsInMediaSelectionGroup": {
				"!type": "fn(mediaSelectionGroup: +AVMediaSelectionGroup) -> +Array"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetCache"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AUAudioUnitPreset": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AUAudioUnitPreset"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AUAudioUnitPreset"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AUAudioUnitPreset"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"number": {
				"!type": "number"
			},
			"name": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AUAudioUnitPreset"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioMixInputParameters": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioMixInputParameters"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioMixInputParameters"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioMixInputParameters"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"trackID": {
				"!type": "number"
			},
			"audioTimePitchAlgorithm": {
				"!type": "string"
			},
			"audioTapProcessor": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"getVolumeRampForTimeStartVolumeEndVolumeTimeRange": {
				"!type": "fn(time: +Object, startVolume: +Object, endVolume: +Object, timeRange: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioMixInputParameters"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSLock": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSLock"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSLock"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSLock"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"name": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"lockBeforeDate": {
				"!type": "fn(limit: +Date) -> bool"
			},
			"tryLock": {
				"!type": "fn() -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSLock"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CALayer": {
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +CALayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CALayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CALayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CALayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CALayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +CALayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +CALayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +CALayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CALayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioSessionRouteDescription": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioSessionRouteDescription"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioSessionRouteDescription"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioSessionRouteDescription"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"inputs": {
				"!type": "+Array"
			},
			"outputs": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioSessionRouteDescription"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CABasicAnimation": {
		"animationWithKeyPath": {
			"!type": "fn(path: string) -> +CABasicAnimation"
		},
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"animation": {
			"!type": "fn() -> +CABasicAnimation"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CABasicAnimation"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CABasicAnimation"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CABasicAnimation"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"byValue": {
				"!type": "+Object"
			},
			"fromValue": {
				"!type": "+Object"
			},
			"toValue": {
				"!type": "+Object"
			},
			"valueFunction": {
				"!type": "+CAValueFunction"
			},
			"cumulative": {
				"!type": "bool"
			},
			"additive": {
				"!type": "bool"
			},
			"keyPath": {
				"!type": "string"
			},
			"timingFunction": {
				"!type": "+CAMediaTimingFunction"
			},
			"delegate": {
				"!type": "+Object"
			},
			"removedOnCompletion": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CABasicAnimation"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMutableTimedMetadataGroup": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMutableTimedMetadataGroup"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMutableTimedMetadataGroup"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMutableTimedMetadataGroup"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"items": {
				"!type": "+Array"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"items": {
				"!type": "+Array"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"items": {
				"!type": "+Array"
			},
			"classifyingLabel": {
				"!type": "string"
			},
			"uniqueID": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSampleBuffer": {
				"!type": "fn(sampleBuffer: +Object) -> +AVMutableTimedMetadataGroup"
			},
			"initWithItemsTimeRange": {
				"!type": "fn(items: +Array, timeRange: +Object) -> +AVMutableTimedMetadataGroup"
			},
			"copyFormatDescription": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMutableTimedMetadataGroup"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSPort": {
		"port": {
			"!type": "fn() -> +NSPort"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSPort"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSPort"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSPort"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"reservedSpaceLength": {
				"!type": "number"
			},
			"valid": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"invalidate": {
				"!type": "fn() -> void"
			},
			"sendBeforeDateMsgidComponentsFromReserved": {
				"!type": "fn(limitDate: +Date, msgID: number, components: +NSMutableArray, receivePort: +NSPort, headerSpaceReserved: number) -> bool"
			},
			"setDelegate": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"scheduleInRunLoopForMode": {
				"!type": "fn(runLoop: +NSRunLoop, mode: string) -> void"
			},
			"removeFromRunLoopForMode": {
				"!type": "fn(runLoop: +NSRunLoop, mode: string) -> void"
			},
			"sendBeforeDateComponentsFromReserved": {
				"!type": "fn(limitDate: +Date, components: +NSMutableArray, receivePort: +NSPort, headerSpaceReserved: number) -> bool"
			},
			"delegate": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSPort"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVSampleBufferDisplayLayer": {
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"layer": {
			"!type": "fn() -> +AVSampleBufferDisplayLayer"
		},
		"cornerCurveExpansionFactor": {
			"!type": "fn(curve: string) -> number"
		},
		"needsDisplayForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"defaultActionForKey": {
			"!type": "fn(event: string) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVSampleBufferDisplayLayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVSampleBufferDisplayLayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVSampleBufferDisplayLayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"status": {
				"!type": "number"
			},
			"controlTimebase": {
				"!type": "+Object"
			},
			"videoGravity": {
				"!type": "string"
			},
			"requiresFlushToResumeDecoding": {
				"!type": "bool"
			},
			"error": {
				"!type": "+NSError"
			},
			"preventsCapture": {
				"!type": "bool"
			},
			"readyForMoreMediaData": {
				"!type": "bool"
			},
			"preventsDisplaySleepDuringVideoPlayback": {
				"!type": "bool"
			},
			"visibleRect": {
				"!type": "+Object"
			},
			"contentsFormat": {
				"!type": "string"
			},
			"superlayer": {
				"!type": "+CALayer"
			},
			"mask": {
				"!type": "+CALayer"
			},
			"frame": {
				"!type": "+Object"
			},
			"actions": {
				"!type": "+Object"
			},
			"allowsEdgeAntialiasing": {
				"!type": "bool"
			},
			"filters": {
				"!type": "+Array"
			},
			"doubleSided": {
				"!type": "bool"
			},
			"shadowRadius": {
				"!type": "number"
			},
			"compositingFilter": {
				"!type": "+Object"
			},
			"contents": {
				"!type": "+Object"
			},
			"borderColor": {
				"!type": "+Object"
			},
			"style": {
				"!type": "+Object"
			},
			"rasterizationScale": {
				"!type": "number"
			},
			"backgroundFilters": {
				"!type": "+Array"
			},
			"shadowOpacity": {
				"!type": "number"
			},
			"magnificationFilter": {
				"!type": "string"
			},
			"opaque": {
				"!type": "bool"
			},
			"transform": {
				"!type": "+Object"
			},
			"minificationFilter": {
				"!type": "string"
			},
			"shadowColor": {
				"!type": "+Object"
			},
			"contentsCenter": {
				"!type": "+Object"
			},
			"contentsScale": {
				"!type": "number"
			},
			"masksToBounds": {
				"!type": "bool"
			},
			"zPosition": {
				"!type": "number"
			},
			"shadowPath": {
				"!type": "+Object"
			},
			"borderWidth": {
				"!type": "number"
			},
			"opacity": {
				"!type": "number"
			},
			"needsDisplayOnBoundsChange": {
				"!type": "bool"
			},
			"edgeAntialiasingMask": {
				"!type": "number"
			},
			"backgroundColor": {
				"!type": "+Object"
			},
			"cornerCurve": {
				"!type": "string"
			},
			"allowsGroupOpacity": {
				"!type": "bool"
			},
			"maskedCorners": {
				"!type": "number"
			},
			"cornerRadius": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"shadowOffset": {
				"!type": "+Object"
			},
			"anchorPointZ": {
				"!type": "number"
			},
			"hidden": {
				"!type": "bool"
			},
			"anchorPoint": {
				"!type": "+Object"
			},
			"name": {
				"!type": "string"
			},
			"geometryFlipped": {
				"!type": "bool"
			},
			"drawsAsynchronously": {
				"!type": "bool"
			},
			"contentsRect": {
				"!type": "+Object"
			},
			"bounds": {
				"!type": "+Object"
			},
			"minificationFilterBias": {
				"!type": "number"
			},
			"sublayers": {
				"!type": "+Array"
			},
			"contentsGravity": {
				"!type": "string"
			},
			"position": {
				"!type": "+Object"
			},
			"sublayerTransform": {
				"!type": "+Object"
			},
			"shouldRasterize": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"requestMediaDataWhenReadyOnQueueUsingBlock": {
				"!type": "fn(queue: +Object, block: +Function) -> void"
			},
			"stopRequestingMediaData": {
				"!type": "fn() -> void"
			},
			"flush": {
				"!type": "fn() -> void"
			},
			"flushAndRemoveImage": {
				"!type": "fn() -> void"
			},
			"enqueueSampleBuffer": {
				"!type": "fn(sampleBuffer: +Object) -> void"
			},
			"hitTest": {
				"!type": "fn(p: +Object) -> +CALayer"
			},
			"displayIfNeeded": {
				"!type": "fn() -> void"
			},
			"insertSublayerBelow": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"setAffineTransform": {
				"!type": "fn(m: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVSampleBufferDisplayLayer"
			},
			"convertPointFromLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"convertPointToLayer": {
				"!type": "fn(p: +Object, l: +CALayer) -> +Object"
			},
			"layoutSublayers": {
				"!type": "fn() -> void"
			},
			"removeAnimationForKey": {
				"!type": "fn(key: string) -> void"
			},
			"affineTransform": {
				"!type": "fn() -> +Object"
			},
			"actionForKey": {
				"!type": "fn(event: string) -> +Object"
			},
			"convertTimeToLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"animationForKey": {
				"!type": "fn(key: string) -> +CAAnimation"
			},
			"animationKeys": {
				"!type": "fn() -> +Array"
			},
			"convertRectFromLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"display": {
				"!type": "fn() -> void"
			},
			"scrollRectToVisible": {
				"!type": "fn(r: +Object) -> void"
			},
			"removeAllAnimations": {
				"!type": "fn() -> void"
			},
			"needsDisplay": {
				"!type": "fn() -> bool"
			},
			"needsLayout": {
				"!type": "fn() -> bool"
			},
			"drawInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"initWithLayer": {
				"!type": "fn(layer: +Object) -> +AVSampleBufferDisplayLayer"
			},
			"addAnimationForKey": {
				"!type": "fn(anim: +CAAnimation, key: string) -> void"
			},
			"setNeedsLayout": {
				"!type": "fn() -> void"
			},
			"removeFromSuperlayer": {
				"!type": "fn() -> void"
			},
			"replaceSublayerWith": {
				"!type": "fn(oldLayer: +CALayer, newLayer: +CALayer) -> void"
			},
			"presentationLayer": {
				"!type": "fn() -> +AVSampleBufferDisplayLayer"
			},
			"setNeedsDisplayInRect": {
				"!type": "fn(r: +Object) -> void"
			},
			"convertTimeFromLayer": {
				"!type": "fn(t: number, l: +CALayer) -> number"
			},
			"setNeedsDisplay": {
				"!type": "fn() -> void"
			},
			"insertSublayerAtIndex": {
				"!type": "fn(layer: +CALayer, idx: number) -> void"
			},
			"layoutIfNeeded": {
				"!type": "fn() -> void"
			},
			"modelLayer": {
				"!type": "fn() -> +AVSampleBufferDisplayLayer"
			},
			"containsPoint": {
				"!type": "fn(p: +Object) -> bool"
			},
			"contentsAreFlipped": {
				"!type": "fn() -> bool"
			},
			"scrollPoint": {
				"!type": "fn(p: +Object) -> void"
			},
			"insertSublayerAbove": {
				"!type": "fn(layer: +CALayer, sibling: +CALayer) -> void"
			},
			"addSublayer": {
				"!type": "fn(layer: +CALayer) -> void"
			},
			"convertRectToLayer": {
				"!type": "fn(r: +Object, l: +CALayer) -> +Object"
			},
			"renderInContext": {
				"!type": "fn(ctx: +Object) -> void"
			},
			"preferredFrameSize": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVSampleBufferDisplayLayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerItemMetadataOutput": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerItemMetadataOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerItemMetadataOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerItemMetadataOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"advanceIntervalForDelegateInvocation": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"suppressesPlayerRendering": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setDelegateQueue": {
				"!type": "fn(delegate: +Object, delegateQueue: +Object) -> void"
			},
			"initWithIdentifiers": {
				"!type": "fn(identifiers: +Array) -> +AVPlayerItemMetadataOutput"
			},
			"itemTimeForHostTime": {
				"!type": "fn(hostTimeInSeconds: number) -> +Object"
			},
			"itemTimeForMachAbsoluteTime": {
				"!type": "fn(machAbsoluteTime: number) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerItemMetadataOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMutableMovieTrack": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMutableMovieTrack"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMutableMovieTrack"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMutableMovieTrack"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"languageCode": {
				"!type": "string"
			},
			"layer": {
				"!type": "number"
			},
			"preferredMediaChunkDuration": {
				"!type": "+Object"
			},
			"alternateGroupID": {
				"!type": "number"
			},
			"timescale": {
				"!type": "number"
			},
			"mediaDataStorage": {
				"!type": "+AVMediaDataStorage"
			},
			"extendedLanguageTag": {
				"!type": "string"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"enabled": {
				"!type": "bool"
			},
			"modified": {
				"!type": "bool"
			},
			"hasProtectedContent": {
				"!type": "bool"
			},
			"cleanApertureDimensions": {
				"!type": "+Object"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"metadata": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"productionApertureDimensions": {
				"!type": "+Object"
			},
			"sampleReferenceBaseURL": {
				"!type": "+NSURL"
			},
			"preferredMediaChunkAlignment": {
				"!type": "number"
			},
			"preferredMediaChunkSize": {
				"!type": "number"
			},
			"encodedPixelsDimensions": {
				"!type": "+Object"
			},
			"mediaDecodeTimeRange": {
				"!type": "+Object"
			},
			"alternateGroupID": {
				"!type": "number"
			},
			"mediaPresentationTimeRange": {
				"!type": "+Object"
			},
			"mediaDataStorage": {
				"!type": "+AVMediaDataStorage"
			},
			"languageCode": {
				"!type": "string"
			},
			"minFrameDuration": {
				"!type": "+Object"
			},
			"formatDescriptions": {
				"!type": "+Array"
			},
			"availableTrackAssociationTypes": {
				"!type": "+Array"
			},
			"nominalFrameRate": {
				"!type": "number"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"estimatedDataRate": {
				"!type": "number"
			},
			"naturalTimeScale": {
				"!type": "number"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"requiresFrameReordering": {
				"!type": "bool"
			},
			"hasAudioSampleDependencies": {
				"!type": "bool"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"selfContained": {
				"!type": "bool"
			},
			"segments": {
				"!type": "+Array"
			},
			"timeRange": {
				"!type": "+Object"
			},
			"extendedLanguageTag": {
				"!type": "string"
			},
			"mediaType": {
				"!type": "string"
			},
			"asset": {
				"!type": "+AVAsset"
			},
			"trackID": {
				"!type": "number"
			},
			"totalSampleDataLength": {
				"!type": "number"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"decodable": {
				"!type": "bool"
			},
			"enabled": {
				"!type": "bool"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"scaleTimeRangeToDuration": {
				"!type": "fn(timeRange: +Object, duration: +Object) -> void"
			},
			"insertMediaTimeRangeIntoTimeRange": {
				"!type": "fn(mediaTimeRange: +Object, trackTimeRange: +Object) -> bool"
			},
			"addTrackAssociationToTrackType": {
				"!type": "fn(movieTrack: +AVMovieTrack, trackAssociationType: string) -> void"
			},
			"insertEmptyTimeRange": {
				"!type": "fn(timeRange: +Object) -> void"
			},
			"removeTimeRange": {
				"!type": "fn(timeRange: +Object) -> void"
			},
			"appendSampleBufferDecodeTimePresentationTimeError": {
				"!type": "fn(sampleBuffer: +Object, outDecodeTime: +Object, outPresentationTime: +Object, outError: +Object) -> bool"
			},
			"insertTimeRangeOfTrackAtTimeCopySampleDataError": {
				"!type": "fn(timeRange: +Object, track: +AVAssetTrack, startTime: +Object, copySampleData: bool, outError: +Object) -> bool"
			},
			"removeTrackAssociationToTrackType": {
				"!type": "fn(movieTrack: +AVMovieTrack, trackAssociationType: string) -> void"
			},
			"replaceFormatDescriptionWithFormatDescription": {
				"!type": "fn(formatDescription: +Object, newFormatDescription: +Object) -> void"
			},
			"hasMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> bool"
			},
			"samplePresentationTimeForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +Object"
			},
			"associatedTracksOfType": {
				"!type": "fn(trackAssociationType: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"segmentForTrackTime": {
				"!type": "fn(trackTime: +Object) -> +AVAssetTrackSegment"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMutableMovieTrack"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSProcessInfo": {
		"processInfo": {
			"!type": "fn() -> +NSProcessInfo"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSProcessInfo"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSProcessInfo"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSProcessInfo"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"systemUptime": {
				"!type": "number"
			},
			"physicalMemory": {
				"!type": "number"
			},
			"iOSAppOnMac": {
				"!type": "bool"
			},
			"hostName": {
				"!type": "string"
			},
			"lowPowerModeEnabled": {
				"!type": "bool"
			},
			"processorCount": {
				"!type": "number"
			},
			"environment": {
				"!type": "+Object"
			},
			"processName": {
				"!type": "string"
			},
			"processIdentifier": {
				"!type": "number"
			},
			"arguments": {
				"!type": "+Array"
			},
			"macCatalystApp": {
				"!type": "bool"
			},
			"operatingSystemVersion": {
				"!type": "+Object"
			},
			"globallyUniqueString": {
				"!type": "string"
			},
			"activeProcessorCount": {
				"!type": "number"
			},
			"thermalState": {
				"!type": "number"
			},
			"operatingSystemVersionString": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"performExpiringActivityWithReasonUsingBlock": {
				"!type": "fn(reason: string, block: +Function) -> void"
			},
			"endActivity": {
				"!type": "fn(activity: +Object) -> void"
			},
			"operatingSystemName": {
				"!type": "fn() -> string"
			},
			"beginActivityWithOptionsReason": {
				"!type": "fn(options: number, reason: string) -> +Object"
			},
			"performActivityWithOptionsReasonUsingBlock": {
				"!type": "fn(options: number, reason: string, block: +Function) -> void"
			},
			"isOperatingSystemAtLeastVersion": {
				"!type": "fn(version: +Object) -> bool"
			},
			"operatingSystem": {
				"!type": "fn() -> number"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSProcessInfo"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CAMediaTimingFunction": {
		"functionWithName": {
			"!type": "fn(name: string) -> +CAMediaTimingFunction"
		},
		"functionWithControlPoints": {
			"!type": "fn(c1x: number, c1y: number, c2x: number, c2y: number) -> +CAMediaTimingFunction"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CAMediaTimingFunction"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CAMediaTimingFunction"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CAMediaTimingFunction"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithControlPoints": {
				"!type": "fn(c1x: number, c1y: number, c2x: number, c2y: number) -> +CAMediaTimingFunction"
			},
			"getControlPointAtIndexValues": {
				"!type": "fn(idx: number, ptr: +Array) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAMediaTimingFunction"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSDate": {
		"dateWithTimeIntervalSince1970": {
			"!type": "fn(secs: number) -> +Date"
		},
		"dateWithTimeIntervalSinceReferenceDate": {
			"!type": "fn(ti: number) -> +Date"
		},
		"distantPast": {
			"!type": "fn() -> +Date"
		},
		"dateWithTimeIntervalSinceDate": {
			"!type": "fn(secsToBeAdded: number, date: +Date) -> +Date"
		},
		"distantFuture": {
			"!type": "fn() -> +Date"
		},
		"dateWithTimeIntervalSinceNow": {
			"!type": "fn(secs: number) -> +Date"
		},
		"timeIntervalSinceReferenceDate": {
			"!type": "fn() -> number"
		},
		"date": {
			"!type": "fn() -> +Date"
		},
		"now": {
			"!type": "fn() -> +Date"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +Date"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +Date"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +Date"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"timeIntervalSinceReferenceDate": {
				"!type": "number"
			},
			"timeIntervalSince1970": {
				"!type": "number"
			},
			"description": {
				"!type": "string"
			},
			"timeIntervalSinceNow": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"descriptionWithLocale": {
				"!type": "fn(locale: +Object) -> string"
			},
			"addTimeInterval": {
				"!type": "fn(seconds: number) -> +Object"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +Date"
			},
			"initWithTimeIntervalSinceDate": {
				"!type": "fn(secsToBeAdded: number, date: +Date) -> +Date"
			},
			"dateByAddingTimeInterval": {
				"!type": "fn(ti: number) -> +Date"
			},
			"timeIntervalSinceDate": {
				"!type": "fn(anotherDate: +Date) -> number"
			},
			"initWithTimeIntervalSinceNow": {
				"!type": "fn(secs: number) -> +Date"
			},
			"isEqualToDate": {
				"!type": "fn(otherDate: +Date) -> bool"
			},
			"jsinit": {
				"!type": "fn() -> +Date"
			},
			"earlierDate": {
				"!type": "fn(anotherDate: +Date) -> +Date"
			},
			"initWithTimeIntervalSinceReferenceDate": {
				"!type": "fn(ti: number) -> +Date"
			},
			"compare": {
				"!type": "fn(other: +Date) -> number"
			},
			"laterDate": {
				"!type": "fn(anotherDate: +Date) -> +Date"
			},
			"initWithTimeIntervalSince1970": {
				"!type": "fn(secs: number) -> +Date"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +Date"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSData": {
		"dataWithContentsOfFile": {
			"!type": "fn(path: string) -> +NSData"
		},
		"dataWithContentsOfMappedFile": {
			"!type": "fn(path: string) -> +Object"
		},
		"dataWithBytesNoCopyLength": {
			"!type": "fn(bytes: +Object, length: number) -> +NSData"
		},
		"dataWithContentsOfURL": {
			"!type": "fn(url: +NSURL) -> +NSData"
		},
		"dataWithBytesNoCopyLengthFreeWhenDone": {
			"!type": "fn(bytes: +Object, length: number, b: bool) -> +NSData"
		},
		"dataWithData": {
			"!type": "fn(data: +NSData) -> +NSData"
		},
		"dataWithContentsOfURLOptionsError": {
			"!type": "fn(url: +NSURL, readOptionsMask: number, errorPtr: +Object) -> +NSData"
		},
		"dataWithBytesLength": {
			"!type": "fn(bytes: +Object, length: number) -> +NSData"
		},
		"dataWithContentsOfFileOptionsError": {
			"!type": "fn(path: string, readOptionsMask: number, errorPtr: +Object) -> +NSData"
		},
		"data": {
			"!type": "fn() -> +NSData"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSData"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSData"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSData"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"length": {
				"!type": "number"
			},
			"description": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithContentsOfFileOptionsError": {
				"!type": "fn(path: string, readOptionsMask: number, errorPtr: +Object) -> +NSData"
			},
			"initWithBase64Encoding": {
				"!type": "fn(base64String: string) -> +Object"
			},
			"subdataWithRange": {
				"!type": "fn(range: +Object) -> +NSData"
			},
			"initWithBytesNoCopyLengthFreeWhenDone": {
				"!type": "fn(bytes: +Object, length: number, b: bool) -> +NSData"
			},
			"writeToURLOptionsError": {
				"!type": "fn(url: +NSURL, writeOptionsMask: number, errorPtr: +Object) -> bool"
			},
			"rangeOfDataOptionsRange": {
				"!type": "fn(dataToFind: +NSData, mask: number, searchRange: +Object) -> +Object"
			},
			"base64Encoding": {
				"!type": "fn() -> string"
			},
			"initWithContentsOfURL": {
				"!type": "fn(url: +NSURL) -> +NSData"
			},
			"compressedDataUsingAlgorithmError": {
				"!type": "fn(algorithm: number, error: +Object) -> +NSData"
			},
			"enumerateByteRangesUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"base64EncodedStringWithOptions": {
				"!type": "fn(options: number) -> string"
			},
			"getBytesLength": {
				"!type": "fn(buffer: +Object, length: number) -> void"
			},
			"initWithBytesNoCopyLengthDeallocator": {
				"!type": "fn(bytes: +Object, length: number, deallocator: +Function) -> +NSData"
			},
			"initWithContentsOfFile": {
				"!type": "fn(path: string) -> +NSData"
			},
			"writeToFileAtomically": {
				"!type": "fn(path: string, useAuxiliaryFile: bool) -> bool"
			},
			"initWithBytesLength": {
				"!type": "fn(bytes: +Object, length: number) -> +NSData"
			},
			"writeToFileOptionsError": {
				"!type": "fn(path: string, writeOptionsMask: number, errorPtr: +Object) -> bool"
			},
			"base64EncodedDataWithOptions": {
				"!type": "fn(options: number) -> +NSData"
			},
			"getBytes": {
				"!type": "fn(buffer: +Object) -> void"
			},
			"isEqualToData": {
				"!type": "fn(other: +NSData) -> bool"
			},
			"writeToURLAtomically": {
				"!type": "fn(url: +NSURL, atomically: bool) -> bool"
			},
			"getBytesRange": {
				"!type": "fn(buffer: +Object, range: +Object) -> void"
			},
			"initWithBase64EncodedDataOptions": {
				"!type": "fn(base64Data: +NSData, options: number) -> +NSData"
			},
			"initWithContentsOfMappedFile": {
				"!type": "fn(path: string) -> +Object"
			},
			"decompressedDataUsingAlgorithmError": {
				"!type": "fn(algorithm: number, error: +Object) -> +NSData"
			},
			"initWithContentsOfURLOptionsError": {
				"!type": "fn(url: +NSURL, readOptionsMask: number, errorPtr: +Object) -> +NSData"
			},
			"initWithBytesNoCopyLength": {
				"!type": "fn(bytes: +Object, length: number) -> +NSData"
			},
			"initWithData": {
				"!type": "fn(data: +NSData) -> +NSData"
			},
			"initWithBase64EncodedStringOptions": {
				"!type": "fn(base64String: string, options: number) -> +NSData"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSData"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitPower": {
		"microwatts": {
			"!type": "fn() -> +NSUnitPower"
		},
		"watts": {
			"!type": "fn() -> +NSUnitPower"
		},
		"gigawatts": {
			"!type": "fn() -> +NSUnitPower"
		},
		"nanowatts": {
			"!type": "fn() -> +NSUnitPower"
		},
		"megawatts": {
			"!type": "fn() -> +NSUnitPower"
		},
		"picowatts": {
			"!type": "fn() -> +NSUnitPower"
		},
		"femtowatts": {
			"!type": "fn() -> +NSUnitPower"
		},
		"horsepower": {
			"!type": "fn() -> +NSUnitPower"
		},
		"terawatts": {
			"!type": "fn() -> +NSUnitPower"
		},
		"milliwatts": {
			"!type": "fn() -> +NSUnitPower"
		},
		"kilowatts": {
			"!type": "fn() -> +NSUnitPower"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitPower"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitPower"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitPower"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitPower"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitPower"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitPower"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitPower"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMutableURLRequest": {
		"supportsSecureCoding": {
			"!type": "fn() -> bool"
		},
		"requestWithURL": {
			"!type": "fn(URL: +NSURL) -> +NSMutableURLRequest"
		},
		"requestWithURLCachePolicyTimeoutInterval": {
			"!type": "fn(URL: +NSURL, cachePolicy: number, timeoutInterval: number) -> +NSMutableURLRequest"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMutableURLRequest"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMutableURLRequest"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMutableURLRequest"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"timeoutInterval": {
				"!type": "number"
			},
			"allowsConstrainedNetworkAccess": {
				"!type": "bool"
			},
			"networkServiceType": {
				"!type": "number"
			},
			"allHTTPHeaderFields": {
				"!type": "+Object"
			},
			"HTTPMethod": {
				"!type": "string"
			},
			"URL": {
				"!type": "+NSURL"
			},
			"allowsCellularAccess": {
				"!type": "bool"
			},
			"HTTPBody": {
				"!type": "+NSData"
			},
			"mainDocumentURL": {
				"!type": "+NSURL"
			},
			"HTTPBodyStream": {
				"!type": "+NSInputStream"
			},
			"HTTPShouldHandleCookies": {
				"!type": "bool"
			},
			"allowsExpensiveNetworkAccess": {
				"!type": "bool"
			},
			"HTTPShouldUsePipelining": {
				"!type": "bool"
			},
			"cachePolicy": {
				"!type": "number"
			},
			"timeoutInterval": {
				"!type": "number"
			},
			"allowsConstrainedNetworkAccess": {
				"!type": "bool"
			},
			"networkServiceType": {
				"!type": "number"
			},
			"allHTTPHeaderFields": {
				"!type": "+Object"
			},
			"HTTPMethod": {
				"!type": "string"
			},
			"URL": {
				"!type": "+NSURL"
			},
			"allowsCellularAccess": {
				"!type": "bool"
			},
			"HTTPBody": {
				"!type": "+NSData"
			},
			"mainDocumentURL": {
				"!type": "+NSURL"
			},
			"HTTPBodyStream": {
				"!type": "+NSInputStream"
			},
			"HTTPShouldHandleCookies": {
				"!type": "bool"
			},
			"allowsExpensiveNetworkAccess": {
				"!type": "bool"
			},
			"HTTPShouldUsePipelining": {
				"!type": "bool"
			},
			"cachePolicy": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setValueForHTTPHeaderField": {
				"!type": "fn(value: string, field: string) -> void"
			},
			"addValueForHTTPHeaderField": {
				"!type": "fn(value: string, field: string) -> void"
			},
			"initWithURL": {
				"!type": "fn(URL: +NSURL) -> +NSMutableURLRequest"
			},
			"valueForHTTPHeaderField": {
				"!type": "fn(field: string) -> string"
			},
			"initWithURLCachePolicyTimeoutInterval": {
				"!type": "fn(URL: +NSURL, cachePolicy: number, timeoutInterval: number) -> +NSMutableURLRequest"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableURLRequest"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLSessionWebSocketMessage": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLSessionWebSocketMessage"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLSessionWebSocketMessage"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLSessionWebSocketMessage"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"data": {
				"!type": "+NSData"
			},
			"type": {
				"!type": "number"
			},
			"string": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithData": {
				"!type": "fn(data: +NSData) -> +NSURLSessionWebSocketMessage"
			},
			"initWithString": {
				"!type": "fn(string: string) -> +NSURLSessionWebSocketMessage"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLSessionWebSocketMessage"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnitVarispeed": {
		"instantiateWithComponentDescriptionOptionsCompletionHandler": {
			"!type": "fn(audioComponentDescription: +Object, options: number, completionHandler: +Function) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnitVarispeed"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnitVarispeed"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnitVarispeed"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"rate": {
				"!type": "number"
			},
			"bypass": {
				"!type": "bool"
			},
			"name": {
				"!type": "string"
			},
			"audioComponentDescription": {
				"!type": "+Object"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"version": {
				"!type": "number"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithAudioComponentDescription": {
				"!type": "fn(audioComponentDescription: +Object) -> +AVAudioUnitVarispeed"
			},
			"loadAudioUnitPresetAtURLError": {
				"!type": "fn(url: +NSURL, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnitVarispeed"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMeasurement": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMeasurement"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMeasurement"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMeasurement"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"doubleValue": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"measurementByConvertingToUnit": {
				"!type": "fn(unit: +NSUnit) -> +NSMeasurement"
			},
			"canBeConvertedToUnit": {
				"!type": "fn(unit: +NSUnit) -> bool"
			},
			"measurementByAddingMeasurement": {
				"!type": "fn(measurement: +NSMeasurement) -> +NSMeasurement"
			},
			"measurementBySubtractingMeasurement": {
				"!type": "fn(measurement: +NSMeasurement) -> +NSMeasurement"
			},
			"initWithDoubleValueUnit": {
				"!type": "fn(doubleValue: number, unit: +Object) -> +NSMeasurement"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMeasurement"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSOrderedCollectionDifference": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSOrderedCollectionDifference"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSOrderedCollectionDifference"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSOrderedCollectionDifference"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"hasChanges": {
				"!type": "bool"
			},
			"removals": {
				"!type": "+Array"
			},
			"insertions": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"inverseDifference": {
				"!type": "fn() -> +NSOrderedCollectionDifference"
			},
			"initWithInsertIndexesInsertedObjectsRemoveIndexesRemovedObjectsAdditionalChanges": {
				"!type": "fn(inserts: +NSIndexSet, insertedObjects: +Array, removes: +NSIndexSet, removedObjects: +Array, changes: +Array) -> +NSOrderedCollectionDifference"
			},
			"initWithChanges": {
				"!type": "fn(changes: +Array) -> +NSOrderedCollectionDifference"
			},
			"differenceByTransformingChangesWithBlock": {
				"!type": "fn(block: +Function) -> +NSOrderedCollectionDifference"
			},
			"initWithInsertIndexesInsertedObjectsRemoveIndexesRemovedObjects": {
				"!type": "fn(inserts: +NSIndexSet, insertedObjects: +Array, removes: +NSIndexSet, removedObjects: +Array) -> +NSOrderedCollectionDifference"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSOrderedCollectionDifference"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSPredicate": {
		"predicateWithFormatArguments": {
			"!type": "fn(predicateFormat: string, argList: +Object) -> +NSPredicate"
		},
		"predicateWithFormat": {
			"!type": "fn(predicateFormat: string, args: Array.prototype) -> +NSPredicate"
		},
		"predicateWithValue": {
			"!type": "fn(value: bool) -> +NSPredicate"
		},
		"predicateWithFormatArgumentArray": {
			"!type": "fn(predicateFormat: string, arguments: +Array) -> +NSPredicate"
		},
		"predicateWithBlock": {
			"!type": "fn(block: +Function) -> +NSPredicate"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSPredicate"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSPredicate"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSPredicate"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"predicateFormat": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"predicateWithSubstitutionVariables": {
				"!type": "fn(variables: +Object) -> +NSPredicate"
			},
			"evaluateWithObject": {
				"!type": "fn(object: +Object) -> bool"
			},
			"allowEvaluation": {
				"!type": "fn() -> void"
			},
			"evaluateWithObjectSubstitutionVariables": {
				"!type": "fn(object: +Object, bindings: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSPredicate"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSProxy": {
		"alloc": {
			"!type": "fn() -> +Object"
		},
		"respondsToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSProxy"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSProxy"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSProxy"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"debugDescription": {
				"!type": "string"
			},
			"description": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"methodSignatureForSelector": {
				"!type": "fn(sel: string) -> +NSMethodSignature"
			},
			"forwardInvocation": {
				"!type": "fn(invocation: +NSInvocation) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSProxy"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSCoder": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSCoder"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSCoder"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSCoder"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"requiresSecureCoding": {
				"!type": "bool"
			},
			"systemVersion": {
				"!type": "number"
			},
			"error": {
				"!type": "+NSError"
			},
			"allowedClasses": {
				"!type": "+NSSet"
			},
			"decodingFailurePolicy": {
				"!type": "number"
			},
			"allowsKeyedCoding": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"decodeObjectOfClassForKey": {
				"!type": "fn(aClass: +Object, key: string) -> +Object"
			},
			"decodeDataObject": {
				"!type": "fn() -> +NSData"
			},
			"versionForClassName": {
				"!type": "fn(className: string) -> number"
			},
			"encodeBoolForKey": {
				"!type": "fn(value: bool, key: string) -> void"
			},
			"encodeConditionalObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"decodeCMTimeForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"failWithError": {
				"!type": "fn(error: +NSError) -> void"
			},
			"encodeArrayOfObjCTypeCountAt": {
				"!type": "fn(type: +Object, count: number, array: +Object) -> void"
			},
			"setObjectZone": {
				"!type": "fn(zone: +Object) -> void"
			},
			"decodeInt64ForKey": {
				"!type": "fn(key: string) -> number"
			},
			"decodeArrayOfObjectsOfClassesForKey": {
				"!type": "fn(classes: +NSSet, key: string) -> +Array"
			},
			"encodeInt64ForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeInt32ForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeValuesOfObjCTypes": {
				"!type": "fn(types: +Object, args: Array.prototype) -> void"
			},
			"encodeIntegerForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"decodeTopLevelObjectForKeyError": {
				"!type": "fn(key: string, error: +Object) -> +Object"
			},
			"decodeCMTimeRangeForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"decodeValuesOfObjCTypes": {
				"!type": "fn(types: +Object, args: Array.prototype) -> void"
			},
			"decodeValueOfObjCTypeAt": {
				"!type": "fn(type: +Object, data: +Object) -> void"
			},
			"containsValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"encodeFloatForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"objectZone": {
				"!type": "fn() -> +Object"
			},
			"decodeDoubleForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeByrefObject": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"decodeInt32ForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeObject": {
				"!type": "fn(object: +Object) -> void"
			},
			"decodeDictionaryWithKeysOfClassesObjectsOfClassesForKey": {
				"!type": "fn(keyClasses: +NSSet, objectClasses: +NSSet, key: string) -> +Object"
			},
			"encodeDataObject": {
				"!type": "fn(data: +NSData) -> void"
			},
			"decodeTopLevelObjectAndReturnError": {
				"!type": "fn(error: +Object) -> +Object"
			},
			"decodeFloatForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeValueOfObjCTypeAt": {
				"!type": "fn(type: +Object, addr: +Object) -> void"
			},
			"decodeObjectForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"encodeBytesLengthForKey": {
				"!type": "fn(bytes: +Object, length: number, key: string) -> void"
			},
			"decodeArrayOfObjCTypeCountAt": {
				"!type": "fn(itemType: +Object, count: number, array: +Object) -> void"
			},
			"encodeRootObject": {
				"!type": "fn(rootObject: +Object) -> void"
			},
			"decodeBoolForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"encodeBytesLength": {
				"!type": "fn(byteaddr: +Object, length: number) -> void"
			},
			"encodeCMTimeRangeForKey": {
				"!type": "fn(timeRange: +Object, key: string) -> void"
			},
			"decodeBytesWithReturnedLength": {
				"!type": "fn(lengthp: +Object) -> +Object"
			},
			"decodeIntForKey": {
				"!type": "fn(key: string) -> number"
			},
			"encodeCMTimeMappingForKey": {
				"!type": "fn(timeMapping: +Object, key: string) -> void"
			},
			"decodeArrayOfObjectsOfClassForKey": {
				"!type": "fn(cls: +Object, key: string) -> +Array"
			},
			"encodeDoubleForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"encodeCMTimeForKey": {
				"!type": "fn(time: +Object, key: string) -> void"
			},
			"decodeObjectOfClassesForKey": {
				"!type": "fn(classes: +NSSet, key: string) -> +Object"
			},
			"decodeDictionaryWithKeysOfClassObjectsOfClassForKey": {
				"!type": "fn(keyCls: +Object, objectCls: +Object, key: string) -> +Object"
			},
			"encodeIntForKey": {
				"!type": "fn(value: number, key: string) -> void"
			},
			"decodeCMTimeMappingForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"decodeTopLevelObjectOfClassesForKeyError": {
				"!type": "fn(classes: +NSSet, key: string, error: +Object) -> +Object"
			},
			"encodeObjectForKey": {
				"!type": "fn(object: +Object, key: string) -> void"
			},
			"decodeObject": {
				"!type": "fn() -> +Object"
			},
			"encodeBycopyObject": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"decodePropertyListForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"decodeTopLevelObjectOfClassForKeyError": {
				"!type": "fn(aClass: +Object, key: string, error: +Object) -> +Object"
			},
			"decodeIntegerForKey": {
				"!type": "fn(key: string) -> number"
			},
			"decodeValueOfObjCTypeAtSize": {
				"!type": "fn(type: +Object, data: +Object, size: number) -> void"
			},
			"decodeBytesForKeyReturnedLength": {
				"!type": "fn(key: string, lengthp: +Object) -> +Object"
			},
			"encodeConditionalObjectForKey": {
				"!type": "fn(object: +Object, key: string) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSCoder"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSDateComponents": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSDateComponents"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSDateComponents"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSDateComponents"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"leapMonth": {
				"!type": "bool"
			},
			"validDate": {
				"!type": "bool"
			},
			"weekOfYear": {
				"!type": "number"
			},
			"hour": {
				"!type": "number"
			},
			"weekdayOrdinal": {
				"!type": "number"
			},
			"nanosecond": {
				"!type": "number"
			},
			"month": {
				"!type": "number"
			},
			"yearForWeekOfYear": {
				"!type": "number"
			},
			"second": {
				"!type": "number"
			},
			"weekOfMonth": {
				"!type": "number"
			},
			"era": {
				"!type": "number"
			},
			"year": {
				"!type": "number"
			},
			"date": {
				"!type": "+Date"
			},
			"timeZone": {
				"!type": "+NSTimeZone"
			},
			"calendar": {
				"!type": "+NSCalendar"
			},
			"quarter": {
				"!type": "number"
			},
			"day": {
				"!type": "number"
			},
			"minute": {
				"!type": "number"
			},
			"weekday": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"valueForComponent": {
				"!type": "fn(unit: number) -> number"
			},
			"setWeek": {
				"!type": "fn(v: number) -> void"
			},
			"week": {
				"!type": "fn() -> number"
			},
			"isValidDateInCalendar": {
				"!type": "fn(calendar: +NSCalendar) -> bool"
			},
			"setValueForComponent": {
				"!type": "fn(value: number, unit: number) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSDateComponents"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSDateFormatter": {
		"setDefaultFormatterBehavior": {
			"!type": "fn(defaultFormatterBehavior: number) -> void"
		},
		"localizedStringFromDateDateStyleTimeStyle": {
			"!type": "fn(date: +Date, dstyle: number, tstyle: number) -> string"
		},
		"defaultFormatterBehavior": {
			"!type": "fn() -> number"
		},
		"dateFormatFromTemplateOptionsLocale": {
			"!type": "fn(tmplate: string, opts: number, locale: +NSLocale) -> string"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSDateFormatter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSDateFormatter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSDateFormatter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"standaloneWeekdaySymbols": {
				"!type": "+Array"
			},
			"longEraSymbols": {
				"!type": "+Array"
			},
			"weekdaySymbols": {
				"!type": "+Array"
			},
			"timeStyle": {
				"!type": "number"
			},
			"locale": {
				"!type": "+NSLocale"
			},
			"dateStyle": {
				"!type": "number"
			},
			"shortQuarterSymbols": {
				"!type": "+Array"
			},
			"shortStandaloneQuarterSymbols": {
				"!type": "+Array"
			},
			"twoDigitStartDate": {
				"!type": "+Date"
			},
			"generatesCalendarDates": {
				"!type": "bool"
			},
			"PMSymbol": {
				"!type": "string"
			},
			"defaultDate": {
				"!type": "+Date"
			},
			"dateFormat": {
				"!type": "string"
			},
			"shortStandaloneMonthSymbols": {
				"!type": "+Array"
			},
			"formatterBehavior": {
				"!type": "number"
			},
			"lenient": {
				"!type": "bool"
			},
			"eraSymbols": {
				"!type": "+Array"
			},
			"veryShortMonthSymbols": {
				"!type": "+Array"
			},
			"veryShortWeekdaySymbols": {
				"!type": "+Array"
			},
			"AMSymbol": {
				"!type": "string"
			},
			"shortStandaloneWeekdaySymbols": {
				"!type": "+Array"
			},
			"doesRelativeDateFormatting": {
				"!type": "bool"
			},
			"gregorianStartDate": {
				"!type": "+Date"
			},
			"timeZone": {
				"!type": "+NSTimeZone"
			},
			"shortWeekdaySymbols": {
				"!type": "+Array"
			},
			"quarterSymbols": {
				"!type": "+Array"
			},
			"shortMonthSymbols": {
				"!type": "+Array"
			},
			"standaloneMonthSymbols": {
				"!type": "+Array"
			},
			"formattingContext": {
				"!type": "number"
			},
			"standaloneQuarterSymbols": {
				"!type": "+Array"
			},
			"veryShortStandaloneMonthSymbols": {
				"!type": "+Array"
			},
			"calendar": {
				"!type": "+NSCalendar"
			},
			"monthSymbols": {
				"!type": "+Array"
			},
			"veryShortStandaloneWeekdaySymbols": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"getObjectValueForStringRangeError": {
				"!type": "fn(obj: +Object, string: string, rangep: +Object, error: +Object) -> bool"
			},
			"setLocalizedDateFormatFromTemplate": {
				"!type": "fn(dateFormatTemplate: string) -> void"
			},
			"stringFromDate": {
				"!type": "fn(date: +Date) -> string"
			},
			"dateFromString": {
				"!type": "fn(string: string) -> +Date"
			},
			"editingStringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription": {
				"!type": "fn(partialStringPtr: +Object, proposedSelRangePtr: +Object, origString: string, origSelRange: +Object, error: +Object) -> bool"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"attributedStringForObjectValueWithDefaultAttributes": {
				"!type": "fn(obj: +Object, attrs: +Object) -> +NSAttributedString"
			},
			"isPartialStringValidNewEditingStringErrorDescription": {
				"!type": "fn(partialString: string, newString: +Object, error: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSDateFormatter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSDateInterval": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSDateInterval"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSDateInterval"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSDateInterval"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"duration": {
				"!type": "number"
			},
			"startDate": {
				"!type": "+Date"
			},
			"endDate": {
				"!type": "+Date"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"isEqualToDateInterval": {
				"!type": "fn(dateInterval: +NSDateInterval) -> bool"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSDateInterval"
			},
			"initWithStartDateEndDate": {
				"!type": "fn(startDate: +Date, endDate: +Date) -> +NSDateInterval"
			},
			"containsDate": {
				"!type": "fn(date: +Date) -> bool"
			},
			"initWithStartDateDuration": {
				"!type": "fn(startDate: +Date, duration: number) -> +NSDateInterval"
			},
			"jsinit": {
				"!type": "fn() -> +NSDateInterval"
			},
			"intersectsDateInterval": {
				"!type": "fn(dateInterval: +NSDateInterval) -> bool"
			},
			"compare": {
				"!type": "fn(dateInterval: +NSDateInterval) -> number"
			},
			"intersectionWithDateInterval": {
				"!type": "fn(dateInterval: +NSDateInterval) -> +NSDateInterval"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSDateInterval"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetSegmentReportSampleInformation": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetSegmentReportSampleInformation"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetSegmentReportSampleInformation"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetSegmentReportSampleInformation"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"length": {
				"!type": "number"
			},
			"isSyncSample": {
				"!type": "bool"
			},
			"presentationTimeStamp": {
				"!type": "+Object"
			},
			"offset": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetSegmentReportSampleInformation"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioSessionPortDescription": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioSessionPortDescription"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioSessionPortDescription"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioSessionPortDescription"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"dataSources": {
				"!type": "+Array"
			},
			"preferredDataSource": {
				"!type": "+AVAudioSessionDataSourceDescription"
			},
			"channels": {
				"!type": "+Array"
			},
			"hasHardwareVoiceCallProcessing": {
				"!type": "bool"
			},
			"portName": {
				"!type": "string"
			},
			"portType": {
				"!type": "string"
			},
			"selectedDataSource": {
				"!type": "+AVAudioSessionDataSourceDescription"
			},
			"UID": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setPreferredDataSourceError": {
				"!type": "fn(dataSource: +AVAudioSessionDataSourceDescription, outError: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioSessionPortDescription"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUserDefaults": {
		"resetStandardUserDefaults": {
			"!type": "fn() -> void"
		},
		"standardUserDefaults": {
			"!type": "fn() -> +NSUserDefaults"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUserDefaults"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUserDefaults"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUserDefaults"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"volatileDomainNames": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"doubleForKey": {
				"!type": "fn(defaultName: string) -> number"
			},
			"volatileDomainForName": {
				"!type": "fn(domainName: string) -> +Object"
			},
			"setIntegerForKey": {
				"!type": "fn(value: number, defaultName: string) -> void"
			},
			"setDoubleForKey": {
				"!type": "fn(value: number, defaultName: string) -> void"
			},
			"setURLForKey": {
				"!type": "fn(url: +NSURL, defaultName: string) -> void"
			},
			"setBoolForKey": {
				"!type": "fn(value: bool, defaultName: string) -> void"
			},
			"setFloatForKey": {
				"!type": "fn(value: number, defaultName: string) -> void"
			},
			"stringArrayForKey": {
				"!type": "fn(defaultName: string) -> +Array"
			},
			"addSuiteNamed": {
				"!type": "fn(suiteName: string) -> void"
			},
			"URLForKey": {
				"!type": "fn(defaultName: string) -> +NSURL"
			},
			"setPersistentDomainForName": {
				"!type": "fn(domain: +Object, domainName: string) -> void"
			},
			"synchronize": {
				"!type": "fn() -> bool"
			},
			"initWithSuiteName": {
				"!type": "fn(suitename: string) -> +NSUserDefaults"
			},
			"jsinit": {
				"!type": "fn() -> +NSUserDefaults"
			},
			"initWithUser": {
				"!type": "fn(username: string) -> +Object"
			},
			"stringForKey": {
				"!type": "fn(defaultName: string) -> string"
			},
			"removeVolatileDomainForName": {
				"!type": "fn(domainName: string) -> void"
			},
			"integerForKey": {
				"!type": "fn(defaultName: string) -> number"
			},
			"setVolatileDomainForName": {
				"!type": "fn(domain: +Object, domainName: string) -> void"
			},
			"removeSuiteNamed": {
				"!type": "fn(suiteName: string) -> void"
			},
			"setObjectForKey": {
				"!type": "fn(value: +Object, defaultName: string) -> void"
			},
			"removePersistentDomainForName": {
				"!type": "fn(domainName: string) -> void"
			},
			"removeObjectForKey": {
				"!type": "fn(defaultName: string) -> void"
			},
			"dictionaryForKey": {
				"!type": "fn(defaultName: string) -> +Object"
			},
			"objectIsForcedForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"persistentDomainNames": {
				"!type": "fn() -> +Array"
			},
			"objectIsForcedForKeyInDomain": {
				"!type": "fn(key: string, domain: string) -> bool"
			},
			"boolForKey": {
				"!type": "fn(defaultName: string) -> bool"
			},
			"dictionaryRepresentation": {
				"!type": "fn() -> +Object"
			},
			"persistentDomainForName": {
				"!type": "fn(domainName: string) -> +Object"
			},
			"dataForKey": {
				"!type": "fn(defaultName: string) -> +NSData"
			},
			"registerDefaults": {
				"!type": "fn(registrationDictionary: +Object) -> void"
			},
			"arrayForKey": {
				"!type": "fn(defaultName: string) -> +Array"
			},
			"floatForKey": {
				"!type": "fn(defaultName: string) -> number"
			},
			"objectForKey": {
				"!type": "fn(defaultName: string) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUserDefaults"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnitComponentManager": {
		"sharedAudioUnitComponentManager": {
			"!type": "fn() -> +AVAudioUnitComponentManager"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnitComponentManager"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnitComponentManager"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnitComponentManager"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"tagNames": {
				"!type": "+Array"
			},
			"standardLocalizedTagNames": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"componentsMatchingDescription": {
				"!type": "fn(desc: +Object) -> +Array"
			},
			"componentsPassingTest": {
				"!type": "fn(testHandler: +Function) -> +Array"
			},
			"componentsMatchingPredicate": {
				"!type": "fn(predicate: +NSPredicate) -> +Array"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnitComponentManager"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AUAudioUnit": {
		"instantiateWithComponentDescriptionOptionsCompletionHandler": {
			"!type": "fn(componentDescription: +Object, options: number, completionHandler: +Function) -> void"
		},
		"registerSubclassAsComponentDescriptionNameVersion": {
			"!type": "fn(cls: +Object, componentDescription: +Object, name: string, version: number) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AUAudioUnit"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AUAudioUnit"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AUAudioUnit"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"factoryPresets": {
				"!type": "+Array"
			},
			"allParameterValues": {
				"!type": "bool"
			},
			"channelMap": {
				"!type": "+Array"
			},
			"fullState": {
				"!type": "+Object"
			},
			"providesUserInterface": {
				"!type": "bool"
			},
			"MIDIOutputBufferSizeHint": {
				"!type": "number"
			},
			"MIDIOutputNames": {
				"!type": "+Array"
			},
			"maximumFramesToRender": {
				"!type": "number"
			},
			"renderingOffline": {
				"!type": "bool"
			},
			"musicDeviceOrEffect": {
				"!type": "bool"
			},
			"jsinternalRenderBlock": {
				"!type": "+Function"
			},
			"fullStateForDocument": {
				"!type": "+Object"
			},
			"latency": {
				"!type": "number"
			},
			"jsinputHandler": {
				"!type": "+Function"
			},
			"componentDescription": {
				"!type": "+Object"
			},
			"supportsMPE": {
				"!type": "bool"
			},
			"supportsUserPresets": {
				"!type": "bool"
			},
			"componentVersion": {
				"!type": "number"
			},
			"channelCapabilities": {
				"!type": "+Array"
			},
			"jsscheduleParameterBlock": {
				"!type": "+Function"
			},
			"jsMIDIOutputEventBlock": {
				"!type": "+Function"
			},
			"jsmusicalContextBlock": {
				"!type": "+Function"
			},
			"inputBusses": {
				"!type": "+AUAudioUnitBusArray"
			},
			"parameterTree": {
				"!type": "+AUParameterTree"
			},
			"jsrenderContextObserver": {
				"!type": "+Function"
			},
			"contextName": {
				"!type": "string"
			},
			"componentName": {
				"!type": "string"
			},
			"currentPreset": {
				"!type": "+AUAudioUnitPreset"
			},
			"component": {
				"!type": "+Object"
			},
			"renderResourcesAllocated": {
				"!type": "bool"
			},
			"jsrenderBlock": {
				"!type": "+Function"
			},
			"running": {
				"!type": "bool"
			},
			"shouldBypassEffect": {
				"!type": "bool"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"userPresets": {
				"!type": "+Array"
			},
			"audioUnitName": {
				"!type": "string"
			},
			"jstransportStateBlock": {
				"!type": "+Function"
			},
			"canProcessInPlace": {
				"!type": "bool"
			},
			"audioUnitShortName": {
				"!type": "string"
			},
			"outputBusses": {
				"!type": "+AUAudioUnitBusArray"
			},
			"virtualMIDICableCount": {
				"!type": "number"
			},
			"canPerformInput": {
				"!type": "bool"
			},
			"tailTime": {
				"!type": "number"
			},
			"inputEnabled": {
				"!type": "bool"
			},
			"jsoutputProvider": {
				"!type": "+Function"
			},
			"jsprofileChangedBlock": {
				"!type": "+Function"
			},
			"canPerformOutput": {
				"!type": "bool"
			},
			"renderQuality": {
				"!type": "number"
			},
			"jsscheduleMIDIEventBlock": {
				"!type": "+Function"
			},
			"outputEnabled": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"allocateRenderResourcesAndReturnError": {
				"!type": "fn(outError: +Object) -> bool"
			},
			"setRenderResourcesAllocated": {
				"!type": "fn(flag: bool) -> void"
			},
			"removeRenderObserver": {
				"!type": "fn(token: number) -> void"
			},
			"profileStateForCableChannel": {
				"!type": "fn(cable: number, channel: number) -> +MIDICIProfileState"
			},
			"tokenByAddingRenderObserver": {
				"!type": "fn(observer: +Function) -> number"
			},
			"initWithComponentDescriptionError": {
				"!type": "fn(componentDescription: +Object, outError: +Object) -> +AUAudioUnit"
			},
			"deallocateRenderResources": {
				"!type": "fn() -> void"
			},
			"parametersForOverviewWithCount": {
				"!type": "fn(count: number) -> +Array"
			},
			"disableProfileCableOnChannelError": {
				"!type": "fn(profile: +MIDICIProfile, cable: number, channel: number, outError: +Object) -> bool"
			},
			"shouldChangeToFormatForBus": {
				"!type": "fn(format: +AVAudioFormat, bus: +AUAudioUnitBus) -> bool"
			},
			"initWithComponentDescriptionOptionsError": {
				"!type": "fn(componentDescription: +Object, options: number, outError: +Object) -> +AUAudioUnit"
			},
			"deleteUserPresetError": {
				"!type": "fn(userPreset: +AUAudioUnitPreset, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"startHardwareAndReturnError": {
				"!type": "fn(outError: +Object) -> bool"
			},
			"stopHardware": {
				"!type": "fn() -> void"
			},
			"presetStateForError": {
				"!type": "fn(userPreset: +AUAudioUnitPreset, outError: +Object) -> +Object"
			},
			"saveUserPresetError": {
				"!type": "fn(userPreset: +AUAudioUnitPreset, outError: +Object) -> bool"
			},
			"enableProfileCableOnChannelError": {
				"!type": "fn(profile: +MIDICIProfile, cable: number, channel: number, outError: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AUAudioUnit"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioEnvironmentNode": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioEnvironmentNode"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioEnvironmentNode"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioEnvironmentNode"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"outputVolume": {
				"!type": "number"
			},
			"reverbParameters": {
				"!type": "+AVAudioEnvironmentReverbParameters"
			},
			"listenerPosition": {
				"!type": "+Object"
			},
			"outputType": {
				"!type": "number"
			},
			"distanceAttenuationParameters": {
				"!type": "+AVAudioEnvironmentDistanceAttenuationParameters"
			},
			"nextAvailableInputBus": {
				"!type": "number"
			},
			"listenerVectorOrientation": {
				"!type": "+Object"
			},
			"listenerAngularOrientation": {
				"!type": "+Object"
			},
			"applicableRenderingAlgorithms": {
				"!type": "+Array"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioEnvironmentNode"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioEnvironmentNode"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSObject": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSObject"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSObject"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSObject"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSObject"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSThread": {
		"setThreadPriority": {
			"!type": "fn(p: number) -> bool"
		},
		"sleepForTimeInterval": {
			"!type": "fn(ti: number) -> void"
		},
		"detachNewThreadWithBlock": {
			"!type": "fn(block: +Function) -> void"
		},
		"currentThread": {
			"!type": "fn() -> +NSThread"
		},
		"isMainThread": {
			"!type": "fn() -> bool"
		},
		"mainThread": {
			"!type": "fn() -> +NSThread"
		},
		"sleepUntilDate": {
			"!type": "fn(date: +Date) -> void"
		},
		"detachNewThreadSelectorToTargetWithObject": {
			"!type": "fn(selector: string, target: +Object, argument: +Object) -> void"
		},
		"callStackReturnAddresses": {
			"!type": "fn() -> +Array"
		},
		"exit": {
			"!type": "fn() -> void"
		},
		"threadPriority": {
			"!type": "fn() -> number"
		},
		"callStackSymbols": {
			"!type": "fn() -> +Array"
		},
		"isMultiThreaded": {
			"!type": "fn() -> bool"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSThread"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSThread"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSThread"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"name": {
				"!type": "string"
			},
			"isMainThread": {
				"!type": "bool"
			},
			"qualityOfService": {
				"!type": "number"
			},
			"executing": {
				"!type": "bool"
			},
			"finished": {
				"!type": "bool"
			},
			"threadPriority": {
				"!type": "number"
			},
			"cancelled": {
				"!type": "bool"
			},
			"stackSize": {
				"!type": "number"
			},
			"threadDictionary": {
				"!type": "+NSMutableDictionary"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithTargetSelectorObject": {
				"!type": "fn(target: +Object, selector: string, argument: +Object) -> +NSThread"
			},
			"initWithBlock": {
				"!type": "fn(block: +Function) -> +NSThread"
			},
			"start": {
				"!type": "fn() -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSThread"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"main": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSThread"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLQueryItem": {
		"queryItemWithNameValue": {
			"!type": "fn(name: string, value: string) -> +NSURLQueryItem"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLQueryItem"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLQueryItem"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLQueryItem"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"name": {
				"!type": "string"
			},
			"value": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithNameValue": {
				"!type": "fn(name: string, value: string) -> +NSURLQueryItem"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLQueryItem"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMetadataBodyObject": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMetadataBodyObject"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMetadataBodyObject"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMetadataBodyObject"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"bodyID": {
				"!type": "number"
			},
			"duration": {
				"!type": "+Object"
			},
			"type": {
				"!type": "string"
			},
			"bounds": {
				"!type": "+Object"
			},
			"time": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMetadataBodyObject"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioIONode": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioIONode"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioIONode"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioIONode"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"voiceProcessingEnabled": {
				"!type": "bool"
			},
			"presentationLatency": {
				"!type": "number"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setVoiceProcessingEnabledError": {
				"!type": "fn(enabled: bool, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioIONode"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CAAnimationGroup": {
		"defaultValueForKey": {
			"!type": "fn(key: string) -> +Object"
		},
		"animation": {
			"!type": "fn() -> +CAAnimationGroup"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CAAnimationGroup"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CAAnimationGroup"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CAAnimationGroup"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"animations": {
				"!type": "+Array"
			},
			"timingFunction": {
				"!type": "+CAMediaTimingFunction"
			},
			"delegate": {
				"!type": "+Object"
			},
			"removedOnCompletion": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"shouldArchiveValueForKey": {
				"!type": "fn(key: string) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CAAnimationGroup"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioUnitTimeEffect": {
		"instantiateWithComponentDescriptionOptionsCompletionHandler": {
			"!type": "fn(audioComponentDescription: +Object, options: number, completionHandler: +Function) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioUnitTimeEffect"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioUnitTimeEffect"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioUnitTimeEffect"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"bypass": {
				"!type": "bool"
			},
			"name": {
				"!type": "string"
			},
			"audioComponentDescription": {
				"!type": "+Object"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"version": {
				"!type": "number"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"audioUnit": {
				"!type": "+Object"
			},
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithAudioComponentDescription": {
				"!type": "fn(audioComponentDescription: +Object) -> +AVAudioUnitTimeEffect"
			},
			"loadAudioUnitPresetAtURLError": {
				"!type": "fn(url: +NSURL, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioUnitTimeEffect"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AUAudioUnitV2Bridge": {
		"instantiateWithComponentDescriptionOptionsCompletionHandler": {
			"!type": "fn(componentDescription: +Object, options: number, completionHandler: +Function) -> void"
		},
		"registerSubclassAsComponentDescriptionNameVersion": {
			"!type": "fn(cls: +Object, componentDescription: +Object, name: string, version: number) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AUAudioUnitV2Bridge"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AUAudioUnitV2Bridge"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AUAudioUnitV2Bridge"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"factoryPresets": {
				"!type": "+Array"
			},
			"allParameterValues": {
				"!type": "bool"
			},
			"channelMap": {
				"!type": "+Array"
			},
			"fullState": {
				"!type": "+Object"
			},
			"providesUserInterface": {
				"!type": "bool"
			},
			"MIDIOutputBufferSizeHint": {
				"!type": "number"
			},
			"MIDIOutputNames": {
				"!type": "+Array"
			},
			"maximumFramesToRender": {
				"!type": "number"
			},
			"renderingOffline": {
				"!type": "bool"
			},
			"musicDeviceOrEffect": {
				"!type": "bool"
			},
			"jsinternalRenderBlock": {
				"!type": "+Function"
			},
			"fullStateForDocument": {
				"!type": "+Object"
			},
			"latency": {
				"!type": "number"
			},
			"jsinputHandler": {
				"!type": "+Function"
			},
			"componentDescription": {
				"!type": "+Object"
			},
			"supportsMPE": {
				"!type": "bool"
			},
			"supportsUserPresets": {
				"!type": "bool"
			},
			"componentVersion": {
				"!type": "number"
			},
			"channelCapabilities": {
				"!type": "+Array"
			},
			"jsscheduleParameterBlock": {
				"!type": "+Function"
			},
			"jsMIDIOutputEventBlock": {
				"!type": "+Function"
			},
			"jsmusicalContextBlock": {
				"!type": "+Function"
			},
			"inputBusses": {
				"!type": "+AUAudioUnitBusArray"
			},
			"parameterTree": {
				"!type": "+AUParameterTree"
			},
			"jsrenderContextObserver": {
				"!type": "+Function"
			},
			"contextName": {
				"!type": "string"
			},
			"componentName": {
				"!type": "string"
			},
			"currentPreset": {
				"!type": "+AUAudioUnitPreset"
			},
			"component": {
				"!type": "+Object"
			},
			"renderResourcesAllocated": {
				"!type": "bool"
			},
			"jsrenderBlock": {
				"!type": "+Function"
			},
			"running": {
				"!type": "bool"
			},
			"shouldBypassEffect": {
				"!type": "bool"
			},
			"manufacturerName": {
				"!type": "string"
			},
			"userPresets": {
				"!type": "+Array"
			},
			"audioUnitName": {
				"!type": "string"
			},
			"jstransportStateBlock": {
				"!type": "+Function"
			},
			"canProcessInPlace": {
				"!type": "bool"
			},
			"audioUnitShortName": {
				"!type": "string"
			},
			"outputBusses": {
				"!type": "+AUAudioUnitBusArray"
			},
			"virtualMIDICableCount": {
				"!type": "number"
			},
			"canPerformInput": {
				"!type": "bool"
			},
			"tailTime": {
				"!type": "number"
			},
			"inputEnabled": {
				"!type": "bool"
			},
			"jsoutputProvider": {
				"!type": "+Function"
			},
			"jsprofileChangedBlock": {
				"!type": "+Function"
			},
			"canPerformOutput": {
				"!type": "bool"
			},
			"renderQuality": {
				"!type": "number"
			},
			"jsscheduleMIDIEventBlock": {
				"!type": "+Function"
			},
			"outputEnabled": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"allocateRenderResourcesAndReturnError": {
				"!type": "fn(outError: +Object) -> bool"
			},
			"setRenderResourcesAllocated": {
				"!type": "fn(flag: bool) -> void"
			},
			"removeRenderObserver": {
				"!type": "fn(token: number) -> void"
			},
			"profileStateForCableChannel": {
				"!type": "fn(cable: number, channel: number) -> +MIDICIProfileState"
			},
			"tokenByAddingRenderObserver": {
				"!type": "fn(observer: +Function) -> number"
			},
			"initWithComponentDescriptionError": {
				"!type": "fn(componentDescription: +Object, outError: +Object) -> +AUAudioUnitV2Bridge"
			},
			"deallocateRenderResources": {
				"!type": "fn() -> void"
			},
			"parametersForOverviewWithCount": {
				"!type": "fn(count: number) -> +Array"
			},
			"disableProfileCableOnChannelError": {
				"!type": "fn(profile: +MIDICIProfile, cable: number, channel: number, outError: +Object) -> bool"
			},
			"shouldChangeToFormatForBus": {
				"!type": "fn(format: +AVAudioFormat, bus: +AUAudioUnitBus) -> bool"
			},
			"initWithComponentDescriptionOptionsError": {
				"!type": "fn(componentDescription: +Object, options: number, outError: +Object) -> +AUAudioUnitV2Bridge"
			},
			"deleteUserPresetError": {
				"!type": "fn(userPreset: +AUAudioUnitPreset, outError: +Object) -> bool"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"startHardwareAndReturnError": {
				"!type": "fn(outError: +Object) -> bool"
			},
			"stopHardware": {
				"!type": "fn() -> void"
			},
			"presetStateForError": {
				"!type": "fn(userPreset: +AUAudioUnitPreset, outError: +Object) -> +Object"
			},
			"saveUserPresetError": {
				"!type": "fn(userPreset: +AUAudioUnitPreset, outError: +Object) -> bool"
			},
			"enableProfileCableOnChannelError": {
				"!type": "fn(profile: +MIDICIProfile, cable: number, channel: number, outError: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AUAudioUnitV2Bridge"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSError": {
		"errorWithDomainCodeUserInfo": {
			"!type": "fn(domain: string, code: number, dict: +Object) -> +NSError"
		},
		"setUserInfoValueProviderForDomainProvider": {
			"!type": "fn(errorDomain: string, provider: +Function) -> void"
		},
		"userInfoValueProviderForDomain": {
			"!type": "fn(errorDomain: string) -> +Function"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSError"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSError"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSError"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"recoveryAttempter": {
				"!type": "+Object"
			},
			"domain": {
				"!type": "string"
			},
			"code": {
				"!type": "number"
			},
			"localizedDescription": {
				"!type": "string"
			},
			"localizedFailureReason": {
				"!type": "string"
			},
			"localizedRecoveryOptions": {
				"!type": "+Array"
			},
			"helpAnchor": {
				"!type": "string"
			},
			"localizedRecoverySuggestion": {
				"!type": "string"
			},
			"userInfo": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithDomainCodeUserInfo": {
				"!type": "fn(domain: string, code: number, dict: +Object) -> +NSError"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSError"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMutableDateRangeMetadataGroup": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMutableDateRangeMetadataGroup"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMutableDateRangeMetadataGroup"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMutableDateRangeMetadataGroup"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"startDate": {
				"!type": "+Date"
			},
			"endDate": {
				"!type": "+Date"
			},
			"items": {
				"!type": "+Array"
			},
			"startDate": {
				"!type": "+Date"
			},
			"endDate": {
				"!type": "+Date"
			},
			"items": {
				"!type": "+Array"
			},
			"items": {
				"!type": "+Array"
			},
			"classifyingLabel": {
				"!type": "string"
			},
			"uniqueID": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithItemsStartDateEndDate": {
				"!type": "fn(items: +Array, startDate: +Date, endDate: +Date) -> +AVMutableDateRangeMetadataGroup"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMutableDateRangeMetadataGroup"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerItemAccessLog": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerItemAccessLog"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerItemAccessLog"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerItemAccessLog"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"extendedLogDataStringEncoding": {
				"!type": "number"
			},
			"events": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"extendedLogData": {
				"!type": "fn() -> +NSData"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerItemAccessLog"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSAutoreleasePool": {
		"addObject": {
			"!type": "fn(anObject: +Object) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSAutoreleasePool"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSAutoreleasePool"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSAutoreleasePool"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"addObject": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"drain": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSAutoreleasePool"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureSynchronizedData": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureSynchronizedData"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureSynchronizedData"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureSynchronizedData"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"timestamp": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureSynchronizedData"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerItemTrack": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerItemTrack"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerItemTrack"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerItemTrack"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"currentVideoFrameRate": {
				"!type": "number"
			},
			"enabled": {
				"!type": "bool"
			},
			"assetTrack": {
				"!type": "+AVAssetTrack"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerItemTrack"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVSpeechSynthesisVoice": {
		"voiceWithIdentifier": {
			"!type": "fn(identifier: string) -> +AVSpeechSynthesisVoice"
		},
		"voiceWithLanguage": {
			"!type": "fn(languageCode: string) -> +AVSpeechSynthesisVoice"
		},
		"currentLanguageCode": {
			"!type": "fn() -> string"
		},
		"speechVoices": {
			"!type": "fn() -> +Array"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVSpeechSynthesisVoice"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVSpeechSynthesisVoice"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVSpeechSynthesisVoice"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"name": {
				"!type": "string"
			},
			"language": {
				"!type": "string"
			},
			"gender": {
				"!type": "number"
			},
			"audioFileSettings": {
				"!type": "+Object"
			},
			"identifier": {
				"!type": "string"
			},
			"quality": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVSpeechSynthesisVoice"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVVideoCompositionLayerInstruction": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVVideoCompositionLayerInstruction"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVVideoCompositionLayerInstruction"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVVideoCompositionLayerInstruction"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"trackID": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"getTransformRampForTimeStartTransformEndTransformTimeRange": {
				"!type": "fn(time: +Object, startTransform: +Object, endTransform: +Object, timeRange: +Object) -> bool"
			},
			"getCropRectangleRampForTimeStartCropRectangleEndCropRectangleTimeRange": {
				"!type": "fn(time: +Object, startCropRectangle: +Object, endCropRectangle: +Object, timeRange: +Object) -> bool"
			},
			"getOpacityRampForTimeStartOpacityEndOpacityTimeRange": {
				"!type": "fn(time: +Object, startOpacity: +Object, endOpacity: +Object, timeRange: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVVideoCompositionLayerInstruction"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetTrackGroup": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetTrackGroup"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetTrackGroup"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetTrackGroup"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"trackIDs": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetTrackGroup"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureFileOutput": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureFileOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureFileOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureFileOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"maxRecordedFileSize": {
				"!type": "number"
			},
			"recordedFileSize": {
				"!type": "number"
			},
			"outputFileURL": {
				"!type": "+NSURL"
			},
			"recordedDuration": {
				"!type": "+Object"
			},
			"minFreeDiskSpaceLimit": {
				"!type": "number"
			},
			"recording": {
				"!type": "bool"
			},
			"maxRecordedDuration": {
				"!type": "+Object"
			},
			"connections": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"stopRecording": {
				"!type": "fn() -> void"
			},
			"startRecordingToOutputFileURLRecordingDelegate": {
				"!type": "fn(outputFileURL: +NSURL, delegate: +Object) -> void"
			},
			"metadataOutputRectOfInterestForRect": {
				"!type": "fn(rectInOutputCoordinates: +Object) -> +Object"
			},
			"transformedMetadataObjectForMetadataObjectConnection": {
				"!type": "fn(metadataObject: +AVMetadataObject, connection: +AVCaptureConnection) -> +AVMetadataObject"
			},
			"rectForMetadataOutputRectOfInterest": {
				"!type": "fn(rectInMetadataOutputCoordinates: +Object) -> +Object"
			},
			"connectionWithMediaType": {
				"!type": "fn(mediaType: string) -> +AVCaptureConnection"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureFileOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioMixingDestination": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioMixingDestination"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioMixingDestination"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioMixingDestination"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"connectionPoint": {
				"!type": "+AVAudioConnectionPoint"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioMixingDestination"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioSessionDataSourceDescription": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioSessionDataSourceDescription"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioSessionDataSourceDescription"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioSessionDataSourceDescription"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"dataSourceName": {
				"!type": "string"
			},
			"orientation": {
				"!type": "string"
			},
			"preferredPolarPattern": {
				"!type": "string"
			},
			"supportedPolarPatterns": {
				"!type": "+Array"
			},
			"dataSourceID": {
				"!type": "number"
			},
			"location": {
				"!type": "string"
			},
			"selectedPolarPattern": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setPreferredPolarPatternError": {
				"!type": "fn(pattern: string, outError: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioSessionDataSourceDescription"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioBuffer": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioBuffer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioBuffer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioBuffer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"format": {
				"!type": "+AVAudioFormat"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioBuffer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSArray": {
		"arrayWithContentsOfFile": {
			"!type": "fn(path: string) -> +Array"
		},
		"arrayWithObjects": {
			"!type": "fn(firstObj: +Object, args: Array.prototype) -> +Array"
		},
		"arrayWithContentsOfURLError": {
			"!type": "fn(url: +NSURL, error: +Object) -> +Array"
		},
		"arrayWithObjectsCount": {
			"!type": "fn(objects: +Object, cnt: number) -> +Array"
		},
		"arrayWithObject": {
			"!type": "fn(anObject: +Object) -> +Array"
		},
		"arrayWithContentsOfURL": {
			"!type": "fn(url: +NSURL) -> +Array"
		},
		"array": {
			"!type": "fn() -> +Array"
		},
		"arrayWithArray": {
			"!type": "fn(array: +Array) -> +Array"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +Array"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +Array"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +Array"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"count": {
				"!type": "number"
			},
			"firstObject": {
				"!type": "+Object"
			},
			"description": {
				"!type": "string"
			},
			"sortedArrayHint": {
				"!type": "+NSData"
			},
			"lastObject": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"filteredArrayUsingPredicate": {
				"!type": "fn(predicate: +NSPredicate) -> +Array"
			},
			"initWithObjectsCount": {
				"!type": "fn(objects: +Object, cnt: number) -> +Array"
			},
			"sortedArrayUsingFunctionContext": {
				"!type": "fn(comparator: +Object, context: +Object) -> +Array"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"sortedArrayUsingComparator": {
				"!type": "fn(cmptr: +Function) -> +Array"
			},
			"sortedArrayUsingDescriptors": {
				"!type": "fn(sortDescriptors: +Array) -> +Array"
			},
			"removeObserverFromObjectsAtIndexesForKeyPathContext": {
				"!type": "fn(observer: +NSObject, indexes: +NSIndexSet, keyPath: string, context: +Object) -> void"
			},
			"indexesOfObjectsWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> +NSIndexSet"
			},
			"containsObject": {
				"!type": "fn(anObject: +Object) -> bool"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"componentsJoinedByString": {
				"!type": "fn(separator: string) -> string"
			},
			"arrayByAddingObjectsFromArray": {
				"!type": "fn(otherArray: +Array) -> +Array"
			},
			"arrayByApplyingDifference": {
				"!type": "fn(difference: +NSOrderedCollectionDifference) -> +Array"
			},
			"initWithContentsOfURLError": {
				"!type": "fn(url: +NSURL, error: +Object) -> +Array"
			},
			"initWithContentsOfFile": {
				"!type": "fn(path: string) -> +Array"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"arrayByAddingObject": {
				"!type": "fn(anObject: +Object) -> +Array"
			},
			"initWithArrayCopyItems": {
				"!type": "fn(array: +Array, flag: bool) -> +Array"
			},
			"reverseObjectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"indexOfObjectIdenticalTo": {
				"!type": "fn(anObject: +Object) -> number"
			},
			"enumerateObjectsUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"sortedArrayWithOptionsUsingComparator": {
				"!type": "fn(opts: number, cmptr: +Function) -> +Array"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"sortedArrayUsingFunctionContextHint": {
				"!type": "fn(comparator: +Object, context: +Object, hint: +NSData) -> +Array"
			},
			"objectAtIndexedSubscript": {
				"!type": "fn(idx: number) -> +Object"
			},
			"writeToURLAtomically": {
				"!type": "fn(url: +NSURL, atomically: bool) -> bool"
			},
			"jsinit": {
				"!type": "fn() -> +Array"
			},
			"addObserverToObjectsAtIndexesForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, indexes: +NSIndexSet, keyPath: string, options: number, context: +Object) -> void"
			},
			"enumerateObjectsWithOptionsUsingBlock": {
				"!type": "fn(opts: number, block: +Function) -> void"
			},
			"isEqualToArray": {
				"!type": "fn(otherArray: +Array) -> bool"
			},
			"firstObjectCommonWithArray": {
				"!type": "fn(otherArray: +Array) -> +Object"
			},
			"indexOfObjectInSortedRangeOptionsUsingComparator": {
				"!type": "fn(obj: +Object, r: +Object, opts: number, cmp: +Function) -> number"
			},
			"objectsAtIndexes": {
				"!type": "fn(indexes: +NSIndexSet) -> +Array"
			},
			"initWithArray": {
				"!type": "fn(array: +Array) -> +Array"
			},
			"indexOfObjectWithOptionsPassingTest": {
				"!type": "fn(opts: number, predicate: +Function) -> number"
			},
			"enumerateObjectsAtIndexesOptionsUsingBlock": {
				"!type": "fn(s: +NSIndexSet, opts: number, block: +Function) -> void"
			},
			"indexesOfObjectsPassingTest": {
				"!type": "fn(predicate: +Function) -> +NSIndexSet"
			},
			"differenceFromArray": {
				"!type": "fn(other: +Array) -> +NSOrderedCollectionDifference"
			},
			"descriptionWithLocale": {
				"!type": "fn(locale: +Object) -> string"
			},
			"indexOfObjectPassingTest": {
				"!type": "fn(predicate: +Function) -> number"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +Array"
			},
			"indexesOfObjectsAtIndexesOptionsPassingTest": {
				"!type": "fn(s: +NSIndexSet, opts: number, predicate: +Function) -> +NSIndexSet"
			},
			"initWithContentsOfURL": {
				"!type": "fn(url: +NSURL) -> +Array"
			},
			"makeObjectsPerformSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"initWithObjects": {
				"!type": "fn(firstObj: +Object, args: Array.prototype) -> +Array"
			},
			"writeToURLError": {
				"!type": "fn(url: +NSURL, error: +Object) -> bool"
			},
			"objectEnumerator": {
				"!type": "fn() -> +NSEnumerator"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"getObjects": {
				"!type": "fn(objects: +Object) -> void"
			},
			"differenceFromArrayWithOptions": {
				"!type": "fn(other: +Array, options: number) -> +NSOrderedCollectionDifference"
			},
			"indexOfObjectInRange": {
				"!type": "fn(anObject: +Object, range: +Object) -> number"
			},
			"objectAtIndex": {
				"!type": "fn(index: number) -> +Object"
			},
			"indexOfObject": {
				"!type": "fn(anObject: +Object) -> number"
			},
			"subarrayWithRange": {
				"!type": "fn(range: +Object) -> +Array"
			},
			"indexOfObjectAtIndexesOptionsPassingTest": {
				"!type": "fn(s: +NSIndexSet, opts: number, predicate: +Function) -> number"
			},
			"sortedArrayUsingSelector": {
				"!type": "fn(comparator: string) -> +Array"
			},
			"indexOfObjectIdenticalToInRange": {
				"!type": "fn(anObject: +Object, range: +Object) -> number"
			},
			"pathsMatchingExtensions": {
				"!type": "fn(filterTypes: +Array) -> +Array"
			},
			"writeToFileAtomically": {
				"!type": "fn(path: string, useAuxiliaryFile: bool) -> bool"
			},
			"descriptionWithLocaleIndent": {
				"!type": "fn(locale: +Object, level: number) -> string"
			},
			"differenceFromArrayWithOptionsUsingEquivalenceTest": {
				"!type": "fn(other: +Array, options: number, block: +Function) -> +NSOrderedCollectionDifference"
			},
			"getObjectsRange": {
				"!type": "fn(objects: +Object, range: +Object) -> void"
			},
			"removeObserverFromObjectsAtIndexesForKeyPath": {
				"!type": "fn(observer: +NSObject, indexes: +NSIndexSet, keyPath: string) -> void"
			},
			"makeObjectsPerformSelectorWithObject": {
				"!type": "fn(aSelector: string, argument: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +Array"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSFileManager": {
		"defaultManager": {
			"!type": "fn() -> +NSFileManager"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSFileManager"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSFileManager"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSFileManager"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"ubiquityIdentityToken": {
				"!type": "+Object"
			},
			"currentDirectoryPath": {
				"!type": "string"
			},
			"delegate": {
				"!type": "+Object"
			},
			"temporaryDirectory": {
				"!type": "+NSURL"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"contentsOfDirectoryAtPathError": {
				"!type": "fn(path: string, error: +Object) -> +Array"
			},
			"isWritableFileAtPath": {
				"!type": "fn(path: string) -> bool"
			},
			"attributesOfItemAtPathError": {
				"!type": "fn(path: string, error: +Object) -> +Object"
			},
			"fileAttributesAtPathTraverseLink": {
				"!type": "fn(path: string, yorn: bool) -> +Object"
			},
			"removeItemAtPathError": {
				"!type": "fn(path: string, error: +Object) -> bool"
			},
			"URLsForDirectoryInDomains": {
				"!type": "fn(directory: number, domainMask: number) -> +Array"
			},
			"createDirectoryAtURLWithIntermediateDirectoriesAttributesError": {
				"!type": "fn(url: +NSURL, createIntermediates: bool, attributes: +Object, error: +Object) -> bool"
			},
			"mountedVolumeURLsIncludingResourceValuesForKeysOptions": {
				"!type": "fn(propertyKeys: +Array, options: number) -> +Array"
			},
			"displayNameAtPath": {
				"!type": "fn(path: string) -> string"
			},
			"createSymbolicLinkAtPathWithDestinationPathError": {
				"!type": "fn(path: string, destPath: string, error: +Object) -> bool"
			},
			"enumeratorAtURLIncludingPropertiesForKeysOptionsErrorHandler": {
				"!type": "fn(url: +NSURL, keys: +Array, mask: number, handler: +Function) -> +NSDirectoryEnumerator"
			},
			"URLForPublishingUbiquitousItemAtURLExpirationDateError": {
				"!type": "fn(url: +NSURL, outDate: +Object, error: +Object) -> +NSURL"
			},
			"destinationOfSymbolicLinkAtPathError": {
				"!type": "fn(path: string, error: +Object) -> string"
			},
			"containerURLForSecurityApplicationGroupIdentifier": {
				"!type": "fn(groupIdentifier: string) -> +NSURL"
			},
			"linkItemAtURLToURLError": {
				"!type": "fn(srcURL: +NSURL, dstURL: +NSURL, error: +Object) -> bool"
			},
			"URLForUbiquityContainerIdentifier": {
				"!type": "fn(containerIdentifier: string) -> +NSURL"
			},
			"linkItemAtPathToPathError": {
				"!type": "fn(srcPath: string, dstPath: string, error: +Object) -> bool"
			},
			"setAttributesOfItemAtPathError": {
				"!type": "fn(attributes: +Object, path: string, error: +Object) -> bool"
			},
			"trashItemAtURLResultingItemURLError": {
				"!type": "fn(url: +NSURL, outResultingURL: +Object, error: +Object) -> bool"
			},
			"isUbiquitousItemAtURL": {
				"!type": "fn(url: +NSURL) -> bool"
			},
			"copyItemAtURLToURLError": {
				"!type": "fn(srcURL: +NSURL, dstURL: +NSURL, error: +Object) -> bool"
			},
			"pathContentOfSymbolicLinkAtPath": {
				"!type": "fn(path: string) -> string"
			},
			"moveItemAtPathToPathError": {
				"!type": "fn(srcPath: string, dstPath: string, error: +Object) -> bool"
			},
			"isReadableFileAtPath": {
				"!type": "fn(path: string) -> bool"
			},
			"getFileProviderServicesForItemAtURLCompletionHandler": {
				"!type": "fn(url: +NSURL, completionHandler: +Function) -> void"
			},
			"contentsOfDirectoryAtURLIncludingPropertiesForKeysOptionsError": {
				"!type": "fn(url: +NSURL, keys: +Array, mask: number, error: +Object) -> +Array"
			},
			"changeCurrentDirectoryPath": {
				"!type": "fn(path: string) -> bool"
			},
			"stringWithFileSystemRepresentationLength": {
				"!type": "fn(str: +Object, len: number) -> string"
			},
			"fileSystemAttributesAtPath": {
				"!type": "fn(path: string) -> +Object"
			},
			"URLForDirectoryInDomainAppropriateForURLCreateError": {
				"!type": "fn(directory: number, domain: number, url: +NSURL, shouldCreate: bool, error: +Object) -> +NSURL"
			},
			"startDownloadingUbiquitousItemAtURLError": {
				"!type": "fn(url: +NSURL, error: +Object) -> bool"
			},
			"copyItemAtPathToPathError": {
				"!type": "fn(srcPath: string, dstPath: string, error: +Object) -> bool"
			},
			"evictUbiquitousItemAtURLError": {
				"!type": "fn(url: +NSURL, error: +Object) -> bool"
			},
			"subpathsAtPath": {
				"!type": "fn(path: string) -> +Array"
			},
			"createSymbolicLinkAtPathPathContent": {
				"!type": "fn(path: string, otherpath: string) -> bool"
			},
			"componentsToDisplayForPath": {
				"!type": "fn(path: string) -> +Array"
			},
			"setUbiquitousItemAtURLDestinationURLError": {
				"!type": "fn(flag: bool, url: +NSURL, destinationURL: +NSURL, error: +Object) -> bool"
			},
			"enumeratorAtPath": {
				"!type": "fn(path: string) -> +NSDirectoryEnumerator"
			},
			"isExecutableFileAtPath": {
				"!type": "fn(path: string) -> bool"
			},
			"fileExistsAtPathIsDirectory": {
				"!type": "fn(path: string, isDirectory: +Object) -> bool"
			},
			"changeFileAttributesAtPath": {
				"!type": "fn(attributes: +Object, path: string) -> bool"
			},
			"fileExistsAtPath": {
				"!type": "fn(path: string) -> bool"
			},
			"isDeletableFileAtPath": {
				"!type": "fn(path: string) -> bool"
			},
			"contentsAtPath": {
				"!type": "fn(path: string) -> +NSData"
			},
			"fileSystemRepresentationWithPath": {
				"!type": "fn(path: string) -> +Object"
			},
			"removeItemAtURLError": {
				"!type": "fn(URL: +NSURL, error: +Object) -> bool"
			},
			"moveItemAtURLToURLError": {
				"!type": "fn(srcURL: +NSURL, dstURL: +NSURL, error: +Object) -> bool"
			},
			"createDirectoryAtPathAttributes": {
				"!type": "fn(path: string, attributes: +Object) -> bool"
			},
			"directoryContentsAtPath": {
				"!type": "fn(path: string) -> +Array"
			},
			"getRelationshipOfDirectoryInDomainToItemAtURLError": {
				"!type": "fn(outRelationship: +Object, directory: number, domainMask: number, url: +NSURL, error: +Object) -> bool"
			},
			"attributesOfFileSystemForPathError": {
				"!type": "fn(path: string, error: +Object) -> +Object"
			},
			"createFileAtPathContentsAttributes": {
				"!type": "fn(path: string, data: +NSData, attr: +Object) -> bool"
			},
			"createSymbolicLinkAtURLWithDestinationURLError": {
				"!type": "fn(url: +NSURL, destURL: +NSURL, error: +Object) -> bool"
			},
			"subpathsOfDirectoryAtPathError": {
				"!type": "fn(path: string, error: +Object) -> +Array"
			},
			"createDirectoryAtPathWithIntermediateDirectoriesAttributesError": {
				"!type": "fn(path: string, createIntermediates: bool, attributes: +Object, error: +Object) -> bool"
			},
			"getRelationshipOfDirectoryAtURLToItemAtURLError": {
				"!type": "fn(outRelationship: +Object, directoryURL: +NSURL, otherURL: +NSURL, error: +Object) -> bool"
			},
			"replaceItemAtURLWithItemAtURLBackupItemNameOptionsResultingItemURLError": {
				"!type": "fn(originalItemURL: +NSURL, newItemURL: +NSURL, backupItemName: string, options: number, resultingURL: +Object, error: +Object) -> bool"
			},
			"contentsEqualAtPathAndPath": {
				"!type": "fn(path1: string, path2: string) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSFileManager"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMutableAudioMixInputParameters": {
		"audioMixInputParametersWithTrack": {
			"!type": "fn(track: +AVAssetTrack) -> +AVMutableAudioMixInputParameters"
		},
		"audioMixInputParameters": {
			"!type": "fn() -> +AVMutableAudioMixInputParameters"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMutableAudioMixInputParameters"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMutableAudioMixInputParameters"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMutableAudioMixInputParameters"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"trackID": {
				"!type": "number"
			},
			"audioTimePitchAlgorithm": {
				"!type": "string"
			},
			"audioTapProcessor": {
				"!type": "+Object"
			},
			"trackID": {
				"!type": "number"
			},
			"audioTimePitchAlgorithm": {
				"!type": "string"
			},
			"audioTapProcessor": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setVolumeRampFromStartVolumeToEndVolumeTimeRange": {
				"!type": "fn(startVolume: number, endVolume: number, timeRange: +Object) -> void"
			},
			"setVolumeAtTime": {
				"!type": "fn(volume: number, time: +Object) -> void"
			},
			"getVolumeRampForTimeStartVolumeEndVolumeTimeRange": {
				"!type": "fn(time: +Object, startVolume: +Object, endVolume: +Object, timeRange: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMutableAudioMixInputParameters"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitFrequency": {
		"megahertz": {
			"!type": "fn() -> +NSUnitFrequency"
		},
		"microhertz": {
			"!type": "fn() -> +NSUnitFrequency"
		},
		"hertz": {
			"!type": "fn() -> +NSUnitFrequency"
		},
		"terahertz": {
			"!type": "fn() -> +NSUnitFrequency"
		},
		"nanohertz": {
			"!type": "fn() -> +NSUnitFrequency"
		},
		"framesPerSecond": {
			"!type": "fn() -> +NSUnitFrequency"
		},
		"gigahertz": {
			"!type": "fn() -> +NSUnitFrequency"
		},
		"millihertz": {
			"!type": "fn() -> +NSUnitFrequency"
		},
		"kilohertz": {
			"!type": "fn() -> +NSUnitFrequency"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitFrequency"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitFrequency"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitFrequency"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitFrequency"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitFrequency"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitFrequency"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitFrequency"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVOutputSettingsAssistant": {
		"availableOutputSettingsPresets": {
			"!type": "fn() -> +Array"
		},
		"outputSettingsAssistantWithPreset": {
			"!type": "fn(presetIdentifier: string) -> +AVOutputSettingsAssistant"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVOutputSettingsAssistant"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVOutputSettingsAssistant"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVOutputSettingsAssistant"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"sourceAudioFormat": {
				"!type": "+Object"
			},
			"sourceVideoFormat": {
				"!type": "+Object"
			},
			"videoSettings": {
				"!type": "+Object"
			},
			"audioSettings": {
				"!type": "+Object"
			},
			"sourceVideoAverageFrameDuration": {
				"!type": "+Object"
			},
			"sourceVideoMinFrameDuration": {
				"!type": "+Object"
			},
			"outputFileType": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVOutputSettingsAssistant"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAssetResourceRenewalRequest": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAssetResourceRenewalRequest"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAssetResourceRenewalRequest"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAssetResourceRenewalRequest"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"redirect": {
				"!type": "+NSURLRequest"
			},
			"requestor": {
				"!type": "+AVAssetResourceLoadingRequestor"
			},
			"request": {
				"!type": "+NSURLRequest"
			},
			"dataRequest": {
				"!type": "+AVAssetResourceLoadingDataRequest"
			},
			"finished": {
				"!type": "bool"
			},
			"cancelled": {
				"!type": "bool"
			},
			"response": {
				"!type": "+NSURLResponse"
			},
			"contentInformationRequest": {
				"!type": "+AVAssetResourceLoadingContentInformationRequest"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"streamingContentKeyRequestDataForAppContentIdentifierOptionsError": {
				"!type": "fn(appIdentifier: +NSData, contentIdentifier: +NSData, options: +Object, outError: +Object) -> +NSData"
			},
			"finishLoadingWithError": {
				"!type": "fn(error: +NSError) -> void"
			},
			"finishLoadingWithResponseDataRedirect": {
				"!type": "fn(response: +NSURLResponse, data: +NSData, redirect: +NSURLRequest) -> void"
			},
			"persistentContentKeyFromKeyVendorResponseOptionsError": {
				"!type": "fn(keyVendorResponse: +NSData, options: +Object, outError: +Object) -> +NSData"
			},
			"finishLoading": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAssetResourceRenewalRequest"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSHTTPCookieStorage": {
		"sharedHTTPCookieStorage": {
			"!type": "fn() -> +NSHTTPCookieStorage"
		},
		"sharedCookieStorageForGroupContainerIdentifier": {
			"!type": "fn(identifier: string) -> +NSHTTPCookieStorage"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSHTTPCookieStorage"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSHTTPCookieStorage"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSHTTPCookieStorage"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"cookies": {
				"!type": "+Array"
			},
			"cookieAcceptPolicy": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"deleteCookie": {
				"!type": "fn(cookie: +NSHTTPCookie) -> void"
			},
			"storeCookiesForTask": {
				"!type": "fn(cookies: +Array, task: +NSURLSessionTask) -> void"
			},
			"setCookie": {
				"!type": "fn(cookie: +NSHTTPCookie) -> void"
			},
			"removeCookiesSinceDate": {
				"!type": "fn(date: +Date) -> void"
			},
			"sortedCookiesUsingDescriptors": {
				"!type": "fn(sortOrder: +Array) -> +Array"
			},
			"cookiesForURL": {
				"!type": "fn(URL: +NSURL) -> +Array"
			},
			"setCookiesForURLMainDocumentURL": {
				"!type": "fn(cookies: +Array, URL: +NSURL, mainDocumentURL: +NSURL) -> void"
			},
			"getCookiesForTaskCompletionHandler": {
				"!type": "fn(task: +NSURLSessionTask, completionHandler: +Function) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSHTTPCookieStorage"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSPointerFunctions": {
		"pointerFunctionsWithOptions": {
			"!type": "fn(options: number) -> +NSPointerFunctions"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSPointerFunctions"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSPointerFunctions"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSPointerFunctions"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"usesStrongWriteBarrier": {
				"!type": "bool"
			},
			"usesWeakReadAndWriteBarriers": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithOptions": {
				"!type": "fn(options: number) -> +NSPointerFunctions"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSPointerFunctions"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMediaSelectionOption": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMediaSelectionOption"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMediaSelectionOption"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMediaSelectionOption"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"displayName": {
				"!type": "string"
			},
			"locale": {
				"!type": "+NSLocale"
			},
			"extendedLanguageTag": {
				"!type": "string"
			},
			"mediaType": {
				"!type": "string"
			},
			"mediaSubTypes": {
				"!type": "+Array"
			},
			"playable": {
				"!type": "bool"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"hasMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> bool"
			},
			"propertyList": {
				"!type": "fn() -> +Object"
			},
			"associatedMediaSelectionOptionInMediaSelectionGroup": {
				"!type": "fn(mediaSelectionGroup: +AVMediaSelectionGroup) -> +AVMediaSelectionOption"
			},
			"displayNameWithLocale": {
				"!type": "fn(locale: +NSLocale) -> string"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMediaSelectionOption"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSRunLoop": {
		"mainRunLoop": {
			"!type": "fn() -> +NSRunLoop"
		},
		"currentRunLoop": {
			"!type": "fn() -> +NSRunLoop"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSRunLoop"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSRunLoop"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSRunLoop"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"currentMode": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"limitDateForMode": {
				"!type": "fn(mode: string) -> +Date"
			},
			"run": {
				"!type": "fn() -> void"
			},
			"performSelectorTargetArgumentOrderModes": {
				"!type": "fn(aSelector: string, target: +Object, arg: +Object, order: number, modes: +Array) -> void"
			},
			"runUntilDate": {
				"!type": "fn(limitDate: +Date) -> void"
			},
			"performBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"cancelPerformSelectorTargetArgument": {
				"!type": "fn(aSelector: string, target: +Object, arg: +Object) -> void"
			},
			"getCFRunLoop": {
				"!type": "fn() -> +Object"
			},
			"addTimerForMode": {
				"!type": "fn(timer: +NSTimer, mode: string) -> void"
			},
			"addPortForMode": {
				"!type": "fn(aPort: +NSPort, mode: string) -> void"
			},
			"acceptInputForModeBeforeDate": {
				"!type": "fn(mode: string, limitDate: +Date) -> void"
			},
			"runModeBeforeDate": {
				"!type": "fn(mode: string, limitDate: +Date) -> bool"
			},
			"removePortForMode": {
				"!type": "fn(aPort: +NSPort, mode: string) -> void"
			},
			"performInModesBlock": {
				"!type": "fn(modes: +Array, block: +Function) -> void"
			},
			"cancelPerformSelectorsWithTarget": {
				"!type": "fn(target: +Object) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSRunLoop"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSFileAccessIntent": {
		"writingIntentWithURLOptions": {
			"!type": "fn(url: +NSURL, options: number) -> +NSFileAccessIntent"
		},
		"readingIntentWithURLOptions": {
			"!type": "fn(url: +NSURL, options: number) -> +NSFileAccessIntent"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSFileAccessIntent"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSFileAccessIntent"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSFileAccessIntent"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"URL": {
				"!type": "+NSURL"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSFileAccessIntent"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSDateIntervalFormatter": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSDateIntervalFormatter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSDateIntervalFormatter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSDateIntervalFormatter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"timeStyle": {
				"!type": "number"
			},
			"locale": {
				"!type": "+NSLocale"
			},
			"dateStyle": {
				"!type": "number"
			},
			"dateTemplate": {
				"!type": "string"
			},
			"timeZone": {
				"!type": "+NSTimeZone"
			},
			"calendar": {
				"!type": "+NSCalendar"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"stringFromDateInterval": {
				"!type": "fn(dateInterval: +NSDateInterval) -> string"
			},
			"stringFromDateToDate": {
				"!type": "fn(fromDate: +Date, toDate: +Date) -> string"
			},
			"editingStringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription": {
				"!type": "fn(partialStringPtr: +Object, proposedSelRangePtr: +Object, origString: string, origSelRange: +Object, error: +Object) -> bool"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"attributedStringForObjectValueWithDefaultAttributes": {
				"!type": "fn(obj: +Object, attrs: +Object) -> +NSAttributedString"
			},
			"isPartialStringValidNewEditingStringErrorDescription": {
				"!type": "fn(partialString: string, newString: +Object, error: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSDateIntervalFormatter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMutableMovie": {
		"movieWithURLOptionsError": {
			"!type": "fn(URL: +NSURL, options: +Object, outError: +Object) -> +AVMutableMovie"
		},
		"movieWithDataOptionsError": {
			"!type": "fn(data: +NSData, options: +Object, outError: +Object) -> +AVMutableMovie"
		},
		"movieWithSettingsFromMovieOptionsError": {
			"!type": "fn(movie: +AVMovie, options: +Object, outError: +Object) -> +AVMutableMovie"
		},
		"movieWithDataOptions": {
			"!type": "fn(data: +NSData, options: +Object) -> +AVMutableMovie"
		},
		"movieWithURLOptions": {
			"!type": "fn(URL: +NSURL, options: +Object) -> +AVMutableMovie"
		},
		"movieTypes": {
			"!type": "fn() -> +Array"
		},
		"assetWithURL": {
			"!type": "fn(URL: +NSURL) -> +AVMutableMovie"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMutableMovie"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMutableMovie"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMutableMovie"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"preferredRate": {
				"!type": "number"
			},
			"tracks": {
				"!type": "+Array"
			},
			"interleavingPeriod": {
				"!type": "+Object"
			},
			"timescale": {
				"!type": "number"
			},
			"defaultMediaDataStorage": {
				"!type": "+AVMediaDataStorage"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"modified": {
				"!type": "bool"
			},
			"metadata": {
				"!type": "+Array"
			},
			"defaultMediaDataStorage": {
				"!type": "+AVMediaDataStorage"
			},
			"URL": {
				"!type": "+NSURL"
			},
			"containsMovieFragments": {
				"!type": "bool"
			},
			"tracks": {
				"!type": "+Array"
			},
			"data": {
				"!type": "+NSData"
			},
			"canContainMovieFragments": {
				"!type": "bool"
			},
			"creationDate": {
				"!type": "+AVMetadataItem"
			},
			"referenceRestrictions": {
				"!type": "number"
			},
			"canContainFragments": {
				"!type": "bool"
			},
			"preferredVolume": {
				"!type": "number"
			},
			"preferredRate": {
				"!type": "number"
			},
			"composable": {
				"!type": "bool"
			},
			"tracks": {
				"!type": "+Array"
			},
			"containsFragments": {
				"!type": "bool"
			},
			"availableMediaCharacteristicsWithMediaSelectionOptions": {
				"!type": "+Array"
			},
			"preferredMediaSelection": {
				"!type": "+AVMediaSelection"
			},
			"duration": {
				"!type": "+Object"
			},
			"providesPreciseDurationAndTiming": {
				"!type": "bool"
			},
			"compatibleWithAirPlayVideo": {
				"!type": "bool"
			},
			"commonMetadata": {
				"!type": "+Array"
			},
			"availableMetadataFormats": {
				"!type": "+Array"
			},
			"naturalSize": {
				"!type": "+Object"
			},
			"exportable": {
				"!type": "bool"
			},
			"lyrics": {
				"!type": "string"
			},
			"trackGroups": {
				"!type": "+Array"
			},
			"compatibleWithSavedPhotosAlbum": {
				"!type": "bool"
			},
			"readable": {
				"!type": "bool"
			},
			"hasProtectedContent": {
				"!type": "bool"
			},
			"overallDurationHint": {
				"!type": "+Object"
			},
			"availableChapterLocales": {
				"!type": "+Array"
			},
			"minimumTimeOffsetFromLive": {
				"!type": "+Object"
			},
			"allMediaSelections": {
				"!type": "+Array"
			},
			"playable": {
				"!type": "bool"
			},
			"preferredTransform": {
				"!type": "+Object"
			},
			"metadata": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVMutableMovieTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"mutableTrackCompatibleWithTrack": {
				"!type": "fn(track: +AVAssetTrack) -> +AVMutableMovieTrack"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"scaleTimeRangeToDuration": {
				"!type": "fn(timeRange: +Object, duration: +Object) -> void"
			},
			"initWithSettingsFromMovieOptionsError": {
				"!type": "fn(movie: +AVMovie, options: +Object, outError: +Object) -> +AVMutableMovie"
			},
			"addMutableTracksCopyingSettingsFromTracksOptions": {
				"!type": "fn(existingTracks: +Array, options: +Object) -> +Array"
			},
			"removeTrack": {
				"!type": "fn(track: +AVMovieTrack) -> void"
			},
			"insertEmptyTimeRange": {
				"!type": "fn(timeRange: +Object) -> void"
			},
			"removeTimeRange": {
				"!type": "fn(timeRange: +Object) -> void"
			},
			"addMutableTrackWithMediaTypeCopySettingsFromTrackOptions": {
				"!type": "fn(mediaType: string, track: +AVAssetTrack, options: +Object) -> +AVMutableMovieTrack"
			},
			"initWithURLOptionsError": {
				"!type": "fn(URL: +NSURL, options: +Object, outError: +Object) -> +AVMutableMovie"
			},
			"insertTimeRangeOfAssetAtTimeCopySampleDataError": {
				"!type": "fn(timeRange: +Object, asset: +AVAsset, startTime: +Object, copySampleData: bool, outError: +Object) -> bool"
			},
			"initWithDataOptionsError": {
				"!type": "fn(data: +NSData, options: +Object, outError: +Object) -> +AVMutableMovie"
			},
			"initWithURLOptions": {
				"!type": "fn(URL: +NSURL, options: +Object) -> +AVMutableMovie"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVMovieTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"initWithDataOptions": {
				"!type": "fn(data: +NSData, options: +Object) -> +AVMutableMovie"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"writeMovieHeaderToURLFileTypeOptionsError": {
				"!type": "fn(URL: +NSURL, fileType: string, options: number, outError: +Object) -> bool"
			},
			"movieHeaderWithFileTypeError": {
				"!type": "fn(fileType: string, outError: +Object) -> +NSData"
			},
			"isCompatibleWithFileType": {
				"!type": "fn(fileType: string) -> bool"
			},
			"unusedTrackID": {
				"!type": "fn() -> number"
			},
			"chapterMetadataGroupsWithTitleLocaleContainingItemsWithCommonKeys": {
				"!type": "fn(locale: +NSLocale, commonKeys: +Array) -> +Array"
			},
			"cancelLoading": {
				"!type": "fn() -> void"
			},
			"trackWithTrackID": {
				"!type": "fn(trackID: number) -> +AVAssetTrack"
			},
			"tracksWithMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +Array"
			},
			"metadataForFormat": {
				"!type": "fn(format: string) -> +Array"
			},
			"tracksWithMediaType": {
				"!type": "fn(mediaType: string) -> +Array"
			},
			"mediaSelectionGroupForMediaCharacteristic": {
				"!type": "fn(mediaCharacteristic: string) -> +AVMediaSelectionGroup"
			},
			"chapterMetadataGroupsBestMatchingPreferredLanguages": {
				"!type": "fn(preferredLanguages: +Array) -> +Array"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMutableMovie"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMutableData": {
		"dataWithLength": {
			"!type": "fn(length: number) -> +NSMutableData"
		},
		"dataWithCapacity": {
			"!type": "fn(aNumItems: number) -> +NSMutableData"
		},
		"dataWithContentsOfFile": {
			"!type": "fn(path: string) -> +NSMutableData"
		},
		"dataWithContentsOfMappedFile": {
			"!type": "fn(path: string) -> +Object"
		},
		"dataWithBytesNoCopyLength": {
			"!type": "fn(bytes: +Object, length: number) -> +NSMutableData"
		},
		"dataWithContentsOfURL": {
			"!type": "fn(url: +NSURL) -> +NSMutableData"
		},
		"dataWithBytesNoCopyLengthFreeWhenDone": {
			"!type": "fn(bytes: +Object, length: number, b: bool) -> +NSMutableData"
		},
		"dataWithData": {
			"!type": "fn(data: +NSData) -> +NSMutableData"
		},
		"dataWithContentsOfURLOptionsError": {
			"!type": "fn(url: +NSURL, readOptionsMask: number, errorPtr: +Object) -> +NSMutableData"
		},
		"dataWithBytesLength": {
			"!type": "fn(bytes: +Object, length: number) -> +NSMutableData"
		},
		"dataWithContentsOfFileOptionsError": {
			"!type": "fn(path: string, readOptionsMask: number, errorPtr: +Object) -> +NSMutableData"
		},
		"data": {
			"!type": "fn() -> +NSMutableData"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMutableData"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMutableData"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMutableData"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"length": {
				"!type": "number"
			},
			"length": {
				"!type": "number"
			},
			"description": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"appendData": {
				"!type": "fn(other: +NSData) -> void"
			},
			"resetBytesInRange": {
				"!type": "fn(range: +Object) -> void"
			},
			"initWithCapacity": {
				"!type": "fn(capacity: number) -> +NSMutableData"
			},
			"appendBytesLength": {
				"!type": "fn(bytes: +Object, length: number) -> void"
			},
			"decompressUsingAlgorithmError": {
				"!type": "fn(algorithm: number, error: +Object) -> bool"
			},
			"replaceBytesInRangeWithBytes": {
				"!type": "fn(range: +Object, bytes: +Object) -> void"
			},
			"replaceBytesInRangeWithBytesLength": {
				"!type": "fn(range: +Object, replacementBytes: +Object, replacementLength: number) -> void"
			},
			"initWithLength": {
				"!type": "fn(length: number) -> +NSMutableData"
			},
			"compressUsingAlgorithmError": {
				"!type": "fn(algorithm: number, error: +Object) -> bool"
			},
			"setData": {
				"!type": "fn(data: +NSData) -> void"
			},
			"increaseLengthBy": {
				"!type": "fn(extraLength: number) -> void"
			},
			"initWithContentsOfFileOptionsError": {
				"!type": "fn(path: string, readOptionsMask: number, errorPtr: +Object) -> +NSMutableData"
			},
			"initWithBase64Encoding": {
				"!type": "fn(base64String: string) -> +Object"
			},
			"subdataWithRange": {
				"!type": "fn(range: +Object) -> +NSData"
			},
			"initWithBytesNoCopyLengthFreeWhenDone": {
				"!type": "fn(bytes: +Object, length: number, b: bool) -> +NSMutableData"
			},
			"writeToURLOptionsError": {
				"!type": "fn(url: +NSURL, writeOptionsMask: number, errorPtr: +Object) -> bool"
			},
			"rangeOfDataOptionsRange": {
				"!type": "fn(dataToFind: +NSData, mask: number, searchRange: +Object) -> +Object"
			},
			"base64Encoding": {
				"!type": "fn() -> string"
			},
			"initWithContentsOfURL": {
				"!type": "fn(url: +NSURL) -> +NSMutableData"
			},
			"compressedDataUsingAlgorithmError": {
				"!type": "fn(algorithm: number, error: +Object) -> +NSMutableData"
			},
			"enumerateByteRangesUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"base64EncodedStringWithOptions": {
				"!type": "fn(options: number) -> string"
			},
			"getBytesLength": {
				"!type": "fn(buffer: +Object, length: number) -> void"
			},
			"initWithBytesNoCopyLengthDeallocator": {
				"!type": "fn(bytes: +Object, length: number, deallocator: +Function) -> +NSMutableData"
			},
			"initWithContentsOfFile": {
				"!type": "fn(path: string) -> +NSMutableData"
			},
			"writeToFileAtomically": {
				"!type": "fn(path: string, useAuxiliaryFile: bool) -> bool"
			},
			"initWithBytesLength": {
				"!type": "fn(bytes: +Object, length: number) -> +NSMutableData"
			},
			"writeToFileOptionsError": {
				"!type": "fn(path: string, writeOptionsMask: number, errorPtr: +Object) -> bool"
			},
			"base64EncodedDataWithOptions": {
				"!type": "fn(options: number) -> +NSData"
			},
			"getBytes": {
				"!type": "fn(buffer: +Object) -> void"
			},
			"isEqualToData": {
				"!type": "fn(other: +NSData) -> bool"
			},
			"writeToURLAtomically": {
				"!type": "fn(url: +NSURL, atomically: bool) -> bool"
			},
			"getBytesRange": {
				"!type": "fn(buffer: +Object, range: +Object) -> void"
			},
			"initWithBase64EncodedDataOptions": {
				"!type": "fn(base64Data: +NSData, options: number) -> +NSMutableData"
			},
			"initWithContentsOfMappedFile": {
				"!type": "fn(path: string) -> +Object"
			},
			"decompressedDataUsingAlgorithmError": {
				"!type": "fn(algorithm: number, error: +Object) -> +NSMutableData"
			},
			"initWithContentsOfURLOptionsError": {
				"!type": "fn(url: +NSURL, readOptionsMask: number, errorPtr: +Object) -> +NSMutableData"
			},
			"initWithBytesNoCopyLength": {
				"!type": "fn(bytes: +Object, length: number) -> +NSMutableData"
			},
			"initWithData": {
				"!type": "fn(data: +NSData) -> +NSMutableData"
			},
			"initWithBase64EncodedStringOptions": {
				"!type": "fn(base64String: string, options: number) -> +NSMutableData"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableData"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSPersonNameComponentsFormatter": {
		"localizedStringFromPersonNameComponentsStyleOptions": {
			"!type": "fn(components: +NSPersonNameComponents, nameFormatStyle: number, nameOptions: number) -> string"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSPersonNameComponentsFormatter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSPersonNameComponentsFormatter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSPersonNameComponentsFormatter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"phonetic": {
				"!type": "bool"
			},
			"style": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"annotatedStringFromPersonNameComponents": {
				"!type": "fn(components: +NSPersonNameComponents) -> +NSAttributedString"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringFromPersonNameComponents": {
				"!type": "fn(components: +NSPersonNameComponents) -> string"
			},
			"personNameComponentsFromString": {
				"!type": "fn(string: string) -> +NSPersonNameComponents"
			},
			"editingStringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription": {
				"!type": "fn(partialStringPtr: +Object, proposedSelRangePtr: +Object, origString: string, origSelRange: +Object, error: +Object) -> bool"
			},
			"getObjectValueForStringErrorDescription": {
				"!type": "fn(obj: +Object, string: string, error: +Object) -> bool"
			},
			"stringForObjectValue": {
				"!type": "fn(obj: +Object) -> string"
			},
			"attributedStringForObjectValueWithDefaultAttributes": {
				"!type": "fn(obj: +Object, attrs: +Object) -> +NSAttributedString"
			},
			"isPartialStringValidNewEditingStringErrorDescription": {
				"!type": "fn(partialString: string, newString: +Object, error: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSPersonNameComponentsFormatter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMutableAssetDownloadStorageManagementPolicy": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMutableAssetDownloadStorageManagementPolicy"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMutableAssetDownloadStorageManagementPolicy"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMutableAssetDownloadStorageManagementPolicy"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"priority": {
				"!type": "string"
			},
			"expirationDate": {
				"!type": "+Date"
			},
			"priority": {
				"!type": "string"
			},
			"expirationDate": {
				"!type": "+Date"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMutableAssetDownloadStorageManagementPolicy"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMutableMediaSelection": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMutableMediaSelection"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMutableMediaSelection"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMutableMediaSelection"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"asset": {
				"!type": "+AVAsset"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"selectMediaOptionInMediaSelectionGroup": {
				"!type": "fn(mediaSelectionOption: +AVMediaSelectionOption, mediaSelectionGroup: +AVMediaSelectionGroup) -> void"
			},
			"selectedMediaOptionInMediaSelectionGroup": {
				"!type": "fn(mediaSelectionGroup: +AVMediaSelectionGroup) -> +AVMediaSelectionOption"
			},
			"mediaSelectionCriteriaCanBeAppliedAutomaticallyToMediaSelectionGroup": {
				"!type": "fn(mediaSelectionGroup: +AVMediaSelectionGroup) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMutableMediaSelection"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioPlayer": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioPlayer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioPlayer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioPlayer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"meteringEnabled": {
				"!type": "bool"
			},
			"currentTime": {
				"!type": "number"
			},
			"url": {
				"!type": "+NSURL"
			},
			"format": {
				"!type": "+AVAudioFormat"
			},
			"settings": {
				"!type": "+Object"
			},
			"enableRate": {
				"!type": "bool"
			},
			"volume": {
				"!type": "number"
			},
			"rate": {
				"!type": "number"
			},
			"channelAssignments": {
				"!type": "+Array"
			},
			"numberOfChannels": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"deviceCurrentTime": {
				"!type": "number"
			},
			"duration": {
				"!type": "number"
			},
			"numberOfLoops": {
				"!type": "number"
			},
			"data": {
				"!type": "+NSData"
			},
			"playing": {
				"!type": "bool"
			},
			"pan": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithContentsOfURLError": {
				"!type": "fn(url: +NSURL, outError: +Object) -> +AVAudioPlayer"
			},
			"peakPowerForChannel": {
				"!type": "fn(channelNumber: number) -> number"
			},
			"averagePowerForChannel": {
				"!type": "fn(channelNumber: number) -> number"
			},
			"prepareToPlay": {
				"!type": "fn() -> bool"
			},
			"play": {
				"!type": "fn() -> bool"
			},
			"initWithDataError": {
				"!type": "fn(data: +NSData, outError: +Object) -> +AVAudioPlayer"
			},
			"initWithContentsOfURLFileTypeHintError": {
				"!type": "fn(url: +NSURL, utiString: string, outError: +Object) -> +AVAudioPlayer"
			},
			"playAtTime": {
				"!type": "fn(time: number) -> bool"
			},
			"updateMeters": {
				"!type": "fn() -> void"
			},
			"stop": {
				"!type": "fn() -> void"
			},
			"setVolumeFadeDuration": {
				"!type": "fn(volume: number, duration: number) -> void"
			},
			"pause": {
				"!type": "fn() -> void"
			},
			"initWithDataFileTypeHintError": {
				"!type": "fn(data: +NSData, utiString: string, outError: +Object) -> +AVAudioPlayer"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioPlayer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVVideoComposition": {
		"videoCompositionWithPropertiesOfAsset": {
			"!type": "fn(asset: +AVAsset) -> +AVVideoComposition"
		},
		"videoCompositionWithAssetApplyingCIFiltersWithHandler": {
			"!type": "fn(asset: +AVAsset, applier: +Function) -> +AVVideoComposition"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVVideoComposition"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVVideoComposition"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVVideoComposition"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"animationTool": {
				"!type": "+AVVideoCompositionCoreAnimationTool"
			},
			"colorYCbCrMatrix": {
				"!type": "string"
			},
			"frameDuration": {
				"!type": "+Object"
			},
			"colorPrimaries": {
				"!type": "string"
			},
			"renderScale": {
				"!type": "number"
			},
			"renderSize": {
				"!type": "+Object"
			},
			"colorTransferFunction": {
				"!type": "string"
			},
			"jscustomVideoCompositorClass": {
				"!type": "+Object"
			},
			"sourceTrackIDForFrameTiming": {
				"!type": "number"
			},
			"instructions": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"isValidForAssetTimeRangeValidationDelegate": {
				"!type": "fn(asset: +AVAsset, timeRange: +Object, validationDelegate: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVVideoComposition"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCapturePhotoOutput": {
		"JPEGPhotoDataRepresentationForJPEGSampleBufferPreviewPhotoSampleBuffer": {
			"!type": "fn(JPEGSampleBuffer: +Object, previewPhotoSampleBuffer: +Object) -> +NSData"
		},
		"jsnew": {
			"!type": "fn() -> +AVCapturePhotoOutput"
		},
		"isBayerRAWPixelFormat": {
			"!type": "fn(pixelFormat: number) -> bool"
		},
		"DNGPhotoDataRepresentationForRawSampleBufferPreviewPhotoSampleBuffer": {
			"!type": "fn(rawSampleBuffer: +Object, previewPhotoSampleBuffer: +Object) -> +NSData"
		},
		"isAppleProRAWPixelFormat": {
			"!type": "fn(pixelFormat: number) -> bool"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCapturePhotoOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCapturePhotoOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCapturePhotoOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"cameraCalibrationDataDeliverySupported": {
				"!type": "bool"
			},
			"dualCameraFusionSupported": {
				"!type": "bool"
			},
			"availableLivePhotoVideoCodecTypes": {
				"!type": "+Array"
			},
			"isStillImageStabilizationScene": {
				"!type": "bool"
			},
			"photoSettingsForSceneMonitoring": {
				"!type": "+AVCapturePhotoSettings"
			},
			"livePhotoCaptureSupported": {
				"!type": "bool"
			},
			"livePhotoCaptureEnabled": {
				"!type": "bool"
			},
			"maxBracketedCapturePhotoCount": {
				"!type": "number"
			},
			"appleProRAWSupported": {
				"!type": "bool"
			},
			"availableRawPhotoPixelFormatTypes": {
				"!type": "+Array"
			},
			"livePhotoCaptureSuspended": {
				"!type": "bool"
			},
			"availablePhotoFileTypes": {
				"!type": "+Array"
			},
			"preparedPhotoSettingsArray": {
				"!type": "+Array"
			},
			"stillImageStabilizationSupported": {
				"!type": "bool"
			},
			"contentAwareDistortionCorrectionEnabled": {
				"!type": "bool"
			},
			"livePhotoAutoTrimmingEnabled": {
				"!type": "bool"
			},
			"virtualDeviceConstituentPhotoDeliveryEnabled": {
				"!type": "bool"
			},
			"availableSemanticSegmentationMatteTypes": {
				"!type": "+Array"
			},
			"portraitEffectsMatteDeliveryEnabled": {
				"!type": "bool"
			},
			"availableRawPhotoFileTypes": {
				"!type": "+Array"
			},
			"dualCameraDualPhotoDeliverySupported": {
				"!type": "bool"
			},
			"availablePhotoCodecTypes": {
				"!type": "+Array"
			},
			"contentAwareDistortionCorrectionSupported": {
				"!type": "bool"
			},
			"isFlashScene": {
				"!type": "bool"
			},
			"portraitEffectsMatteDeliverySupported": {
				"!type": "bool"
			},
			"lensStabilizationDuringBracketedCaptureSupported": {
				"!type": "bool"
			},
			"appleProRAWEnabled": {
				"!type": "bool"
			},
			"availablePhotoPixelFormatTypes": {
				"!type": "+Array"
			},
			"depthDataDeliverySupported": {
				"!type": "bool"
			},
			"dualCameraDualPhotoDeliveryEnabled": {
				"!type": "bool"
			},
			"highResolutionCaptureEnabled": {
				"!type": "bool"
			},
			"enabledSemanticSegmentationMatteTypes": {
				"!type": "+Array"
			},
			"depthDataDeliveryEnabled": {
				"!type": "bool"
			},
			"virtualDeviceFusionSupported": {
				"!type": "bool"
			},
			"maxPhotoQualityPrioritization": {
				"!type": "number"
			},
			"autoRedEyeReductionSupported": {
				"!type": "bool"
			},
			"supportedFlashModes": {
				"!type": "+Array"
			},
			"virtualDeviceConstituentPhotoDeliverySupported": {
				"!type": "bool"
			},
			"connections": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"supportedPhotoPixelFormatTypesForFileType": {
				"!type": "fn(fileType: string) -> +Array"
			},
			"supportedPhotoCodecTypesForFileType": {
				"!type": "fn(fileType: string) -> +Array"
			},
			"jsinit": {
				"!type": "fn() -> +AVCapturePhotoOutput"
			},
			"supportedRawPhotoPixelFormatTypesForFileType": {
				"!type": "fn(fileType: string) -> +Array"
			},
			"capturePhotoWithSettingsDelegate": {
				"!type": "fn(settings: +AVCapturePhotoSettings, delegate: +Object) -> void"
			},
			"setPreparedPhotoSettingsArrayCompletionHandler": {
				"!type": "fn(preparedPhotoSettingsArray: +Array, completionHandler: +Function) -> void"
			},
			"metadataOutputRectOfInterestForRect": {
				"!type": "fn(rectInOutputCoordinates: +Object) -> +Object"
			},
			"transformedMetadataObjectForMetadataObjectConnection": {
				"!type": "fn(metadataObject: +AVMetadataObject, connection: +AVCaptureConnection) -> +AVMetadataObject"
			},
			"rectForMetadataOutputRectOfInterest": {
				"!type": "fn(rectInMetadataOutputCoordinates: +Object) -> +Object"
			},
			"connectionWithMediaType": {
				"!type": "fn(mediaType: string) -> +AVCaptureConnection"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCapturePhotoOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLProtectionSpace": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLProtectionSpace"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLProtectionSpace"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLProtectionSpace"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"proxyType": {
				"!type": "string"
			},
			"realm": {
				"!type": "string"
			},
			"distinguishedNames": {
				"!type": "+Array"
			},
			"host": {
				"!type": "string"
			},
			"receivesCredentialSecurely": {
				"!type": "bool"
			},
			"protocol": {
				"!type": "string"
			},
			"authenticationMethod": {
				"!type": "string"
			},
			"port": {
				"!type": "number"
			},
			"serverTrust": {
				"!type": "+Object"
			},
			"isProxy": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithProxyHostPortTypeRealmAuthenticationMethod": {
				"!type": "fn(host: string, port: number, type: string, realm: string, authenticationMethod: string) -> +NSURLProtectionSpace"
			},
			"initWithHostPortProtocolRealmAuthenticationMethod": {
				"!type": "fn(host: string, port: number, protocol: string, realm: string, authenticationMethod: string) -> +NSURLProtectionSpace"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLProtectionSpace"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSComparisonPredicate": {
		"predicateWithLeftExpressionRightExpressionCustomSelector": {
			"!type": "fn(lhs: +NSExpression, rhs: +NSExpression, selector: string) -> +NSComparisonPredicate"
		},
		"predicateWithLeftExpressionRightExpressionModifierTypeOptions": {
			"!type": "fn(lhs: +NSExpression, rhs: +NSExpression, modifier: number, type: number, options: number) -> +NSComparisonPredicate"
		},
		"predicateWithFormatArguments": {
			"!type": "fn(predicateFormat: string, argList: +Object) -> +NSPredicate"
		},
		"predicateWithFormat": {
			"!type": "fn(predicateFormat: string, args: Array.prototype) -> +NSPredicate"
		},
		"predicateWithValue": {
			"!type": "fn(value: bool) -> +NSPredicate"
		},
		"predicateWithFormatArgumentArray": {
			"!type": "fn(predicateFormat: string, arguments: +Array) -> +NSPredicate"
		},
		"predicateWithBlock": {
			"!type": "fn(block: +Function) -> +NSPredicate"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSComparisonPredicate"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSComparisonPredicate"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSComparisonPredicate"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jscustomSelector": {
				"!type": "string"
			},
			"leftExpression": {
				"!type": "+NSExpression"
			},
			"comparisonPredicateModifier": {
				"!type": "number"
			},
			"rightExpression": {
				"!type": "+NSExpression"
			},
			"options": {
				"!type": "number"
			},
			"predicateOperatorType": {
				"!type": "number"
			},
			"predicateFormat": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSComparisonPredicate"
			},
			"initWithLeftExpressionRightExpressionModifierTypeOptions": {
				"!type": "fn(lhs: +NSExpression, rhs: +NSExpression, modifier: number, type: number, options: number) -> +NSComparisonPredicate"
			},
			"initWithLeftExpressionRightExpressionCustomSelector": {
				"!type": "fn(lhs: +NSExpression, rhs: +NSExpression, selector: string) -> +NSComparisonPredicate"
			},
			"predicateWithSubstitutionVariables": {
				"!type": "fn(variables: +Object) -> +NSComparisonPredicate"
			},
			"evaluateWithObject": {
				"!type": "fn(object: +Object) -> bool"
			},
			"allowEvaluation": {
				"!type": "fn() -> void"
			},
			"evaluateWithObjectSubstitutionVariables": {
				"!type": "fn(object: +Object, bindings: +Object) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSComparisonPredicate"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSBlockOperation": {
		"blockOperationWithBlock": {
			"!type": "fn(block: +Function) -> +NSBlockOperation"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSBlockOperation"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSBlockOperation"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSBlockOperation"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"executionBlocks": {
				"!type": "+Array"
			},
			"ready": {
				"!type": "bool"
			},
			"name": {
				"!type": "string"
			},
			"jscompletionBlock": {
				"!type": "+Function"
			},
			"concurrent": {
				"!type": "bool"
			},
			"qualityOfService": {
				"!type": "number"
			},
			"queuePriority": {
				"!type": "number"
			},
			"executing": {
				"!type": "bool"
			},
			"finished": {
				"!type": "bool"
			},
			"dependencies": {
				"!type": "+Array"
			},
			"asynchronous": {
				"!type": "bool"
			},
			"threadPriority": {
				"!type": "number"
			},
			"cancelled": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"addExecutionBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"cancel": {
				"!type": "fn() -> void"
			},
			"waitUntilFinished": {
				"!type": "fn() -> void"
			},
			"start": {
				"!type": "fn() -> void"
			},
			"main": {
				"!type": "fn() -> void"
			},
			"addDependency": {
				"!type": "fn(op: +NSOperation) -> void"
			},
			"removeDependency": {
				"!type": "fn(op: +NSOperation) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSBlockOperation"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSOutputStream": {
		"outputStreamToFileAtPathAppend": {
			"!type": "fn(path: string, shouldAppend: bool) -> +NSOutputStream"
		},
		"outputStreamToMemory": {
			"!type": "fn() -> +NSOutputStream"
		},
		"outputStreamToBufferCapacity": {
			"!type": "fn(buffer: +Object, capacity: number) -> +NSOutputStream"
		},
		"outputStreamWithURLAppend": {
			"!type": "fn(url: +NSURL, shouldAppend: bool) -> +NSOutputStream"
		},
		"getBoundStreamsWithBufferSizeInputStreamOutputStream": {
			"!type": "fn(bufferSize: number, inputStream: +Object, outputStream: +Object) -> void"
		},
		"getStreamsToHostWithNamePortInputStreamOutputStream": {
			"!type": "fn(hostname: string, port: number, inputStream: +Object, outputStream: +Object) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSOutputStream"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSOutputStream"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSOutputStream"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"hasSpaceAvailable": {
				"!type": "bool"
			},
			"streamError": {
				"!type": "+NSError"
			},
			"streamStatus": {
				"!type": "number"
			},
			"delegate": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initToBufferCapacity": {
				"!type": "fn(buffer: +Object, capacity: number) -> +NSOutputStream"
			},
			"initToFileAtPathAppend": {
				"!type": "fn(path: string, shouldAppend: bool) -> +NSOutputStream"
			},
			"jsinitToMemory": {
				"!type": "fn() -> +NSOutputStream"
			},
			"writeMaxLength": {
				"!type": "fn(buffer: +Object, len: number) -> number"
			},
			"initWithURLAppend": {
				"!type": "fn(url: +NSURL, shouldAppend: bool) -> +NSOutputStream"
			},
			"setPropertyForKey": {
				"!type": "fn(property: +Object, key: string) -> bool"
			},
			"scheduleInRunLoopForMode": {
				"!type": "fn(aRunLoop: +NSRunLoop, mode: string) -> void"
			},
			"propertyForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"removeFromRunLoopForMode": {
				"!type": "fn(aRunLoop: +NSRunLoop, mode: string) -> void"
			},
			"close": {
				"!type": "fn() -> void"
			},
			"open": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSOutputStream"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVTextStyleRule": {
		"propertyListForTextStyleRules": {
			"!type": "fn(textStyleRules: +Array) -> +Object"
		},
		"textStyleRuleWithTextMarkupAttributes": {
			"!type": "fn(textMarkupAttributes: +Object) -> +AVTextStyleRule"
		},
		"textStyleRuleWithTextMarkupAttributesTextSelector": {
			"!type": "fn(textMarkupAttributes: +Object, textSelector: string) -> +AVTextStyleRule"
		},
		"textStyleRulesFromPropertyList": {
			"!type": "fn(plist: +Object) -> +Array"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVTextStyleRule"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVTextStyleRule"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVTextStyleRule"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"textMarkupAttributes": {
				"!type": "+Object"
			},
			"textSelector": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithTextMarkupAttributesTextSelector": {
				"!type": "fn(textMarkupAttributes: +Object, textSelector: string) -> +AVTextStyleRule"
			},
			"initWithTextMarkupAttributes": {
				"!type": "fn(textMarkupAttributes: +Object) -> +AVTextStyleRule"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVTextStyleRule"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMetadataItemValueRequest": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMetadataItemValueRequest"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMetadataItemValueRequest"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMetadataItemValueRequest"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"metadataItem": {
				"!type": "+AVMetadataItem"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"respondWithValue": {
				"!type": "fn(value: +Object) -> void"
			},
			"respondWithError": {
				"!type": "fn(error: +NSError) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMetadataItemValueRequest"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioSourceNode": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioSourceNode"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioSourceNode"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioSourceNode"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"engine": {
				"!type": "+AVAudioEngine"
			},
			"latency": {
				"!type": "number"
			},
			"numberOfInputs": {
				"!type": "number"
			},
			"outputPresentationLatency": {
				"!type": "number"
			},
			"AUAudioUnit": {
				"!type": "+AUAudioUnit"
			},
			"lastRenderTime": {
				"!type": "+AVAudioTime"
			},
			"numberOfOutputs": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithRenderBlock": {
				"!type": "fn(block: +Function) -> +AVAudioSourceNode"
			},
			"initWithFormatRenderBlock": {
				"!type": "fn(format: +AVAudioFormat, block: +Function) -> +AVAudioSourceNode"
			},
			"reset": {
				"!type": "fn() -> void"
			},
			"installTapOnBusBufferSizeFormatBlock": {
				"!type": "fn(bus: number, bufferSize: number, format: +AVAudioFormat, tapBlock: +Function) -> void"
			},
			"removeTapOnBus": {
				"!type": "fn(bus: number) -> void"
			},
			"nameForOutputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"nameForInputBus": {
				"!type": "fn(bus: number) -> string"
			},
			"inputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"outputFormatForBus": {
				"!type": "fn(bus: number) -> +AVAudioFormat"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioSourceNode"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVContentKeyResponse": {
		"contentKeyResponseWithFairPlayStreamingKeyResponseData": {
			"!type": "fn(keyResponseData: +NSData) -> +AVContentKeyResponse"
		},
		"contentKeyResponseWithAuthorizationTokenData": {
			"!type": "fn(authorizationTokenData: +NSData) -> +AVContentKeyResponse"
		},
		"contentKeyResponseWithClearKeyDataInitializationVector": {
			"!type": "fn(keyData: +NSData, initializationVector: +NSData) -> +AVContentKeyResponse"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVContentKeyResponse"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVContentKeyResponse"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVContentKeyResponse"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVContentKeyResponse"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerMediaSelectionCriteria": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerMediaSelectionCriteria"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerMediaSelectionCriteria"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerMediaSelectionCriteria"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"principalMediaCharacteristics": {
				"!type": "+Array"
			},
			"preferredLanguages": {
				"!type": "+Array"
			},
			"preferredMediaCharacteristics": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithPrincipalMediaCharacteristicsPreferredLanguagesPreferredMediaCharacteristics": {
				"!type": "fn(principalMediaCharacteristics: +Array, preferredLanguages: +Array, preferredMediaCharacteristics: +Array) -> +AVPlayerMediaSelectionCriteria"
			},
			"initWithPreferredLanguagesPreferredMediaCharacteristics": {
				"!type": "fn(preferredLanguages: +Array, preferredMediaCharacteristics: +Array) -> +AVPlayerMediaSelectionCriteria"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerMediaSelectionCriteria"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVFrameRateRange": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVFrameRateRange"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVFrameRateRange"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVFrameRateRange"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"maxFrameDuration": {
				"!type": "+Object"
			},
			"maxFrameRate": {
				"!type": "number"
			},
			"minFrameDuration": {
				"!type": "+Object"
			},
			"minFrameRate": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVFrameRateRange"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"EAGLSharegroup": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +EAGLSharegroup"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +EAGLSharegroup"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +EAGLSharegroup"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"debugLabel": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +EAGLSharegroup"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSIndexPath": {
		"indexPathWithIndex": {
			"!type": "fn(index: number) -> +NSIndexPath"
		},
		"indexPathWithIndexesLength": {
			"!type": "fn(indexes: +Object, length: number) -> +NSIndexPath"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSIndexPath"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSIndexPath"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSIndexPath"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"length": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithIndex": {
				"!type": "fn(index: number) -> +NSIndexPath"
			},
			"getIndexes": {
				"!type": "fn(indexes: +Object) -> void"
			},
			"getIndexesRange": {
				"!type": "fn(indexes: +Object, positionRange: +Object) -> void"
			},
			"indexAtPosition": {
				"!type": "fn(position: number) -> number"
			},
			"indexPathByRemovingLastIndex": {
				"!type": "fn() -> +NSIndexPath"
			},
			"initWithIndexesLength": {
				"!type": "fn(indexes: +Object, length: number) -> +NSIndexPath"
			},
			"indexPathByAddingIndex": {
				"!type": "fn(index: number) -> +NSIndexPath"
			},
			"compare": {
				"!type": "fn(otherObject: +NSIndexPath) -> number"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSIndexPath"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVVideoCompositionRenderContext": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVVideoCompositionRenderContext"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVVideoCompositionRenderContext"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVVideoCompositionRenderContext"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"edgeWidths": {
				"!type": "+Object"
			},
			"pixelAspectRatio": {
				"!type": "+Object"
			},
			"renderTransform": {
				"!type": "+Object"
			},
			"highQualityRendering": {
				"!type": "bool"
			},
			"renderScale": {
				"!type": "number"
			},
			"videoComposition": {
				"!type": "+AVVideoComposition"
			},
			"size": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"newPixelBuffer": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVVideoCompositionRenderContext"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"CADisplayLink": {
		"displayLinkWithTargetSelector": {
			"!type": "fn(target: +Object, sel: string) -> +CADisplayLink"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +CADisplayLink"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +CADisplayLink"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +CADisplayLink"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"targetTimestamp": {
				"!type": "number"
			},
			"timestamp": {
				"!type": "number"
			},
			"frameInterval": {
				"!type": "number"
			},
			"paused": {
				"!type": "bool"
			},
			"preferredFramesPerSecond": {
				"!type": "number"
			},
			"duration": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"invalidate": {
				"!type": "fn() -> void"
			},
			"addToRunLoopForMode": {
				"!type": "fn(runloop: +NSRunLoop, mode: string) -> void"
			},
			"removeFromRunLoopForMode": {
				"!type": "fn(runloop: +NSRunLoop, mode: string) -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +CADisplayLink"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerItemErrorLogEvent": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerItemErrorLogEvent"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerItemErrorLogEvent"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerItemErrorLogEvent"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"errorStatusCode": {
				"!type": "number"
			},
			"URI": {
				"!type": "string"
			},
			"errorDomain": {
				"!type": "string"
			},
			"date": {
				"!type": "+Date"
			},
			"playbackSessionID": {
				"!type": "string"
			},
			"serverAddress": {
				"!type": "string"
			},
			"errorComment": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerItemErrorLogEvent"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSUnitAngle": {
		"arcMinutes": {
			"!type": "fn() -> +NSUnitAngle"
		},
		"revolutions": {
			"!type": "fn() -> +NSUnitAngle"
		},
		"radians": {
			"!type": "fn() -> +NSUnitAngle"
		},
		"gradians": {
			"!type": "fn() -> +NSUnitAngle"
		},
		"degrees": {
			"!type": "fn() -> +NSUnitAngle"
		},
		"arcSeconds": {
			"!type": "fn() -> +NSUnitAngle"
		},
		"baseUnit": {
			"!type": "fn() -> +NSUnitAngle"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSUnitAngle"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSUnitAngle"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSUnitAngle"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"converter": {
				"!type": "+NSUnitConverter"
			},
			"symbol": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithSymbolConverter": {
				"!type": "fn(symbol: string, converter: +NSUnitConverter) -> +NSUnitAngle"
			},
			"initWithSymbol": {
				"!type": "fn(symbol: string) -> +NSUnitAngle"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSUnitAngle"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMutableString": {
		"stringWithCapacity": {
			"!type": "fn(capacity: number) -> +NSMutableString"
		},
		"stringWithCStringLength": {
			"!type": "fn(bytes: +Object, length: number) -> +Object"
		},
		"defaultCStringEncoding": {
			"!type": "fn() -> number"
		},
		"stringWithContentsOfFile": {
			"!type": "fn(path: string) -> +Object"
		},
		"string": {
			"!type": "fn() -> +NSMutableString"
		},
		"stringEncodingForDataEncodingOptionsConvertedStringUsedLossyConversion": {
			"!type": "fn(data: +NSData, opts: +Object, string: +Object, usedLossyConversion: +Object) -> number"
		},
		"stringWithUTF8String": {
			"!type": "fn(nullTerminatedCString: +Object) -> +NSMutableString"
		},
		"stringWithCString": {
			"!type": "fn(bytes: +Object) -> +Object"
		},
		"stringWithContentsOfFileUsedEncodingError": {
			"!type": "fn(path: string, enc: +Object, error: +Object) -> +NSMutableString"
		},
		"stringWithContentsOfURL": {
			"!type": "fn(url: +NSURL) -> +Object"
		},
		"stringWithCharactersLength": {
			"!type": "fn(characters: +Object, length: number) -> +NSMutableString"
		},
		"pathWithComponents": {
			"!type": "fn(components: +Array) -> string"
		},
		"localizedStringWithFormat": {
			"!type": "fn(format: string, args: Array.prototype) -> +NSMutableString"
		},
		"availableStringEncodings": {
			"!type": "fn() -> +Object"
		},
		"stringWithContentsOfFileEncodingError": {
			"!type": "fn(path: string, enc: number, error: +Object) -> +NSMutableString"
		},
		"localizedNameOfStringEncoding": {
			"!type": "fn(encoding: number) -> string"
		},
		"stringWithCStringEncoding": {
			"!type": "fn(cString: +Object, enc: number) -> +NSMutableString"
		},
		"stringWithFormat": {
			"!type": "fn(format: string, args: Array.prototype) -> +NSMutableString"
		},
		"stringWithString": {
			"!type": "fn(string: string) -> +NSMutableString"
		},
		"stringWithContentsOfURLUsedEncodingError": {
			"!type": "fn(url: +NSURL, enc: +Object, error: +Object) -> +NSMutableString"
		},
		"stringWithContentsOfURLEncodingError": {
			"!type": "fn(url: +NSURL, enc: number, error: +Object) -> +NSMutableString"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMutableString"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMutableString"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMutableString"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"stringByRemovingPercentEncoding": {
				"!type": "string"
			},
			"stringByStandardizingPath": {
				"!type": "string"
			},
			"doubleValue": {
				"!type": "number"
			},
			"boolValue": {
				"!type": "bool"
			},
			"stringByAbbreviatingWithTildeInPath": {
				"!type": "string"
			},
			"description": {
				"!type": "string"
			},
			"decomposedStringWithCanonicalMapping": {
				"!type": "string"
			},
			"smallestEncoding": {
				"!type": "number"
			},
			"uppercaseString": {
				"!type": "string"
			},
			"length": {
				"!type": "number"
			},
			"absolutePath": {
				"!type": "bool"
			},
			"fastestEncoding": {
				"!type": "number"
			},
			"decomposedStringWithCompatibilityMapping": {
				"!type": "string"
			},
			"precomposedStringWithCanonicalMapping": {
				"!type": "string"
			},
			"stringByResolvingSymlinksInPath": {
				"!type": "string"
			},
			"lowercaseString": {
				"!type": "string"
			},
			"pathExtension": {
				"!type": "string"
			},
			"precomposedStringWithCompatibilityMapping": {
				"!type": "string"
			},
			"hash": {
				"!type": "number"
			},
			"localizedLowercaseString": {
				"!type": "string"
			},
			"lastPathComponent": {
				"!type": "string"
			},
			"floatValue": {
				"!type": "number"
			},
			"stringByDeletingPathExtension": {
				"!type": "string"
			},
			"intValue": {
				"!type": "number"
			},
			"localizedUppercaseString": {
				"!type": "string"
			},
			"capitalizedString": {
				"!type": "string"
			},
			"integerValue": {
				"!type": "number"
			},
			"stringByExpandingTildeInPath": {
				"!type": "string"
			},
			"stringByDeletingLastPathComponent": {
				"!type": "string"
			},
			"localizedCapitalizedString": {
				"!type": "string"
			},
			"longLongValue": {
				"!type": "number"
			},
			"pathComponents": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"replaceCharactersInRangeWithString": {
				"!type": "fn(range: +Object, aString: string) -> void"
			},
			"insertStringAtIndex": {
				"!type": "fn(aString: string, loc: number) -> void"
			},
			"initWithCapacity": {
				"!type": "fn(capacity: number) -> +NSMutableString"
			},
			"applyTransformReverseRangeUpdatedRange": {
				"!type": "fn(transform: string, reverse: bool, range: +Object, resultingRange: +Object) -> bool"
			},
			"replaceOccurrencesOfStringWithStringOptionsRange": {
				"!type": "fn(target: string, replacement: string, options: number, searchRange: +Object) -> number"
			},
			"setString": {
				"!type": "fn(aString: string) -> void"
			},
			"appendFormat": {
				"!type": "fn(format: string, args: Array.prototype) -> void"
			},
			"appendString": {
				"!type": "fn(aString: string) -> void"
			},
			"deleteCharactersInRange": {
				"!type": "fn(range: +Object) -> void"
			},
			"stringByTrimmingCharactersInSet": {
				"!type": "fn(set: +NSCharacterSet) -> string"
			},
			"getCharacters": {
				"!type": "fn(buffer: +Object) -> void"
			},
			"localizedCaseInsensitiveCompare": {
				"!type": "fn(string: string) -> number"
			},
			"commonPrefixWithStringOptions": {
				"!type": "fn(str: string, mask: number) -> string"
			},
			"initWithFormatArguments": {
				"!type": "fn(format: string, argList: +Object) -> +NSMutableString"
			},
			"lowercaseStringWithLocale": {
				"!type": "fn(locale: +NSLocale) -> string"
			},
			"containsString": {
				"!type": "fn(str: string) -> bool"
			},
			"componentsSeparatedByCharactersInSet": {
				"!type": "fn(separator: +NSCharacterSet) -> +Array"
			},
			"stringByAddingPercentEncodingWithAllowedCharacters": {
				"!type": "fn(allowedCharacters: +NSCharacterSet) -> string"
			},
			"initWithContentsOfFile": {
				"!type": "fn(path: string) -> +Object"
			},
			"propertyListFromStringsFileFormat": {
				"!type": "fn() -> +Object"
			},
			"enumerateLinguisticTagsInRangeSchemeOptionsOrthographyUsingBlock": {
				"!type": "fn(range: +Object, scheme: string, options: number, orthography: +NSOrthography, block: +Function) -> void"
			},
			"hasSuffix": {
				"!type": "fn(str: string) -> bool"
			},
			"lineRangeForRange": {
				"!type": "fn(range: +Object) -> +Object"
			},
			"initWithContentsOfFileEncodingError": {
				"!type": "fn(path: string, enc: number, error: +Object) -> +NSMutableString"
			},
			"initWithFormatLocale": {
				"!type": "fn(format: string, locale: +Object, args: Array.prototype) -> +NSMutableString"
			},
			"lossyCString": {
				"!type": "fn() -> +Object"
			},
			"substringWithRange": {
				"!type": "fn(range: +Object) -> string"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableString"
			},
			"getParagraphStartEndContentsEndForRange": {
				"!type": "fn(startPtr: +Object, parEndPtr: +Object, contentsEndPtr: +Object, range: +Object) -> void"
			},
			"getCharactersRange": {
				"!type": "fn(buffer: +Object, range: +Object) -> void"
			},
			"rangeOfComposedCharacterSequencesForRange": {
				"!type": "fn(range: +Object) -> +Object"
			},
			"cStringUsingEncoding": {
				"!type": "fn(encoding: number) -> +Object"
			},
			"rangeOfCharacterFromSetOptions": {
				"!type": "fn(searchSet: +NSCharacterSet, mask: number) -> +Object"
			},
			"lengthOfBytesUsingEncoding": {
				"!type": "fn(enc: number) -> number"
			},
			"substringToIndex": {
				"!type": "fn(to: number) -> string"
			},
			"writeToFileAtomicallyEncodingError": {
				"!type": "fn(path: string, useAuxiliaryFile: bool, enc: number, error: +Object) -> bool"
			},
			"rangeOfCharacterFromSet": {
				"!type": "fn(searchSet: +NSCharacterSet) -> +Object"
			},
			"initWithCoder": {
				"!type": "fn(coder: +NSCoder) -> +NSMutableString"
			},
			"getCStringMaxLengthEncoding": {
				"!type": "fn(buffer: +Object, maxBufferCount: number, encoding: number) -> bool"
			},
			"stringByAppendingPathExtension": {
				"!type": "fn(str: string) -> string"
			},
			"initWithCStringNoCopyLengthFreeWhenDone": {
				"!type": "fn(bytes: +Object, length: number, freeBuffer: bool) -> +Object"
			},
			"localizedCompare": {
				"!type": "fn(string: string) -> number"
			},
			"stringByApplyingTransformReverse": {
				"!type": "fn(transform: string, reverse: bool) -> string"
			},
			"completePathIntoStringCaseSensitiveMatchesIntoArrayFilterTypes": {
				"!type": "fn(outputName: +Object, flag: bool, outputArray: +Object, filterTypes: +Array) -> number"
			},
			"stringByReplacingOccurrencesOfStringWithStringOptionsRange": {
				"!type": "fn(target: string, replacement: string, options: number, searchRange: +Object) -> string"
			},
			"localizedCaseInsensitiveContainsString": {
				"!type": "fn(str: string) -> bool"
			},
			"stringByAddingPercentEscapesUsingEncoding": {
				"!type": "fn(enc: number) -> string"
			},
			"initWithCharactersLength": {
				"!type": "fn(characters: +Object, length: number) -> +NSMutableString"
			},
			"stringByReplacingOccurrencesOfStringWithString": {
				"!type": "fn(target: string, replacement: string) -> string"
			},
			"propertyList": {
				"!type": "fn() -> +Object"
			},
			"initWithFormatLocaleArguments": {
				"!type": "fn(format: string, locale: +Object, argList: +Object) -> +NSMutableString"
			},
			"getCString": {
				"!type": "fn(bytes: +Object) -> void"
			},
			"getLineStartEndContentsEndForRange": {
				"!type": "fn(startPtr: +Object, lineEndPtr: +Object, contentsEndPtr: +Object, range: +Object) -> void"
			},
			"hasPrefix": {
				"!type": "fn(str: string) -> bool"
			},
			"initWithCStringLength": {
				"!type": "fn(bytes: +Object, length: number) -> +Object"
			},
			"getBytesMaxLengthUsedLengthEncodingOptionsRangeRemainingRange": {
				"!type": "fn(buffer: +Object, maxBufferCount: number, usedBufferCount: +Object, encoding: number, options: number, range: +Object, leftover: +Object) -> bool"
			},
			"componentsSeparatedByString": {
				"!type": "fn(separator: string) -> +Array"
			},
			"initWithBytesNoCopyLengthEncodingFreeWhenDone": {
				"!type": "fn(bytes: +Object, len: number, encoding: number, freeBuffer: bool) -> +NSMutableString"
			},
			"maximumLengthOfBytesUsingEncoding": {
				"!type": "fn(enc: number) -> number"
			},
			"initWithDataEncoding": {
				"!type": "fn(data: +NSData, encoding: number) -> +NSMutableString"
			},
			"rangeOfStringOptionsRange": {
				"!type": "fn(searchString: string, mask: number, rangeOfReceiverToSearch: +Object) -> +Object"
			},
			"initWithCharactersNoCopyLengthDeallocator": {
				"!type": "fn(chars: +Object, len: number, deallocator: +Function) -> +NSMutableString"
			},
			"caseInsensitiveCompare": {
				"!type": "fn(string: string) -> number"
			},
			"stringByReplacingCharactersInRangeWithString": {
				"!type": "fn(range: +Object, replacement: string) -> string"
			},
			"compareOptions": {
				"!type": "fn(string: string, mask: number) -> number"
			},
			"initWithContentsOfURLEncodingError": {
				"!type": "fn(url: +NSURL, enc: number, error: +Object) -> +NSMutableString"
			},
			"canBeConvertedToEncoding": {
				"!type": "fn(encoding: number) -> bool"
			},
			"rangeOfStringOptions": {
				"!type": "fn(searchString: string, mask: number) -> +Object"
			},
			"initWithCStringEncoding": {
				"!type": "fn(nullTerminatedCString: +Object, encoding: number) -> +NSMutableString"
			},
			"stringByFoldingWithOptionsLocale": {
				"!type": "fn(options: number, locale: +NSLocale) -> string"
			},
			"initWithFormat": {
				"!type": "fn(format: string, args: Array.prototype) -> +NSMutableString"
			},
			"enumerateSubstringsInRangeOptionsUsingBlock": {
				"!type": "fn(range: +Object, opts: number, block: +Function) -> void"
			},
			"initWithString": {
				"!type": "fn(aString: string) -> +NSMutableString"
			},
			"stringByPaddingToLengthWithStringStartingAtIndex": {
				"!type": "fn(newLength: number, padString: string, padIndex: number) -> string"
			},
			"localizedStandardRangeOfString": {
				"!type": "fn(str: string) -> +Object"
			},
			"rangeOfString": {
				"!type": "fn(searchString: string) -> +Object"
			},
			"getCStringMaxLengthRangeRemainingRange": {
				"!type": "fn(bytes: +Object, maxLength: number, aRange: +Object, leftoverRange: +Object) -> void"
			},
			"initWithCString": {
				"!type": "fn(bytes: +Object) -> +Object"
			},
			"getFileSystemRepresentationMaxLength": {
				"!type": "fn(cname: +Object, max: number) -> bool"
			},
			"compare": {
				"!type": "fn(string: string) -> number"
			},
			"enumerateLinesUsingBlock": {
				"!type": "fn(block: +Function) -> void"
			},
			"writeToURLAtomically": {
				"!type": "fn(url: +NSURL, atomically: bool) -> bool"
			},
			"initWithBytesNoCopyLengthEncodingDeallocator": {
				"!type": "fn(bytes: +Object, len: number, encoding: number, deallocator: +Function) -> +NSMutableString"
			},
			"stringByAppendingString": {
				"!type": "fn(aString: string) -> string"
			},
			"compareOptionsRange": {
				"!type": "fn(string: string, mask: number, rangeOfReceiverToCompare: +Object) -> number"
			},
			"substringFromIndex": {
				"!type": "fn(from: number) -> string"
			},
			"initWithCharactersNoCopyLengthFreeWhenDone": {
				"!type": "fn(characters: +Object, length: number, freeBuffer: bool) -> +NSMutableString"
			},
			"stringByAppendingPathComponent": {
				"!type": "fn(str: string) -> string"
			},
			"capitalizedStringWithLocale": {
				"!type": "fn(locale: +NSLocale) -> string"
			},
			"localizedStandardContainsString": {
				"!type": "fn(str: string) -> bool"
			},
			"stringsByAppendingPaths": {
				"!type": "fn(paths: +Array) -> +Array"
			},
			"stringByAppendingFormat": {
				"!type": "fn(format: string, args: Array.prototype) -> string"
			},
			"cString": {
				"!type": "fn() -> +Object"
			},
			"isEqualToString": {
				"!type": "fn(aString: string) -> bool"
			},
			"getCStringMaxLength": {
				"!type": "fn(bytes: +Object, maxLength: number) -> void"
			},
			"linguisticTagsInRangeSchemeOptionsOrthographyTokenRanges": {
				"!type": "fn(range: +Object, scheme: string, options: number, orthography: +NSOrthography, tokenRanges: +Object) -> +Array"
			},
			"cStringLength": {
				"!type": "fn() -> number"
			},
			"rangeOfCharacterFromSetOptionsRange": {
				"!type": "fn(searchSet: +NSCharacterSet, mask: number, rangeOfReceiverToSearch: +Object) -> +Object"
			},
			"variantFittingPresentationWidth": {
				"!type": "fn(width: number) -> string"
			},
			"rangeOfComposedCharacterSequenceAtIndex": {
				"!type": "fn(index: number) -> +Object"
			},
			"writeToURLAtomicallyEncodingError": {
				"!type": "fn(url: +NSURL, useAuxiliaryFile: bool, enc: number, error: +Object) -> bool"
			},
			"initWithContentsOfURLUsedEncodingError": {
				"!type": "fn(url: +NSURL, enc: +Object, error: +Object) -> +NSMutableString"
			},
			"dataUsingEncoding": {
				"!type": "fn(encoding: number) -> +NSData"
			},
			"initWithContentsOfURL": {
				"!type": "fn(url: +NSURL) -> +Object"
			},
			"initWithBytesLengthEncoding": {
				"!type": "fn(bytes: +Object, len: number, encoding: number) -> +NSMutableString"
			},
			"initWithContentsOfFileUsedEncodingError": {
				"!type": "fn(path: string, enc: +Object, error: +Object) -> +NSMutableString"
			},
			"dataUsingEncodingAllowLossyConversion": {
				"!type": "fn(encoding: number, lossy: bool) -> +NSData"
			},
			"compareOptionsRangeLocale": {
				"!type": "fn(string: string, mask: number, rangeOfReceiverToCompare: +Object, locale: +Object) -> number"
			},
			"writeToFileAtomically": {
				"!type": "fn(path: string, useAuxiliaryFile: bool) -> bool"
			},
			"localizedStandardCompare": {
				"!type": "fn(string: string) -> number"
			},
			"characterAtIndex": {
				"!type": "fn(index: number) -> number"
			},
			"paragraphRangeForRange": {
				"!type": "fn(range: +Object) -> +Object"
			},
			"rangeOfStringOptionsRangeLocale": {
				"!type": "fn(searchString: string, mask: number, rangeOfReceiverToSearch: +Object, locale: +NSLocale) -> +Object"
			},
			"initWithUTF8String": {
				"!type": "fn(nullTerminatedCString: +Object) -> +NSMutableString"
			},
			"stringByReplacingPercentEscapesUsingEncoding": {
				"!type": "fn(enc: number) -> string"
			},
			"uppercaseStringWithLocale": {
				"!type": "fn(locale: +NSLocale) -> string"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMutableString"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMessagePort": {
		"port": {
			"!type": "fn() -> +NSPort"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMessagePort"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMessagePort"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMessagePort"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"reservedSpaceLength": {
				"!type": "number"
			},
			"valid": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"invalidate": {
				"!type": "fn() -> void"
			},
			"sendBeforeDateMsgidComponentsFromReserved": {
				"!type": "fn(limitDate: +Date, msgID: number, components: +NSMutableArray, receivePort: +NSPort, headerSpaceReserved: number) -> bool"
			},
			"setDelegate": {
				"!type": "fn(anObject: +Object) -> void"
			},
			"scheduleInRunLoopForMode": {
				"!type": "fn(runLoop: +NSRunLoop, mode: string) -> void"
			},
			"removeFromRunLoopForMode": {
				"!type": "fn(runLoop: +NSRunLoop, mode: string) -> void"
			},
			"sendBeforeDateComponentsFromReserved": {
				"!type": "fn(limitDate: +Date, components: +NSMutableArray, receivePort: +NSPort, headerSpaceReserved: number) -> bool"
			},
			"delegate": {
				"!type": "fn() -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMessagePort"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioSessionChannelDescription": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioSessionChannelDescription"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioSessionChannelDescription"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioSessionChannelDescription"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"owningPortUID": {
				"!type": "string"
			},
			"channelNumber": {
				"!type": "number"
			},
			"channelName": {
				"!type": "string"
			},
			"channelLabel": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioSessionChannelDescription"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioCompressedBuffer": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioCompressedBuffer"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioCompressedBuffer"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioCompressedBuffer"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"byteLength": {
				"!type": "number"
			},
			"maximumPacketSize": {
				"!type": "number"
			},
			"packetCount": {
				"!type": "number"
			},
			"packetCapacity": {
				"!type": "number"
			},
			"byteCapacity": {
				"!type": "number"
			},
			"format": {
				"!type": "+AVAudioFormat"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithFormatPacketCapacity": {
				"!type": "fn(format: +AVAudioFormat, packetCapacity: number) -> +AVAudioCompressedBuffer"
			},
			"initWithFormatPacketCapacityMaximumPacketSize": {
				"!type": "fn(format: +AVAudioFormat, packetCapacity: number, maximumPacketSize: number) -> +AVAudioCompressedBuffer"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioCompressedBuffer"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSURLProtocol": {
		"requestIsCacheEquivalentToRequest": {
			"!type": "fn(a: +NSURLRequest, b: +NSURLRequest) -> bool"
		},
		"canonicalRequestForRequest": {
			"!type": "fn(request: +NSURLRequest) -> +NSURLRequest"
		},
		"setPropertyForKeyInRequest": {
			"!type": "fn(value: +Object, key: string, request: +NSMutableURLRequest) -> void"
		},
		"registerClass": {
			"!type": "fn(protocolClass: +Object) -> bool"
		},
		"removePropertyForKeyInRequest": {
			"!type": "fn(key: string, request: +NSMutableURLRequest) -> void"
		},
		"canInitWithTask": {
			"!type": "fn(task: +NSURLSessionTask) -> bool"
		},
		"propertyForKeyInRequest": {
			"!type": "fn(key: string, request: +NSURLRequest) -> +Object"
		},
		"canInitWithRequest": {
			"!type": "fn(request: +NSURLRequest) -> bool"
		},
		"unregisterClass": {
			"!type": "fn(protocolClass: +Object) -> void"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSURLProtocol"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSURLProtocol"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSURLProtocol"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"cachedResponse": {
				"!type": "+NSCachedURLResponse"
			},
			"client": {
				"!type": "+Object"
			},
			"request": {
				"!type": "+NSURLRequest"
			},
			"task": {
				"!type": "+NSURLSessionTask"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"startLoading": {
				"!type": "fn() -> void"
			},
			"initWithTaskCachedResponseClient": {
				"!type": "fn(task: +NSURLSessionTask, cachedResponse: +NSCachedURLResponse, client: +Object) -> +NSURLProtocol"
			},
			"initWithRequestCachedResponseClient": {
				"!type": "fn(request: +NSURLRequest, cachedResponse: +NSCachedURLResponse, client: +Object) -> +NSURLProtocol"
			},
			"stopLoading": {
				"!type": "fn() -> void"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSURLProtocol"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVAudioConnectionPoint": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVAudioConnectionPoint"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVAudioConnectionPoint"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVAudioConnectionPoint"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"node": {
				"!type": "+AVAudioNode"
			},
			"bus": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithNodeBus": {
				"!type": "fn(node: +AVAudioNode, bus: number) -> +AVAudioConnectionPoint"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVAudioConnectionPoint"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMetadataGroup": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMetadataGroup"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMetadataGroup"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMetadataGroup"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"items": {
				"!type": "+Array"
			},
			"classifyingLabel": {
				"!type": "string"
			},
			"uniqueID": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMetadataGroup"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSCalendar": {
		"currentCalendar": {
			"!type": "fn() -> +NSCalendar"
		},
		"autoupdatingCurrentCalendar": {
			"!type": "fn() -> +NSCalendar"
		},
		"calendarWithIdentifier": {
			"!type": "fn(calendarIdentifierConstant: string) -> +NSCalendar"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSCalendar"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSCalendar"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSCalendar"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"standaloneWeekdaySymbols": {
				"!type": "+Array"
			},
			"longEraSymbols": {
				"!type": "+Array"
			},
			"weekdaySymbols": {
				"!type": "+Array"
			},
			"locale": {
				"!type": "+NSLocale"
			},
			"veryShortMonthSymbols": {
				"!type": "+Array"
			},
			"shortQuarterSymbols": {
				"!type": "+Array"
			},
			"shortStandaloneQuarterSymbols": {
				"!type": "+Array"
			},
			"PMSymbol": {
				"!type": "string"
			},
			"shortStandaloneMonthSymbols": {
				"!type": "+Array"
			},
			"eraSymbols": {
				"!type": "+Array"
			},
			"veryShortWeekdaySymbols": {
				"!type": "+Array"
			},
			"AMSymbol": {
				"!type": "string"
			},
			"shortStandaloneWeekdaySymbols": {
				"!type": "+Array"
			},
			"timeZone": {
				"!type": "+NSTimeZone"
			},
			"shortWeekdaySymbols": {
				"!type": "+Array"
			},
			"quarterSymbols": {
				"!type": "+Array"
			},
			"shortMonthSymbols": {
				"!type": "+Array"
			},
			"calendarIdentifier": {
				"!type": "string"
			},
			"standaloneMonthSymbols": {
				"!type": "+Array"
			},
			"standaloneQuarterSymbols": {
				"!type": "+Array"
			},
			"minimumDaysInFirstWeek": {
				"!type": "number"
			},
			"veryShortStandaloneMonthSymbols": {
				"!type": "+Array"
			},
			"monthSymbols": {
				"!type": "+Array"
			},
			"veryShortStandaloneWeekdaySymbols": {
				"!type": "+Array"
			},
			"firstWeekday": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"ordinalityOfUnitInUnitForDate": {
				"!type": "fn(smaller: number, larger: number, date: +Date) -> number"
			},
			"dateBySettingUnitValueOfDateOptions": {
				"!type": "fn(unit: number, v: number, date: +Date, opts: number) -> +Date"
			},
			"rangeOfUnitStartDateIntervalForDate": {
				"!type": "fn(unit: number, datep: +Object, tip: +Object, date: +Date) -> bool"
			},
			"nextWeekendStartDateIntervalOptionsAfterDate": {
				"!type": "fn(datep: +Object, tip: +Object, options: number, date: +Date) -> bool"
			},
			"dateWithEraYearForWeekOfYearWeekOfYearWeekdayHourMinuteSecondNanosecond": {
				"!type": "fn(eraValue: number, yearValue: number, weekValue: number, weekdayValue: number, hourValue: number, minuteValue: number, secondValue: number, nanosecondValue: number) -> +Date"
			},
			"isDateInWeekend": {
				"!type": "fn(date: +Date) -> bool"
			},
			"dateFromComponents": {
				"!type": "fn(comps: +NSDateComponents) -> +Date"
			},
			"dateByAddingUnitValueToDateOptions": {
				"!type": "fn(unit: number, value: number, date: +Date, options: number) -> +Date"
			},
			"nextDateAfterDateMatchingHourMinuteSecondOptions": {
				"!type": "fn(date: +Date, hourValue: number, minuteValue: number, secondValue: number, options: number) -> +Date"
			},
			"dateByAddingComponentsToDateOptions": {
				"!type": "fn(comps: +NSDateComponents, date: +Date, opts: number) -> +Date"
			},
			"isDateInTomorrow": {
				"!type": "fn(date: +Date) -> bool"
			},
			"maximumRangeOfUnit": {
				"!type": "fn(unit: number) -> +Object"
			},
			"initWithCalendarIdentifier": {
				"!type": "fn(ident: string) -> +Object"
			},
			"dateBySettingHourMinuteSecondOfDateOptions": {
				"!type": "fn(h: number, m: number, s: number, date: +Date, opts: number) -> +Date"
			},
			"componentFromDate": {
				"!type": "fn(unit: number, date: +Date) -> number"
			},
			"componentsFromDateComponentsToDateComponentsOptions": {
				"!type": "fn(unitFlags: number, startingDateComp: +NSDateComponents, resultDateComp: +NSDateComponents, options: number) -> +NSDateComponents"
			},
			"isDateInYesterday": {
				"!type": "fn(date: +Date) -> bool"
			},
			"isDateInSameDayAsDate": {
				"!type": "fn(date1: +Date, date2: +Date) -> bool"
			},
			"getHourMinuteSecondNanosecondFromDate": {
				"!type": "fn(hourValuePointer: +Object, minuteValuePointer: +Object, secondValuePointer: +Object, nanosecondValuePointer: +Object, date: +Date) -> void"
			},
			"startOfDayForDate": {
				"!type": "fn(date: +Date) -> +Date"
			},
			"compareDateToDateToUnitGranularity": {
				"!type": "fn(date1: +Date, date2: +Date, unit: number) -> number"
			},
			"enumerateDatesStartingAfterDateMatchingComponentsOptionsUsingBlock": {
				"!type": "fn(start: +Date, comps: +NSDateComponents, opts: number, block: +Function) -> void"
			},
			"componentsInTimeZoneFromDate": {
				"!type": "fn(timezone: +NSTimeZone, date: +Date) -> +NSDateComponents"
			},
			"getEraYearMonthDayFromDate": {
				"!type": "fn(eraValuePointer: +Object, yearValuePointer: +Object, monthValuePointer: +Object, dayValuePointer: +Object, date: +Date) -> void"
			},
			"isDateEqualToDateToUnitGranularity": {
				"!type": "fn(date1: +Date, date2: +Date, unit: number) -> bool"
			},
			"dateMatchesComponents": {
				"!type": "fn(date: +Date, components: +NSDateComponents) -> bool"
			},
			"componentsFromDate": {
				"!type": "fn(unitFlags: number, date: +Date) -> +NSDateComponents"
			},
			"getEraYearForWeekOfYearWeekOfYearWeekdayFromDate": {
				"!type": "fn(eraValuePointer: +Object, yearValuePointer: +Object, weekValuePointer: +Object, weekdayValuePointer: +Object, date: +Date) -> void"
			},
			"isDateInToday": {
				"!type": "fn(date: +Date) -> bool"
			},
			"dateWithEraYearMonthDayHourMinuteSecondNanosecond": {
				"!type": "fn(eraValue: number, yearValue: number, monthValue: number, dayValue: number, hourValue: number, minuteValue: number, secondValue: number, nanosecondValue: number) -> +Date"
			},
			"nextDateAfterDateMatchingUnitValueOptions": {
				"!type": "fn(date: +Date, unit: number, value: number, options: number) -> +Date"
			},
			"rangeOfUnitInUnitForDate": {
				"!type": "fn(smaller: number, larger: number, date: +Date) -> +Object"
			},
			"minimumRangeOfUnit": {
				"!type": "fn(unit: number) -> +Object"
			},
			"componentsFromDateToDateOptions": {
				"!type": "fn(unitFlags: number, startingDate: +Date, resultDate: +Date, opts: number) -> +NSDateComponents"
			},
			"nextDateAfterDateMatchingComponentsOptions": {
				"!type": "fn(date: +Date, comps: +NSDateComponents, options: number) -> +Date"
			},
			"rangeOfWeekendStartDateIntervalContainingDate": {
				"!type": "fn(datep: +Object, tip: +Object, date: +Date) -> bool"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSCalendar"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVMetadataItemFilter": {
		"metadataItemFilterForSharing": {
			"!type": "fn() -> +AVMetadataItemFilter"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVMetadataItemFilter"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVMetadataItemFilter"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVMetadataItemFilter"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVMetadataItemFilter"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSMethodSignature": {
		"signatureWithObjCTypes": {
			"!type": "fn(types: +Object) -> +NSMethodSignature"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSMethodSignature"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSMethodSignature"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSMethodSignature"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"numberOfArguments": {
				"!type": "number"
			},
			"methodReturnLength": {
				"!type": "number"
			},
			"frameLength": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"isOneway": {
				"!type": "fn() -> bool"
			},
			"getArgumentTypeAtIndex": {
				"!type": "fn(idx: number) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSMethodSignature"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"NSRegularExpression": {
		"regularExpressionWithPatternOptionsError": {
			"!type": "fn(pattern: string, options: number, error: +Object) -> +NSRegularExpression"
		},
		"escapedTemplateForString": {
			"!type": "fn(string: string) -> string"
		},
		"escapedPatternForString": {
			"!type": "fn(string: string) -> string"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +NSRegularExpression"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +NSRegularExpression"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +NSRegularExpression"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"pattern": {
				"!type": "string"
			},
			"options": {
				"!type": "number"
			},
			"numberOfCaptureGroups": {
				"!type": "number"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithPatternOptionsError": {
				"!type": "fn(pattern: string, options: number, error: +Object) -> +NSRegularExpression"
			},
			"numberOfMatchesInStringOptionsRange": {
				"!type": "fn(string: string, options: number, range: +Object) -> number"
			},
			"matchesInStringOptionsRange": {
				"!type": "fn(string: string, options: number, range: +Object) -> +Array"
			},
			"stringByReplacingMatchesInStringOptionsRangeWithTemplate": {
				"!type": "fn(string: string, options: number, range: +Object, templ: string) -> string"
			},
			"enumerateMatchesInStringOptionsRangeUsingBlock": {
				"!type": "fn(string: string, options: number, range: +Object, block: +Function) -> void"
			},
			"rangeOfFirstMatchInStringOptionsRange": {
				"!type": "fn(string: string, options: number, range: +Object) -> +Object"
			},
			"firstMatchInStringOptionsRange": {
				"!type": "fn(string: string, options: number, range: +Object) -> +NSTextCheckingResult"
			},
			"replaceMatchesInStringOptionsRangeWithTemplate": {
				"!type": "fn(string: +NSMutableString, options: number, range: +Object, templ: string) -> number"
			},
			"replacementStringForResultInStringOffsetTemplate": {
				"!type": "fn(result: +NSTextCheckingResult, string: string, offset: number, templ: string) -> string"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +NSRegularExpression"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVPlayerItemVideoOutput": {
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVPlayerItemVideoOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVPlayerItemVideoOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVPlayerItemVideoOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"delegate": {
				"!type": "+Object"
			},
			"suppressesPlayerRendering": {
				"!type": "bool"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"initWithPixelBufferAttributes": {
				"!type": "fn(pixelBufferAttributes: +Object) -> +AVPlayerItemVideoOutput"
			},
			"hasNewPixelBufferForItemTime": {
				"!type": "fn(itemTime: +Object) -> bool"
			},
			"copyPixelBufferForItemTimeItemTimeForDisplay": {
				"!type": "fn(itemTime: +Object, outItemTimeForDisplay: +Object) -> +Object"
			},
			"setDelegateQueue": {
				"!type": "fn(delegate: +Object, delegateQueue: +Object) -> void"
			},
			"requestNotificationOfMediaDataChangeWithAdvanceInterval": {
				"!type": "fn(interval: number) -> void"
			},
			"initWithOutputSettings": {
				"!type": "fn(outputSettings: +Object) -> +AVPlayerItemVideoOutput"
			},
			"itemTimeForHostTime": {
				"!type": "fn(hostTimeInSeconds: number) -> +Object"
			},
			"itemTimeForMachAbsoluteTime": {
				"!type": "fn(machAbsoluteTime: number) -> +Object"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVPlayerItemVideoOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AUParameterTree": {
		"createGroupFromTemplateIdentifierNameAddressOffset": {
			"!type": "fn(templateGroup: +AUParameterGroup, identifier: string, name: string, addressOffset: number) -> +AUParameterGroup"
		},
		"createGroupTemplate": {
			"!type": "fn(children: +Array) -> +AUParameterGroup"
		},
		"createGroupWithIdentifierNameChildren": {
			"!type": "fn(identifier: string, name: string, children: +Array) -> +AUParameterGroup"
		},
		"createParameterWithIdentifierNameAddressMinMaxUnitUnitNameFlagsValueStringsDependentParameters": {
			"!type": "fn(identifier: string, name: string, address: number, min: number, max: number, unit: number, unitName: string, flags: number, valueStrings: +Array, dependentParameters: +Array) -> +AUParameter"
		},
		"createTreeWithChildren": {
			"!type": "fn(children: +Array) -> +AUParameterTree"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AUParameterTree"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AUParameterTree"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AUParameterTree"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"allParameters": {
				"!type": "+Array"
			},
			"children": {
				"!type": "+Array"
			},
			"displayName": {
				"!type": "string"
			},
			"jsimplementorDisplayNameWithLengthCallback": {
				"!type": "+Function"
			},
			"jsimplementorValueFromStringCallback": {
				"!type": "+Function"
			},
			"jsimplementorStringFromValueCallback": {
				"!type": "+Function"
			},
			"jsimplementorValueProvider": {
				"!type": "+Function"
			},
			"jsimplementorValueObserver": {
				"!type": "+Function"
			},
			"identifier": {
				"!type": "string"
			},
			"keyPath": {
				"!type": "string"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"parameterWithAddress": {
				"!type": "fn(address: number) -> +AUParameter"
			},
			"parameterWithIDScopeElement": {
				"!type": "fn(paramID: number, scope: number, element: number) -> +AUParameter"
			},
			"tokenByAddingParameterObserver": {
				"!type": "fn(observer: +Function) -> +Object"
			},
			"tokenByAddingParameterAutomationObserver": {
				"!type": "fn(observer: +Function) -> +Object"
			},
			"removeParameterObserver": {
				"!type": "fn(token: +Object) -> void"
			},
			"tokenByAddingParameterRecordingObserver": {
				"!type": "fn(observer: +Function) -> +Object"
			},
			"displayNameWithLength": {
				"!type": "fn(maximumLength: number) -> string"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AUParameterTree"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVCaptureDepthDataOutput": {
		"jsnew": {
			"!type": "fn() -> +AVCaptureDepthDataOutput"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVCaptureDepthDataOutput"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVCaptureDepthDataOutput"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVCaptureDepthDataOutput"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"filteringEnabled": {
				"!type": "bool"
			},
			"alwaysDiscardsLateDepthData": {
				"!type": "bool"
			},
			"delegate": {
				"!type": "+Object"
			},
			"connections": {
				"!type": "+Array"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"setDelegateCallbackQueue": {
				"!type": "fn(delegate: +Object, callbackQueue: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureDepthDataOutput"
			},
			"metadataOutputRectOfInterestForRect": {
				"!type": "fn(rectInOutputCoordinates: +Object) -> +Object"
			},
			"transformedMetadataObjectForMetadataObjectConnection": {
				"!type": "fn(metadataObject: +AVMetadataObject, connection: +AVCaptureConnection) -> +AVMetadataObject"
			},
			"rectForMetadataOutputRectOfInterest": {
				"!type": "fn(rectInMetadataOutputCoordinates: +Object) -> +Object"
			},
			"connectionWithMediaType": {
				"!type": "fn(mediaType: string) -> +AVCaptureConnection"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVCaptureDepthDataOutput"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	},
	"AVSemanticSegmentationMatte": {
		"semanticSegmentationMatteFromImageSourceAuxiliaryDataTypeDictionaryRepresentationError": {
			"!type": "fn(imageSourceAuxiliaryDataType: +Object, imageSourceAuxiliaryDataInfoDictionary: +Object, outError: +Object) -> +AVSemanticSegmentationMatte"
		},
		"load": {
			"!type": "fn() -> void"
		},
		"mutableCopyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"hash": {
			"!type": "fn() -> number"
		},
		"description": {
			"!type": "fn() -> string"
		},
		"instancesRespondToSelector": {
			"!type": "fn(aSelector: string) -> bool"
		},
		"copyWithZone": {
			"!type": "fn(zone: +Object) -> +Object"
		},
		"setVersion": {
			"!type": "fn(aVersion: number) -> void"
		},
		"conformsToProtocol": {
			"!type": "fn(protocol: +Protocol) -> bool"
		},
		"accessInstanceVariablesDirectly": {
			"!type": "fn() -> bool"
		},
		"superclass": {
			"!type": "fn() -> +Object"
		},
		"initialize": {
			"!type": "fn() -> void"
		},
		"keyPathsForValuesAffectingValueForKey": {
			"!type": "fn(key: string) -> +NSSet"
		},
		"class": {
			"!type": "fn() -> +Object"
		},
		"instanceMethodSignatureForSelector": {
			"!type": "fn(aSelector: string) -> +NSMethodSignature"
		},
		"alloc": {
			"!type": "fn() -> +AVSemanticSegmentationMatte"
		},
		"cancelPreviousPerformRequestsWithTarget": {
			"!type": "fn(aTarget: +Object) -> void"
		},
		"automaticallyNotifiesObserversForKey": {
			"!type": "fn(key: string) -> bool"
		},
		"debugDescription": {
			"!type": "fn() -> string"
		},
		"classFallbacksForKeyedArchiver": {
			"!type": "fn() -> +Array"
		},
		"resolveInstanceMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"version": {
			"!type": "fn() -> number"
		},
		"resolveClassMethod": {
			"!type": "fn(sel: string) -> bool"
		},
		"isSubclassOfClass": {
			"!type": "fn(aClass: +Object) -> bool"
		},
		"allocWithZone": {
			"!type": "fn(zone: +Object) -> +AVSemanticSegmentationMatte"
		},
		"instanceMethodForSelector": {
			"!type": "fn(aSelector: string) -> +Object"
		},
		"jsnew": {
			"!type": "fn() -> +AVSemanticSegmentationMatte"
		},
		"classForKeyedUnarchiver": {
			"!type": "fn() -> +Object"
		},
		"cancelPreviousPerformRequestsWithTargetSelectorObject": {
			"!type": "fn(aTarget: +Object, aSelector: string, anArgument: +Object) -> void"
		},
		"prototype": {
			"pixelFormatType": {
				"!type": "number"
			},
			"matteType": {
				"!type": "string"
			},
			"mattingImage": {
				"!type": "+Object"
			},
			"jsclassForKeyedArchiver": {
				"!type": "+Object"
			},
			"jsclassForCoder": {
				"!type": "+Object"
			},
			"autoContentAccessingProxy": {
				"!type": "+Object"
			},
			"semanticSegmentationMatteByReplacingSemanticSegmentationMatteWithPixelBufferError": {
				"!type": "fn(pixelBuffer: +Object, outError: +Object) -> +AVSemanticSegmentationMatte"
			},
			"dictionaryRepresentationForAuxiliaryDataType": {
				"!type": "fn(outAuxDataType: +Object) -> +Object"
			},
			"semanticSegmentationMatteByApplyingExifOrientation": {
				"!type": "fn(exifOrientation: number) -> +AVSemanticSegmentationMatte"
			},
			"awakeAfterUsingCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"dictionaryWithValuesForKeys": {
				"!type": "fn(keys: +Array) -> +Object"
			},
			"methodForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"performSelectorWithObjectAfterDelayInModes": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number, modes: +Array) -> void"
			},
			"mutableArrayValueForKey": {
				"!type": "fn(key: string) -> +NSMutableArray"
			},
			"willChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number, delegate: +Object, didRecoverSelector: string, contextInfo: +Object) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool) -> void"
			},
			"addObserverForKeyPathOptionsContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, options: number, context: +Object) -> void"
			},
			"didChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"setNilValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"setValueForKeyPath": {
				"!type": "fn(value: +Object, keyPath: string) -> void"
			},
			"replacementObjectForCoder": {
				"!type": "fn(coder: +NSCoder) -> +Object"
			},
			"jsmutableCopy": {
				"!type": "fn() -> +Object"
			},
			"performSelectorOnThreadWithObjectWaitUntilDone": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool) -> void"
			},
			"removeObserverForKeyPathContext": {
				"!type": "fn(observer: +NSObject, keyPath: string, context: +Object) -> void"
			},
			"fileManagerWillProcessPath": {
				"!type": "fn(fm: +NSFileManager, path: string) -> void"
			},
			"valueForUndefinedKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"performSelectorInBackgroundWithObject": {
				"!type": "fn(aSelector: string, arg: +Object) -> void"
			},
			"jsinit": {
				"!type": "fn() -> +AVSemanticSegmentationMatte"
			},
			"mutableArrayValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableArray"
			},
			"setValueForKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"performSelectorOnMainThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, arg: +Object, wait: bool, array: +Array) -> void"
			},
			"mutableOrderedSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableOrderedSet"
			},
			"forwardingTargetForSelector": {
				"!type": "fn(aSelector: string) -> +Object"
			},
			"validateValueForKeyPathError": {
				"!type": "fn(ioValue: +Object, inKeyPath: string, outError: +Object) -> bool"
			},
			"valueForKey": {
				"!type": "fn(key: string) -> +Object"
			},
			"finalize": {
				"!type": "fn() -> void"
			},
			"mutableSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableSet"
			},
			"validateValueForKeyError": {
				"!type": "fn(ioValue: +Object, inKey: string, outError: +Object) -> bool"
			},
			"attemptRecoveryFromErrorOptionIndex": {
				"!type": "fn(error: +NSError, recoveryOptionIndex: number) -> bool"
			},
			"forwardInvocation": {
				"!type": "fn(anInvocation: +NSInvocation) -> void"
			},
			"removeObserverForKeyPath": {
				"!type": "fn(observer: +NSObject, keyPath: string) -> void"
			},
			"dealloc": {
				"!type": "fn() -> void"
			},
			"performSelectorWithObjectAfterDelay": {
				"!type": "fn(aSelector: string, anArgument: +Object, delay: number) -> void"
			},
			"jscopy": {
				"!type": "fn() -> +Object"
			},
			"setValuesForKeysWithDictionary": {
				"!type": "fn(keyedValues: +Object) -> void"
			},
			"mutableSetValueForKeyPath": {
				"!type": "fn(keyPath: string) -> +NSMutableSet"
			},
			"didChangeValuesAtIndexesForKey": {
				"!type": "fn(changeKind: number, indexes: +NSIndexSet, key: string) -> void"
			},
			"didChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"mutableOrderedSetValueForKey": {
				"!type": "fn(key: string) -> +NSMutableOrderedSet"
			},
			"methodSignatureForSelector": {
				"!type": "fn(aSelector: string) -> +NSMethodSignature"
			},
			"observeValueForKeyPathOfObjectChangeContext": {
				"!type": "fn(keyPath: string, object: +Object, change: +Object, context: +Object) -> void"
			},
			"setValueForUndefinedKey": {
				"!type": "fn(value: +Object, key: string) -> void"
			},
			"valueForKeyPath": {
				"!type": "fn(keyPath: string) -> +Object"
			},
			"replacementObjectForKeyedArchiver": {
				"!type": "fn(archiver: +NSKeyedArchiver) -> +Object"
			},
			"willChangeValueForKey": {
				"!type": "fn(key: string) -> void"
			},
			"doesNotRecognizeSelector": {
				"!type": "fn(aSelector: string) -> void"
			},
			"willChangeValueForKeyWithSetMutationUsingObjects": {
				"!type": "fn(key: string, mutationKind: number, objects: +NSSet) -> void"
			},
			"fileManagerShouldProceedAfterError": {
				"!type": "fn(fm: +NSFileManager, errorInfo: +Object) -> bool"
			},
			"performSelectorOnThreadWithObjectWaitUntilDoneModes": {
				"!type": "fn(aSelector: string, thr: +NSThread, arg: +Object, wait: bool, array: +Array) -> void"
			}
		}
	}
}
